C51 COMPILER V9.00   MAIN                                                                  05/19/2016 09:22:46 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\out\main.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c LARGE BROWSE DEBUG OBJECTEXTEND PRINT(.\lst\main.lst) OBJECT(.\out\m
                    -ain.obj)

line level    source

   1          #include "led_display.h"
   2          #include "sys.h"
   3          //#include"led.h"       
   4          #include "eeprom.h"
   5          #include "uart.h"
   6          #include "global.h"
   7          #include "main.h"
   8          #include <string.h>
   9          
  10          //#define uint unsigned int
  11          //#define uchar unsigned char
  12          
  13          
  14          #define FOSC 11059200L
  15          
  16          #define T1MS (65536-FOSC/12/1000) //12T模式
  17          
  18          
  19          extern xdata public_stru public_val;
  20          
  21          char eeprom_en = 0;
  22          int iInitCnt = 0;
  23          
  24          /* 下行发送的帧类型 */
  25          //char send_frame_type = 0xff;
  26          char send_frame_type = UP_REPLY_DONE;
  27          
  28          unsigned int cnt_read_state = 0;
  29          unsigned int cnt_read_param = 0;
  30          unsigned int cnt_read_param_range = 0;
  31          
  32          char already_read_param = 0;             /* 是否已读到配置参数:1已读到，0未读到 */
  33          //char send_read_param_flag = 0;       /* 是否已发送 */
  34          
  35          char already_read_param_range = 0;   /* 是否已读到配置参数范围:1已读到，0未读到 */
  36          
  37          char write_param_flag = 0;           /* 当前是否要写配置参数到主板:1需要，0不需要 */
  38          
  39          char write_test_mode_flag = 0;       /* 当前是否要写测试模式到主板:1需要，0不需要 */
  40          
  41          char write_learn_mode_flag = 0;      /* 当前是否要写学习模式到主板:1需要，0不需要 */
  42          
  43          char write_speed_mode_flag = 0;      /* 当前是否要写速度模式到主板:1需要，0不需要 */
  44          
  45          char write_warning_flag = 0;         /* 当前是否要写报警消息到主板:1需要，0不需要 */
  46          
  47          char write_clear_cnt_flag = 0;       /* 当前是否要写清除已出筒数到主板:1需要，0不需要 */
  48          char main_borad_finish_clear = 1;    /* 主板收到清除命令后已完成计数清零:1已完成，0未完成 */
  49          
  50          char write_key_flag = 0;             /* 当前是否要写按键到主板:1需要，0不需要 */
  51          
  52          char start_com_flag = 0;             /* 操作板开始串口通信的标志: 1开始，0未开始 */
  53          
  54          unsigned int usLongDownFlag = 0;     /* 长按下标志: 0未按下，1已按下 */
C51 COMPILER V9.00   MAIN                                                                  05/19/2016 09:22:46 PAGE 2   

  55          
  56          
  57          xdata _T_CHECK_EDGE2 t_FzFwKey = { 
  58                                                                          KEY_IO9_FZ_FW_MASK,
  59                                                                          888, 
  60                                                                          0, 
  61                                                                          0,
  62                                                                          0};
  63          
  64          xdata _T_CHECK_EDGE2 t_FzBwKey = { 
  65                                                                          KEY_RED_FZ_BW_MASK,
  66                                                                          888,  
  67                                                                          0, 
  68                                                                          0,
  69                                                                          0};
  70          
  71          
  72          xdata _T_CHECK_EDGE2 t_PaperFwKey = { //(unsigned short const *)&(unKey.all),
  73                                                                          KEY_IO1_PAPER_FW_MASK,
  74                                                                          888, 
  75                                                                          //40, 
  76                                                                          //500, 
  77                                                                          0, 
  78                                                                          0,
  79                                                                          0};
  80          
  81          xdata _T_CHECK_EDGE2 t_PaperBwKey = { 
  82                                                                          KEY_IO2_PAPER_BW_MASK,
  83                                                                          888,  
  84                                                                          0, 
  85                                                                          0,
  86                                                                          0};
  87          
  88          xdata _T_CHECK_EDGE2 t_CutKey = { 
  89                                                                          KEY_IO3_CUT_MASK,
  90                                                                          888,  
  91                                                                          0, 
  92                                                                          0,
  93                                                                          0};
  94          
  95          xdata _T_CHECK_EDGE2 t_PaperDownKey = { 
  96                                                                          KEY_IO4_PAPER_DOWN_MASK,
  97                                                                          888,  
  98                                                                          0, 
  99                                                                          0,
 100                                                                          0};
 101          
 102          xdata _T_CHECK_EDGE2 t_RollKey = { 
 103                                                                          KEY_IO5_ROLL_MASK,
 104                                                                          888,  
 105                                                                          0, 
 106                                                                          0,
 107                                                                          0};
 108          
 109          #if 0
              //pwm
              void Timer0Init(void)
              {
                  AUXR |= 0x80;                       //定时器0为1T模式
              //  AUXR &= 0x7f;                       //定时器0为12T模式
              
                  TMOD = 0x00;                    //设置定时器为模式0(16位自动重装载)
C51 COMPILER V9.00   MAIN                                                                  05/19/2016 09:22:46 PAGE 3   

              
                      //TL0 = 0xfd;                     //初始化计时值
                  TL0 = ZL_PWM_FREQ;                        /* 初始化为直流电机的PWM频率248 by james */
                  
                  TH0 = 0xff;
                  TR0 = 1;                        //定时器0开始计时
               //   ET0 = 1;                        //使能定时器0中断
              }
              
              void Timer1Init(void)
              {
                  AUXR |= 0x40;                //定时器1为1T模式
                      TMOD &= 0x0f;           //设置定时器模式
                      TL1 = 0xCB;             //设置定时初值
                      TH1 = 0xD4;         //设置定时初值
                      TF1 = 0;                //清除TF0标志
                  IP |= 0x08;
              //      TR1 = 1;                //定时器0开始计时
              }
              
              void Timer2Init(void)
              {
                  AUXR |= 0x04;
                  T2L = 0xCB;                     //初始化计时值
                  T2H = 0xD4;
                  AUXR |= 0x10;                   //定时器2开始计时
              }
              
              
              void sys_init(void)                //系统初始化函数
              {
                P2M1 = 0x01;
                P2M0 = 0xC1; //11000001
                
                P3M1 = 0x00;
                P3M0 = 0x6B; //01101011
              
                P1M1 = 0x00;
                P1M0 = 0x04; //00000100
              
                
                P0 = 0xff;             //io口初始化
                P1 = 0xff;
                P2 = 0xff;
                P3 = 0x9f;             //步进电机初始化为不使能 
                
                //Timer0Init();  // pwm
                //Timer2Init();  // 1ms主逻辑中断
                
                //pwm_init();
              
                //Timer1Init();  // 步进脉冲翻转
                
              }
              
              #endif
 173          
 174          
 175          void Timer0Init(void)
 176          {
 177   1          AUXR |= 0x80;                       //定时器0为1T模式
 178   1      //  AUXR &= 0x7f;                       //定时器0为12T模式
C51 COMPILER V9.00   MAIN                                                                  05/19/2016 09:22:46 PAGE 4   

 179   1      
 180   1          TMOD = 0x00;                    //设置定时器为模式0(16位自动重装载)
 181   1          TL0 = T1MS;                     //初始化计时值
 182   1          TH0 = T1MS >> 8;
 183   1          TR0 = 1;                        //定时器0开始计时
 184   1          ET0 = 1;                        //使能定时器0中断
 185   1          EA = 1;
 186   1      }
 187          
 188          void sys_init(void)                //系统初始化函数
 189          {
 190   1              P2M1 = 0x00;
 191   1              P2M0 = 0x20;
 192   1      
 193   1              P0 = 0xff;             //io口初始化
 194   1              P1 = 0xff;
 195   1              P2 = 0xff;
 196   1              P3 = 0xff; 
 197   1      
 198   1              Timer0Init();
 199   1              uart_init();
 200   1              
 201   1      #ifndef LED_DISP
 202   1              uart2_init(); 
 203   1      #endif  
 204   1        
 205   1      }
 206          
 207          
 208          void GlobalInit()
 209          {
 210   1              memset(&public_val, 0, sizeof(public_val));     
 211   1      
 212   1              speed_mode = 1;  // 高速模式
 213   1      }
 214          
 215          
 216          
 217          
 218          ///踏板长按识别
 219          
 220          #if 1
 221          void CheckKeyClick(_T_CHECK_EDGE2 *p)
 222          {
 223   1              switch(p->us_logStep)
 224   1              {
 225   2              case 0:
 226   2                      
 227   2                      p->us_finishFlag = 0;
 228   2                      if( !(unKey.all & p->us_inMask) )                                                                               
 229   2                      {
 230   3                              p->us_logStep = 10;
 231   3                              p->us_DownCnt = 0;
 232   3                      }
 233   2                      
 234   2                      break;
 235   2                      
 236   2              case 10:
 237   2      
 238   2                      if( !(unKey.all & p->us_inMask) )                                                                               
 239   2                      {
 240   3                              p->us_DownCnt++;
C51 COMPILER V9.00   MAIN                                                                  05/19/2016 09:22:46 PAGE 5   

 241   3                              if(p->us_DownCnt > KEY_JIT_DELAY)                       ///<按下                                                
 242   3                              {
 243   4                                      //p->us_finishFlag = FOOT_DOWN_FLAG;   
 244   4      
 245   4                                      p->us_logStep = 20;   
 246   4                              }
 247   3                      }
 248   2                      else
 249   2                      {
 250   3                              p->us_DownCnt = 0;
 251   3                              p->us_logStep = 0;
 252   3                      }
 253   2                      
 254   2                      break;  
 255   2                      
 256   2              case 20:
 257   2                      
 258   2                      p->us_DownCnt++;
 259   2                      
 260   2                      if (unKey.all & p->us_inMask)   
 261   2                      {
 262   3                              p->us_logStep = 30;
 263   3                              p->us_UpCnt = 0;
 264   3                      }
 265   2      
 266   2                      if (p->us_DownCnt > KEY_LONG_DELAY)
 267   2                      {
 268   3                              p->us_finishFlag = KEY_LONG_DOWN_FLAG;   /* 判为长按按下 */   
 269   3      
 270   3                              //p->us_logStep = 30;
 271   3                      }
 272   2                      
 273   2                      break;
 274   2      
 275   2              case 30:
 276   2      
 277   2                      p->us_DownCnt++;
 278   2      
 279   2                      if (unKey.all & p->us_inMask)    
 280   2                      {
 281   3                              p->us_UpCnt++;
 282   3                              if(p->us_UpCnt > KEY_JIT_DELAY)   /* 弹起 */                                                                    
 283   3                              {
 284   4                                      //if (p->us_DownCnt > KEY_LONG_DELAY)     
 285   4                                      if (p->us_finishFlag == KEY_LONG_DOWN_FLAG)
 286   4                                      {
 287   5                                              p->us_finishFlag = KEY_LONG_UP_FLAG;   /* 判为长按抬起 */   
 288   5                                      }
 289   4                                      else
 290   4                                      {
 291   5                                              p->us_finishFlag = KEY_SHORT_UP_FLAG;  /* 判为短按 */
 292   5                                      }
 293   4      
 294   4                                      p->us_DownCnt = 0;                              
 295   4                                      p->us_logStep = 888;                            
 296   4                              }
 297   3                      }
 298   2                      else
 299   2                      {
 300   3                              p->us_UpCnt = 0;
 301   3                              p->us_logStep = 20;
 302   3                      }
C51 COMPILER V9.00   MAIN                                                                  05/19/2016 09:22:46 PAGE 6   

 303   2                      
 304   2                      break;
 305   2                      
 306   2              }
 307   1              
 308   1      }
 309          
 310          #else
              
              void CheckKeyClick(_T_CHECK_EDGE2 *p)
              {
                      switch(p->us_logStep)
                      {
                      case 0:
                              
                              p->us_finishFlag = 0;
                              if( !(unKey.all & p->us_inMask) )                                                                               
                              {
                                      p->us_logStep = 10;
                                      p->us_DownCnt = 0;
                              }
                              
                              break;
                              
                      case 10:
              
                              if( !(unKey.all & p->us_inMask) )                                                                               
                              {
                                      p->us_DownCnt++;
                                      if(p->us_DownCnt > KEY_JIT_DELAY)                       ///<按下                                                
                                      {
                                              p->us_finishFlag = KEY_LONG_DOWN_FLAG;   /* 判为长按按下 */     
              
                                              p->us_DownCnt = 0;
                                              p->us_logStep = 20;   
                                      }
                              }
                              else
                              {
                                      p->us_DownCnt = 0;
                                      p->us_logStep = 0;
                              }
                              
                              break;  
                              
                      case 20:                
                              
                              if (unKey.all & p->us_inMask)   
                              {
                                      p->us_logStep = 30;
                                      p->us_UpCnt = 0;
                              }
                              
                              break;
              
                      case 30:
              
                              if (unKey.all & p->us_inMask)    
                              {
                                      p->us_UpCnt++;
                                      if(p->us_UpCnt > KEY_JIT_DELAY)   /* 弹起 */                                                                    
                                      {
C51 COMPILER V9.00   MAIN                                                                  05/19/2016 09:22:46 PAGE 7   

                                              p->us_finishFlag = KEY_LONG_UP_FLAG;   /* 判为长按抬起 */   
              
                                              p->us_UpCnt = 0;                                
                                              p->us_logStep = 888;                            
                                      }
                              }
                              else
                              {
                                      p->us_UpCnt = 0;
                                      p->us_logStep = 20;
                              }
                              
                              break;
                              
                      }
                      
              }
              
              #endif
 384          
 385          
 386          void key_detect()
 387          {       
 388   1              unKey.u_bit.K1 = P24;
 389   1              unKey.u_bit.K2 = P23;
 390   1              unKey.u_bit.K3 = P22;
 391   1              unKey.u_bit.K4 = P21;
 392   1              
 393   1              unKey.u_bit.IO1 = P20;
 394   1              unKey.u_bit.IO2 = P35;
 395   1              unKey.u_bit.IO3 = P33;
 396   1              unKey.u_bit.IO4 = P32;
 397   1              unKey.u_bit.IO5 = P26;
 398   1              unKey.u_bit.IO6 = P27;
 399   1              unKey.u_bit.IO7 = P12;
 400   1              unKey.u_bit.IO8 = P13;
 401   1              unKey.u_bit.IO9 = P16;
 402   1      
 403   1              unKey.u_bit.RED = P17;
 404   1              unKey.u_bit.GREEN = P54;
 405   1              unKey.u_bit.BLUE = P55; 
 406   1      
 407   1              CheckKeyClick(&t_PaperFwKey);
 408   1              CheckKeyClick(&t_PaperBwKey);
 409   1              //CheckKeyClick(&t_CutKey);     
 410   1              CheckKeyClick(&t_PaperDownKey); 
 411   1              CheckKeyClick(&t_RollKey);      
 412   1              CheckKeyClick(&t_FzFwKey);              
 413   1              CheckKeyClick(&t_FzBwKey);              
 414   1      }
 415          
 416          void start_key_detect()
 417          {
 418   1              t_PaperFwKey.us_logStep = 0;
 419   1              t_PaperBwKey.us_logStep = 0;
 420   1              //t_CutKey.us_logStep = 0;
 421   1              t_PaperDownKey.us_logStep = 0;
 422   1              t_RollKey.us_logStep = 0;       
 423   1              t_FzFwKey.us_logStep = 0;
 424   1              t_FzBwKey.us_logStep = 0;       
 425   1      }
 426          
C51 COMPILER V9.00   MAIN                                                                  05/19/2016 09:22:46 PAGE 8   

 427          void judge_key()
 428          {
 429   1              // 发纸
 430   1              if (t_FzFwKey.us_finishFlag != 0) 
 431   1              {
 432   2                      gsKeyVal = KEY_IO9;
 433   2                      
 434   2                      if (t_FzFwKey.us_finishFlag == KEY_LONG_DOWN_FLAG)     /* 长按 */
 435   2                      {                       
 436   3                              gcKeyType = KEY_LONG_DOWN_FLAG;  
 437   3      
 438   3                              if (usLongDownFlag == 0)
 439   3                              {
 440   4                                      usLongDownFlag = 1;
 441   4      
 442   4                                      write_key_flag = 1;   /* 有按键，需要写按键到主板 */
 443   4                              }
 444   3                      }
 445   2                      else if (t_FzFwKey.us_finishFlag == KEY_SHORT_UP_FLAG) /* 短按 */
 446   2                      {
 447   3                              gcKeyType = KEY_SHORT_UP_FLAG;   
 448   3      
 449   3                              t_FzFwKey.us_finishFlag = 0;
 450   3                              t_FzFwKey.us_logStep = 0;                       
 451   3      
 452   3                              usLongDownFlag = 0;   /* 清长按标志 */
 453   3      
 454   3                              write_key_flag = 1;   /* 有按键，需要写按键到主板 */                    
 455   3                      }
 456   2                      else                                                       /* 长按抬起 */
 457   2                      {
 458   3                              gcKeyType = KEY_LONG_UP_FLAG;   
 459   3      
 460   3                              t_FzFwKey.us_finishFlag = 0;
 461   3                              t_FzFwKey.us_logStep = 0;                       
 462   3      
 463   3                              usLongDownFlag = 0;   /* 清长按标志 */
 464   3      
 465   3                              write_key_flag = 1;   /* 有按键，需要写按键到主板 */                    
 466   3                      }       
 467   2              }
 468   1      
 469   1              // 收纸
 470   1              if (t_FzBwKey.us_finishFlag != 0) 
 471   1              {
 472   2                      gsKeyVal = KEY_RED;
 473   2                      
 474   2                      if (t_FzBwKey.us_finishFlag == KEY_LONG_DOWN_FLAG)     /* 长按 */
 475   2                      {                       
 476   3                              gcKeyType = KEY_LONG_DOWN_FLAG;  
 477   3      
 478   3                              if (usLongDownFlag == 0)
 479   3                              {
 480   4                                      usLongDownFlag = 1;
 481   4      
 482   4                                      write_key_flag = 1;   /* 有按键，需要写按键到主板 */
 483   4                              }
 484   3                      }
 485   2                      else if (t_FzBwKey.us_finishFlag == KEY_SHORT_UP_FLAG) /* 短按 */
 486   2                      {
 487   3                              gcKeyType = KEY_SHORT_UP_FLAG;   
 488   3      
C51 COMPILER V9.00   MAIN                                                                  05/19/2016 09:22:46 PAGE 9   

 489   3                              t_FzBwKey.us_finishFlag = 0;
 490   3                              t_FzBwKey.us_logStep = 0;                       
 491   3      
 492   3                              usLongDownFlag = 0;   /* 清长按标志 */
 493   3      
 494   3                              write_key_flag = 1;   /* 有按键，需要写按键到主板 */                    
 495   3                      }
 496   2                      else                                                       /* 长按抬起 */
 497   2                      {
 498   3                              gcKeyType = KEY_LONG_UP_FLAG;   
 499   3      
 500   3                              t_FzBwKey.us_finishFlag = 0;
 501   3                              t_FzBwKey.us_logStep = 0;                       
 502   3      
 503   3                              usLongDownFlag = 0;   /* 清长按标志 */
 504   3      
 505   3                              write_key_flag = 1;   /* 有按键，需要写按键到主板 */                    
 506   3                      }       
 507   2              }
 508   1      
 509   1      
 510   1              
 511   1              /* 进纸 */
 512   1              if (t_PaperFwKey.us_finishFlag != 0) 
 513   1              {
 514   2                      gsKeyVal = KEY_IO1;
 515   2                      
 516   2                      if (t_PaperFwKey.us_finishFlag == KEY_LONG_DOWN_FLAG)     /* 长按 */
 517   2                      {                       
 518   3                              gcKeyType = KEY_LONG_DOWN_FLAG;  
 519   3      
 520   3                              if (usLongDownFlag == 0)
 521   3                              {
 522   4                                      usLongDownFlag = 1;
 523   4      
 524   4                                      write_key_flag = 1;   /* 有按键，需要写按键到主板 */
 525   4                              }
 526   3                      }
 527   2                      else if (t_PaperFwKey.us_finishFlag == KEY_SHORT_UP_FLAG) /* 短按 */
 528   2                      {
 529   3                              gcKeyType = KEY_SHORT_UP_FLAG;   
 530   3      
 531   3                              t_PaperFwKey.us_finishFlag = 0;
 532   3                              t_PaperFwKey.us_logStep = 0;                    
 533   3      
 534   3                              usLongDownFlag = 0;   /* 清长按标志 */
 535   3      
 536   3                              write_key_flag = 1;   /* 有按键，需要写按键到主板 */                    
 537   3                      }
 538   2                      else                                                       /* 长按抬起 */
 539   2                      {
 540   3                              gcKeyType = KEY_LONG_UP_FLAG;   
 541   3      
 542   3                              t_PaperFwKey.us_finishFlag = 0;
 543   3                              t_PaperFwKey.us_logStep = 0;                    
 544   3      
 545   3                              usLongDownFlag = 0;   /* 清长按标志 */
 546   3      
 547   3                              write_key_flag = 1;   /* 有按键，需要写按键到主板 */                    
 548   3                      }       
 549   2              }
 550   1      
C51 COMPILER V9.00   MAIN                                                                  05/19/2016 09:22:46 PAGE 10  

 551   1              /* 退纸 */      
 552   1              if (t_PaperBwKey.us_finishFlag != 0) 
 553   1              {
 554   2                      gsKeyVal = KEY_IO2;
 555   2                      
 556   2                      if (t_PaperBwKey.us_finishFlag == KEY_LONG_DOWN_FLAG)     /* 长按 */
 557   2                      {                       
 558   3                              gcKeyType = KEY_LONG_DOWN_FLAG;  
 559   3      
 560   3                              if (usLongDownFlag == 0)
 561   3                              {
 562   4                                      usLongDownFlag = 1;
 563   4      
 564   4                                      write_key_flag = 1;   /* 有按键，需要写按键到主板 */
 565   4                              }
 566   3                      }
 567   2                      else if (t_PaperBwKey.us_finishFlag == KEY_SHORT_UP_FLAG) /* 短按 */
 568   2                      {
 569   3                              gcKeyType = KEY_SHORT_UP_FLAG;   
 570   3      
 571   3                              t_PaperBwKey.us_finishFlag = 0;
 572   3                              t_PaperBwKey.us_logStep = 0;                    
 573   3      
 574   3                              usLongDownFlag = 0;   /* 清长按标志 */
 575   3      
 576   3                              write_key_flag = 1;   /* 有按键，需要写按键到主板 */                    
 577   3                      }
 578   2                      else                                                       /* 长按抬起 */
 579   2                      {
 580   3                              gcKeyType = KEY_LONG_UP_FLAG;   
 581   3      
 582   3                              t_PaperBwKey.us_finishFlag = 0;
 583   3                              t_PaperBwKey.us_logStep = 0;                    
 584   3      
 585   3                              usLongDownFlag = 0;   /* 清长按标志 */
 586   3      
 587   3                              write_key_flag = 1;   /* 有按键，需要写按键到主板 */                    
 588   3                      }       
 589   2              }
 590   1      
 591   1              /* 切纸 */      
 592   1      #if 0
                      if (t_CutKey.us_finishFlag != 0) 
                      {
                              gsKeyVal = KEY_IO3;
                              
                              if (t_CutKey.us_finishFlag == KEY_LONG_DOWN_FLAG)     /* 长按 */
                              {                       
                                      gcKeyType = KEY_LONG_DOWN_FLAG;  
              
                                      if (usLongDownFlag == 0)
                                      {
                                              usLongDownFlag = 1;
              
                                              write_key_flag = 1;   /* 有按键，需要写按键到主板 */
                                      }
                              }
                              else if (t_CutKey.us_finishFlag == KEY_SHORT_UP_FLAG) /* 短按 */
                              {
                                      gcKeyType = KEY_SHORT_UP_FLAG;   
              
                                      t_CutKey.us_finishFlag = 0;
C51 COMPILER V9.00   MAIN                                                                  05/19/2016 09:22:46 PAGE 11  

                                      t_CutKey.us_logStep = 0;                        
              
                                      usLongDownFlag = 0;   /* 清长按标志 */
              
                                      write_key_flag = 1;   /* 有按键，需要写按键到主板 */                    
                              }
                              else                                                       /* 长按抬起 */
                              {
                                      gcKeyType = KEY_LONG_UP_FLAG;   
              
                                      t_CutKey.us_finishFlag = 0;
                                      t_CutKey.us_logStep = 0;                        
              
                                      usLongDownFlag = 0;   /* 清长按标志 */
              
                                      write_key_flag = 1;   /* 有按键，需要写按键到主板 */                    
                              }       
                      }
              #endif
 632   1      
 633   1              /* 下料 */      
 634   1              if (t_PaperDownKey.us_finishFlag != 0) 
 635   1              {
 636   2                      gsKeyVal = KEY_IO4;
 637   2                      
 638   2                      if (t_PaperDownKey.us_finishFlag == KEY_LONG_DOWN_FLAG)     /* 长按 */
 639   2                      {                       
 640   3                              gcKeyType = KEY_LONG_DOWN_FLAG;  
 641   3      
 642   3                              if (usLongDownFlag == 0)
 643   3                              {
 644   4                                      usLongDownFlag = 1;
 645   4      
 646   4                                      write_key_flag = 1;   /* 有按键，需要写按键到主板 */
 647   4                              }
 648   3                      }
 649   2                      else if (t_PaperDownKey.us_finishFlag == KEY_SHORT_UP_FLAG) /* 短按 */
 650   2                      {
 651   3                              gcKeyType = KEY_SHORT_UP_FLAG;   
 652   3      
 653   3                              t_PaperDownKey.us_finishFlag = 0;
 654   3                              t_PaperDownKey.us_logStep = 0;                  
 655   3      
 656   3                              usLongDownFlag = 0;   /* 清长按标志 */
 657   3      
 658   3                              write_key_flag = 1;   /* 有按键，需要写按键到主板 */                    
 659   3                      }
 660   2                      else                                                       /* 长按抬起 */
 661   2                      {
 662   3                              gcKeyType = KEY_LONG_UP_FLAG;   
 663   3      
 664   3                              t_PaperDownKey.us_finishFlag = 0;
 665   3                              t_PaperDownKey.us_logStep = 0;                  
 666   3      
 667   3                              usLongDownFlag = 0;   /* 清长按标志 */
 668   3      
 669   3                              write_key_flag = 1;   /* 有按键，需要写按键到主板 */                    
 670   3                      }       
 671   2              }
 672   1      
 673   1              /* 搓条 */      
 674   1              if (t_RollKey.us_finishFlag != 0) 
C51 COMPILER V9.00   MAIN                                                                  05/19/2016 09:22:46 PAGE 12  

 675   1              {
 676   2                      gsKeyVal = KEY_IO5;
 677   2                      
 678   2                      if (t_RollKey.us_finishFlag == KEY_LONG_DOWN_FLAG)     /* 长按 */
 679   2                      {                       
 680   3                              gcKeyType = KEY_LONG_DOWN_FLAG;  
 681   3      
 682   3                              if (usLongDownFlag == 0)
 683   3                              {
 684   4                                      usLongDownFlag = 1;
 685   4      
 686   4                                      write_key_flag = 1;   /* 有按键，需要写按键到主板 */
 687   4                              }
 688   3                      }
 689   2                      else if (t_RollKey.us_finishFlag == KEY_SHORT_UP_FLAG) /* 短按 */
 690   2                      {
 691   3                              gcKeyType = KEY_SHORT_UP_FLAG;   
 692   3      
 693   3                              t_RollKey.us_finishFlag = 0;
 694   3                              t_RollKey.us_logStep = 0;                       
 695   3      
 696   3                              usLongDownFlag = 0;   /* 清长按标志 */
 697   3      
 698   3                              write_key_flag = 1;   /* 有按键，需要写按键到主板 */                    
 699   3                      }
 700   2                      else                                                       /* 长按抬起 */
 701   2                      {
 702   3                              gcKeyType = KEY_LONG_UP_FLAG;   
 703   3      
 704   3                              t_RollKey.us_finishFlag = 0;
 705   3                              t_RollKey.us_logStep = 0;                       
 706   3      
 707   3                              usLongDownFlag = 0;   /* 清长按标志 */
 708   3      
 709   3                              write_key_flag = 1;   /* 有按键，需要写按键到主板 */                    
 710   3                      }       
 711   2              }
 712   1              
 713   1      }
 714          
 715          /*************定时器0中断***************
 716          函数原型：void tm0_isr(void) interrupt 1 using 1
 717          入口参数：无
 718          出口参数：无
 719          备注：
 720          *******************************/
 721          void tm0_isr() interrupt 1 using 1
 722          {
 723   1              public_val.ms_timer++;
 724   1              
 725   1              check_uart_rec();
 726   1      
 727   1              key_detect();
 728   1              
 729   1      }
 730          
 731          
 732          
 733          void main()
 734          {
 735   1              eeprom_en = 0;
 736   1      
C51 COMPILER V9.00   MAIN                                                                  05/19/2016 09:22:46 PAGE 13  

 737   1              /* 硬件初始化 */
 738   1              sys_init();
 739   1      
 740   1              /* 全局变量初始化 */
 741   1              GlobalInit();
 742   1                      
 743   1              InitLEDDisplay();
 744   1      
 745   1              cnt_read_state = public_val.ms_timer;   
 746   1              
 747   1              //add by yq
 748   1      //      GpuSend("DR2\r\n");
 749   1              {
 750   2                      long i;
 751   2                      for(i = 0; i < 1000; i++)
 752   2                              {
 753   3                                      _nop_();
 754   3                              }
 755   2              }
 756   1              
 757   1              while(1)
 758   1              {       
 759   2                      if (start_com_flag == 0)
 760   2                      {
 761   3                              if (public_val.ms_timer - cnt_read_state > 500)  /* 开机延迟500ms才开始通信 */
 762   3                              //if (public_val.ms_timer - cnt_read_state > 1500)   //for test
 763   3                              {
 764   4                                      cnt_read_state = public_val.ms_timer;
 765   4                                      cnt_read_param = public_val.ms_timer;
 766   4      
 767   4                                      /* 开始手动模式按键检测 */
 768   4                                      start_key_detect();
 769   4      
 770   4                                      start_com_flag = 1;
 771   4                              }
 772   3                      }
 773   2      
 774   2                      if (start_com_flag == 1)
 775   2                      {               
 776   3                              LEDDisplay();
 777   3                              
 778   3                              if(public_val.uart_rec_statu == 2)   /* 接收完毕，开始处理 */
 779   3                              {                       
 780   4                                      rec_data_func();
 781   4                                      
 782   4                                      public_val.uart_rec_statu = 3;   /* 置接收处理完毕状态 */
 783   4                                      public_val.uart_rec_count = 0;   /* 清接收字节计数 */
 784   4                              }
 785   3                              
 786   3      
 787   3                              send_data_func();
 788   3      
 789   3                              judge_key();
 790   3      
 791   3                      }
 792   2                      
 793   2              }
 794   1      }
 795          
 796          


C51 COMPILER V9.00   MAIN                                                                  05/19/2016 09:22:46 PAGE 14  

MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2171    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    121       7
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
