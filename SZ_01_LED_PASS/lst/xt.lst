C51 COMPILER V9.00   XT                                                                    04/10/2015 13:57:45 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE XT
OBJECT MODULE PLACED IN .\out\xt.obj
COMPILER INVOKED BY: C:\Program Files\Keil C51\C51\BIN\C51.EXE xt.c BROWSE DEBUG OBJECTEXTEND PRINT(.\lst\xt.lst) OBJECT
                    -(.\out\xt.obj)

line level    source

   1          
   2          #include "xt.h"
   3          #include "motor_ctrl.h"
   4          #include "LED_Display.h"
   5          #include "save_cnt.h"
   6          
   7          extern xdata char test_mode;
   8          
   9          xdata _T_CHECK_EDGE t_DriverModuleEdge_X = { &public_val.io_read,
  10                                                                                            IN_MASK_ALE,
  11                                                                                            0,  /* logstep初始化为0 */
  12                                                                                            5,  /* 感应模块保护持续时间5ms */
  13                                                                                            0, 0 };
  14          
  15          xdata _T_CHECK_EDGE t_DriverModuleEdge_K = { &public_val.io_read,
  16                                                                                            IN_MASK_ALE2,
  17                                                                                            0,  /* logstep初始化为0 */
  18                                                                                            5,  /* 感应模块保护持续时间5ms */
  19                                                                                            0, 0 };
  20          
  21          xdata _T_CHECK_EDGE t_SensorContiueHighTTL_X = { &public_val.io_read,
  22                                                                                            S5_IN_MASK_X,
  23                                                                                            LOGIC_STEP_INFINITE, 
  24                                                                                            50,  /* 感应无饼持续时间50ms */
  25                                                                                            0, 0 };
  26          
  27          ///料不足传感器边沿判断结构变量
  28          xdata _T_CHECK_EDGE t_SensorLessEdge_S = { &public_val.io_read,
  29                                                                                   S7_IN_MASK_S,
  30                                                                                   LOGIC_STEP_INFINITE, 
  31                                                                                   //500,     /* 感应无筒子持续时间:ms */
  32                                                                                   50,     /* 19414 */
  33                                                                                   0, 0 };
  34          
  35          ///料足传感器边沿判断结构变量
  36          xdata _T_CHECK_EDGE t_SensorEnoughEdge_S = { &public_val.io_read,
  37                                                                                   S7_IN_MASK_S,
  38                                                                                   LOGIC_STEP_INFINITE, 
  39                                                                                   //600,     /* 感应有筒子持续时间:ms */
  40                                                                                   50,     /* 19414 */
  41                                                                                   0, 0 };
  42          
  43          ///脚踏1上升沿判断结构变量
  44          xdata _T_CHECK_EDGE t_Foot1RisingEdge = { &public_val.io_read,
  45                                                                                   FOOT1_MASK,
  46                                                                                   LOGIC_STEP_INFINITE, 
  47                                                                                   20, /* ms */
  48                                                                                   0, 0 };
  49          
  50          ///下料接近开关感应到位持续低电平检测    /* 19418 */
  51          xdata _T_CHECK_EDGE t_SensorGetToPos_S = { &public_val.io_read,
  52                                                                                   S8_IN_MASK_S,
  53                                                                                   LOGIC_STEP_INFINITE, 
  54                                                                                   3,     
C51 COMPILER V9.00   XT                                                                    04/10/2015 13:57:45 PAGE 2   

  55                                                                                   0, 0 };
  56          
  57          ///推饼接近开关感应到位持续低电平检测    /* 19418 */
  58          xdata _T_CHECK_EDGE t_SensorGetToPos_K = { &public_val.io_read,
  59                                                                                   S6_IN_MASK_K,
  60                                                                                   LOGIC_STEP_INFINITE, 
  61                                                                                   3,     
  62                                                                                   0, 0 };
  63          
  64          
  65          
  66          ///升降工作逻辑数据结构变量
  67          xdata _T_WORK_LOGIC_X t_WorkLogicData_X = { 0, 0, 0, 0, 0};
  68          
  69          ///送料工作逻辑数据结构变量
  70          xdata _T_WORK_LOGIC_S t_WorkLogicData_S = { 0, 0, 0};
  71          
  72          
  73          //xdata unsigned char cUpSpeed_X[4] = {246, 247, 248, 249};
  74                  
  75          xdata char cAddMatrlByManu = 0;   /* 顶部无料需等待手动添料的标志:1需等待手动添料，0不需等待 */
  76          
  77          xdata char cLiftDownFlag = 0;         /* 升降电机下降到底部的标志 */
  78          xdata char cLiftPauseFlag = 0;        /* 升降电机暂停标志 */
  79          
  80          //xdata char cFirstStart = 0;     /* 开机首次启动标志: 0未启动，1启动 */
  81          
  82          //xdata char cDoorOpenState;        /* 下料门开启关闭状态: 1开启，0关闭 */
  83          
  84          void ResetDoorForTest()
  85          {
  86   1              public_val.Err_Flag = 0;
  87   1              t_WorkLogicData_S.us_logStep = 0;
  88   1              t_WorkLogicData_S.us_doorCnt = 0;
  89   1              cAddMatrlByManu = 0;
  90   1              
  91   1              //EnableAxis(MOTOR_PUSH, 1);
  92   1              //t_WorkLogicData_X.us_logStep = 0;
  93   1      }
  94          
  95          void CheckSensorContinueHighTTL(_T_CHECK_EDGE *p)
  96          {
  97   1              switch(p->us_logStep)
  98   1              {
  99   2              case 0: 
 100   2                      p->us_finishFlag = 0;
 101   2                      if( (*p->pus_inData & p->us_inMask) )                                                                           ///<无料
 102   2                      {
 103   3                              p->us_logStep = 10;
 104   3                              p->us_actDelay = 0;
 105   3                      }
 106   2                      break;
 107   2              case 10:
 108   2                      if( (*p->pus_inData & p->us_inMask) )                                                                           ///<无料
 109   2                      {
 110   3                              p->us_actDelay ++;
 111   3                              if(p->us_actDelay > p->ul_totalDelay)                                                                   
 112   3                              {
 113   4                                      p->us_logStep = 20;
 114   4                              }
 115   3                      }
 116   2                      else
C51 COMPILER V9.00   XT                                                                    04/10/2015 13:57:45 PAGE 3   

 117   2                      {
 118   3                              p->us_actDelay = 0;
 119   3                              p->us_logStep = 0;
 120   3                      }
 121   2                      break;
 122   2              case 20:
 123   2                      p->us_logStep = LOGIC_STEP_INFINITE;
 124   2                      p->us_finishFlag = 1;
 125   2                      break;
 126   2              }
 127   1      }
 128          
 129          
 130          void CheckSensorContinueLowTTL(_T_CHECK_EDGE *p)
 131          {
 132   1              switch(p->us_logStep)
 133   1              {
 134   2              case 0:
 135   2                      p->us_finishFlag = 0;
 136   2                      if( !(*p->pus_inData & p->us_inMask) )                                                                          ///<料满
 137   2                      {
 138   3                              p->us_logStep = 10;
 139   3                              p->us_actDelay = 0;
 140   3                      }
 141   2                      break;
 142   2              case 10:
 143   2                      if( !(*p->pus_inData & p->us_inMask) )                                                                          ///<料满
 144   2                      {
 145   3                              p->us_actDelay ++;
 146   3                              if(p->us_actDelay > p->ul_totalDelay)                                                                   
 147   3                              {
 148   4                                      p->us_logStep = 20;
 149   4                              }
 150   3                      }
 151   2                      else
 152   2                      {
 153   3                              p->us_actDelay = 0;
 154   3                              p->us_logStep = 0;
 155   3                      }
 156   2                      break;
 157   2              case 20:
 158   2                      p->us_logStep = LOGIC_STEP_INFINITE;
 159   2                      p->us_finishFlag = 1;
 160   2                      break;
 161   2              }
 162   1      }
 163          
 164          
 165          void CheckFallingEdge(_T_CHECK_EDGE *p)
 166          {
 167   1              switch(p->us_logStep)
 168   1              {
 169   2              case 0:
 170   2                      p->us_finishFlag = 0;
 171   2                      if( *p->pus_inData & p->us_inMask )
 172   2                      {
 173   3                              p->us_logStep = 10;
 174   3                              p->us_actDelay = 0;
 175   3                      }
 176   2                      break;
 177   2                      
 178   2              case 10:
C51 COMPILER V9.00   XT                                                                    04/10/2015 13:57:45 PAGE 4   

 179   2                      if( *p->pus_inData & p->us_inMask )
 180   2                      {
 181   3                              p->us_actDelay++;
 182   3                              if(p->us_actDelay > p->ul_totalDelay)
 183   3                              {
 184   4                                      p->us_logStep = 30;
 185   4                              }
 186   3                      }
 187   2                      else
 188   2                      {
 189   3                              p->us_actDelay = 0;
 190   3                      }
 191   2                      
 192   2                      break;
 193   2                      
 194   2              case 30:
 195   2                      if( !(*p->pus_inData & p->us_inMask) )
 196   2                      {
 197   3                              p->us_actDelay++;
 198   3                              if(p->us_actDelay > p->ul_totalDelay)
 199   3                              {
 200   4                                      p->us_logStep = 40;
 201   4                              }
 202   3                      }
 203   2                      else
 204   2                      {
 205   3                              p->us_actDelay = 0;
 206   3                      }
 207   2                      break;
 208   2                      
 209   2              case 40:
 210   2                      p->us_logStep = LOGIC_STEP_INFINITE;
 211   2                      p->us_finishFlag = 1;
 212   2                      break;
 213   2                      
 214   2              }
 215   1      }
 216          
 217          /* 升降电机 
 218             1ms执行一次 */
 219          void xt_ctrl_lift_push(_T_WORK_LOGIC_X *p)
 220          {
 221   1              char cFlag = 0;
 222   1              static unsigned short next_step = 0;
 223   1              switch (p->us_logStep)
 224   1              {
 225   2                      case 0:
 226   2      
 227   2                              t_Foot1RisingEdge.us_logStep = 0;
 228   2                              
 229   2                              //public_val.Work_Pause_Flag = 1 | 0x80;    //开机即为暂停状态
 230   2                              public_val.Bell_Flag = YES;   //开机蜂鸣器长间隔响
 231   2      
 232   2                              t_SensorGetToPos_K.us_logStep = 0;  /* added for v19418 */
 233   2      
 234   2                              p->us_logStep = 5;
 235   2                              
 236   2                              break;
 237   2      
 238   2                      case 5:
 239   2                      
 240   2                              if(t_Foot1RisingEdge.us_finishFlag)  //开机踩脚踏板
C51 COMPILER V9.00   XT                                                                    04/10/2015 13:57:45 PAGE 5   

 241   2                              {
 242   3                                      //public_val.Work_Pause_Flag = 0;
 243   3                                      public_val.Bell_Flag = NO;
 244   3      
 245   3                              #ifdef SENSOR_K_OUT
 246   3                                      if (t_SensorGetToPos_K.us_finishFlag == 0)   /* 推饼接近在外:未推出 */
 247   3                              #else
                                              if (t_SensorGetToPos_K.us_finishFlag != 0)   /* 推饼接近在内:未推出 */
                                      #endif
 250   3                                      {       
 251   4                                      #ifndef SENSOR_K_OUT    
                                                      t_SensorGetToPos_K.us_finishFlag = 0;
                                              #endif
 254   4                                              
 255   4                                              next_step = 40;          //未推出 进入继续洗筒状态
 256   4                                              p->us_logStep = 8;       /* 不论取饼光电是否能检测到饼 */
 257   4                                      }
 258   3                                      else        /* 已推出 */
 259   3                                      {
 260   4                                      #ifdef SENSOR_K_OUT                                     
 261   4                                              t_SensorGetToPos_K.us_finishFlag = 0;
 262   4                                      #endif
 263   4                                              
 264   4                                              next_step = 20;          //已经推出 升降电机上升 再继续洗筒
 265   4                                              p->us_logStep = 10;      /* 须判断饼是否取出 */
 266   4                                              t_SensorContiueHighTTL_X.us_logStep = 0;  ///<开启无炮饼检测                            
 267   4                                      }
 268   3      
 269   3                              }
 270   2      
 271   2      
 272   2                              break;
 273   2      
 274   2                      case 8:
 275   2                                      /* 使能升降电机 */
 276   2                                      EnableAxis(MOTOR_LIFT, 1);
 277   2      
 278   2                                      t_Foot1RisingEdge.us_logStep = 0;  /* 开启踏板检测 */
 279   2                                              
 280   2                                      p->us_logStep = next_step;
 281   2                                      
 282   2                              break;
 283   2                              
 284   2                      case 10:
 285   2                              
 286   2                              if (t_SensorContiueHighTTL_X.us_finishFlag)  /* 无饼 */
 287   2                              {
 288   3                                      /* 使能升降电机 */
 289   3                                      EnableAxis(MOTOR_LIFT, 1);
 290   3      
 291   3                                      t_Foot1RisingEdge.us_logStep = 0;  /* 开启踏板检测 */
 292   3                                              
 293   3                                      p->us_logStep = next_step;
 294   3                              }
 295   2                              
 296   2                              break;
 297   2      
 298   2                      case 20:
 299   2      
 300   2                              if (cAddMatrlByManu == 0)  /* 不需等待手动添料 */
 301   2                              {
 302   3                                      p->ul_actDelay++;
C51 COMPILER V9.00   XT                                                                    04/10/2015 13:57:45 PAGE 6   

 303   3      
 304   3                                      /* 延时后升降电机上升 */
 305   3                                      if (p->ul_actDelay > STEP_ENBLE_DELAY)                  
 306   3                                      {
 307   4                                              p->ul_actDelay = 0;
 308   4      
 309   4                                              SetAxisTQ(BIG_CURRENT);      /* 上升使用大电流 */
 310   4                                              
 311   4                                              SetAxisDirection(MOTOR_LIFT, POSITIVE_DIR_LIFT);
 312   4      
 313   4                                              cMotorReverse = MOTOR_LIFT;  /* 设置升降电机脉冲脚翻转 */                                       
 314   4                                              ulPulseCnt = 0;              /* 脉冲翻转计数清零 */
 315   4                                              
 316   4                                              set_step_moto(STEP_START, public_val.menu_parm[PARM_LIFT_UP_SPD]);
 317   4                                              
 318   4                                              p->us_logStep = 30;
 319   4                                      }
 320   3                              }
 321   2                              
 322   2                              break;
 323   2                              
 324   2                      case 30:
 325   2                              
 326   2                              /* 上升设定距离到位 */
 327   2                              if (ulPulseCnt > ((unsigned long)public_val.menu_parm[PARM_LIFT_UP_LEN] * LIFT_LEN_STEP))
 328   2                              {                                               
 329   3                                      set_step_moto(STEP_STOP, 0);
 330   3                                      p->us_logStep = 31;
 331   3                              }
 332   2                              
 333   2                              break;  
 334   2                              
 335   2                      case 31:
 336   2      
 337   2                              /* 提前使能推饼电机 */
 338   2                              EnableAxis(MOTOR_PUSH, 1);
 339   2                              p->us_logStep = 32;
 340   2                              
 341   2                              break;
 342   2                              
 343   2                      case 32:
 344   2                              
 345   2                              p->ul_actDelay++;
 346   2      
 347   2                              /* 延时后推饼电机回退 */
 348   2                              if (p->ul_actDelay > STEP_STOP_DELAY)
 349   2                              {
 350   3                                      p->ul_actDelay = 0;
 351   3                                      
 352   3                                      SetAxisDirection(MOTOR_PUSH, POSITIVE_DIR_PUSH);
 353   3      
 354   3                                      cMotorReverse = MOTOR_PUSH;  /* 设置推饼电机脉冲脚翻转 */
 355   3                                      ulPulseCnt = 0;              /* 脉冲翻转计数清零 */
 356   3                                      
 357   3                                      set_step_moto(STEP_START, public_val.menu_parm[PARM_PUSH_SPD]);
 358   3      
 359   3                                      SetAxisTQ(LITTLE_CURRENT);  /* 升降电机切到小电流保持 */
 360   3      
 361   3                              #ifndef SENSOR_K_OUT 
                                              t_SensorGetToPos_K.us_logStep = 0;   /* 开启推饼接近检测 added for 19418 */
                                      #endif
 364   3      
C51 COMPILER V9.00   XT                                                                    04/10/2015 13:57:45 PAGE 7   

 365   3                                      p->us_logStep = 34;                             
 366   3                              }
 367   2                              
 368   2                              break;
 369   2      
 370   2                      case 34:
 371   2      
 372   2                      #ifdef SENSOR_K_OUT  
 373   2      
 374   2                              /*回退设定距离后停止 */
 375   2                              if (ulPulseCnt > ((unsigned long)public_val.menu_parm[PARM_PUSH_LEN] * 640))
 376   2                              {                               
 377   3                                      set_step_moto(STEP_STOP, 0);                            
 378   3      
 379   3                                      ulPulseCnt = 0;
 380   3                                      
 381   3                                      p->us_logStep = 40;
 382   3                              }
 383   2      
 384   2                      #else
                              
                                      /* 如果推饼接近感应到则停止回退 */
                              
                                      //if (!SENSOR_STATUS_K)
                                      if (t_SensorGetToPos_K.us_finishFlag != 0)
                                      {                               
                                              t_SensorGetToPos_K.us_finishFlag = 0;
                                              
                                              set_step_moto(STEP_STOP, 0);
              
                                              //SetAxisTQ(BIG_CURRENT);      /* 升降电机切回大电流 */
              
                                              p->us_logStep = 40;
                                      }
                                      
                                      /* 如果推饼电机回退超过设定距离3圈，则报E3错 */
                                      else if (ulPulseCnt 
                                              > ((unsigned long)(public_val.menu_parm[PARM_PUSH_LEN] + 30) * 640))
                                      {                               
                                              /* 工作模式 */
                                              //if (public_val.menu_parm[PARM_TEST_MODE] == 0)
                                              if (test_mode == 0)
                                              {
                                                      public_val.Err_Flag = 3;
              
                                                      /* 关闭推饼电机 */
                                                      EnableAxis(MOTOR_PUSH, 0);
                                                              
                                                      p->us_logStep = 888;
                                              }
                                              else  /* 测试模式 */
                                              {
                                                      /* 停止回退 */
                                                      set_step_moto(STEP_STOP, 0);
              
                                                      p->us_logStep = 40;
                                              }
                                      }                       
                              #endif
 424   2                              
 425   2                              break;
 426   2      
C51 COMPILER V9.00   XT                                                                    04/10/2015 13:57:45 PAGE 8   

 427   2                      case 40:
 428   2      
 429   2                              if (cAddMatrlByManu == 0)  /* 不需等待手动添料 */
 430   2                              {
 431   3                                      p->ul_actDelay++;
 432   3      
 433   3                                      /* 延时后升降电机准备下降，交流电机启动 */
 434   3                                      if (p->ul_actDelay > STEP_STOP_DELAY)
 435   3                                      {
 436   4                                              p->ul_actDelay = 0;
 437   4      
 438   4                                              //SetAxisTQ(BIG_CURRENT);      /* 升降电机切回大电流 */
 439   4                                              
 440   4                                              SetAxisDirection(MOTOR_LIFT, NEGTIVE_DIR_LIFT);
 441   4      
 442   4                                              /* 关闭推饼电机 */
 443   4                                              EnableAxis(MOTOR_PUSH, 0);
 444   4      
 445   4                                              cMotorReverse = MOTOR_LIFT;  /* 设置升降电机脉冲脚翻转 */
 446   4                                              ulPulseCnt = 0;              /* 脉冲翻转计数清零 */
 447   4                                              
 448   4                                              /* 交流电机使能 */
 449   4                                              //OUTAC = AC_ENABLE;
 450   4      
 451   4                                              //t_Foot1RisingEdge.us_logStep = 0;  /* 开启踏板检测 */
 452   4                                              
 453   4                                              p->us_logStep = 50;
 454   4                                      }
 455   3                              }
 456   2      
 457   2                              break;
 458   2      
 459   2                      case 50:
 460   2                              
 461   2                              /* 如果已下降到底部 */
 462   2                              if (cLiftDownFlag != 0)
 463   2                              {                                                       
 464   3                                      if (public_val.menu_parm[PARM_AUTO_MODE] == YES) /* 自动模式 added for v19416 */
 465   3                                      {
 466   4                                              /* 自动模式下降到位后自动推出 */
 467   4                                              p->ul_actDelay = 0;
 468   4                                              
 469   4                                              t_Foot1RisingEdge.us_finishFlag = 0;
 470   4                                              
 471   4                                              cLiftDownFlag = 0;
 472   4      
 473   4                                              /* 升降电机停止 */
 474   4                                              set_step_moto(STEP_STOP, 0);
 475   4                                              
 476   4                                              /* 交流电机关闭 */
 477   4                                              OUTAC = AC_DISABLE;
 478   4      
 479   4                                              /* 使能推饼电机 */
 480   4                                              EnableAxis(MOTOR_PUSH, 1);
 481   4      
 482   4                                              p->ul_runDelay = 0;
 483   4                                              p->ul_pauseDelay = 0;
 484   4      
 485   4                                              p->us_logStep = 55;
 486   4      
 487   4                                              break;
 488   4                                              
C51 COMPILER V9.00   XT                                                                    04/10/2015 13:57:45 PAGE 9   

 489   4                                      }
 490   3                                      else  /* 手动模式 */
 491   3                                      {
 492   4                                              /* 如果踏板被按下，升降电机和交流电机停止 */
 493   4                                              if (t_Foot1RisingEdge.us_finishFlag != 0)
 494   4                                                      //|| (p->ul_actDelay > (1000* public_val.menu_parm[PARM_PUSH_DELAY])))  /* deleted for v19416 */
 495   4                                              {
 496   5                                                      p->ul_actDelay = 0;                                     
 497   5      
 498   5                                                      t_Foot1RisingEdge.us_finishFlag = 0;
 499   5                                                      
 500   5                                                      cLiftDownFlag = 0;
 501   5      
 502   5                                                      /* 升降电机停止 */
 503   5                                                      set_step_moto(STEP_STOP, 0);
 504   5                                                      
 505   5                                                      /* 交流电机关闭 */
 506   5                                                      OUTAC = AC_DISABLE;
 507   5      
 508   5                                                      /* 使能推饼电机 */
 509   5                                                      EnableAxis(MOTOR_PUSH, 1);
 510   5      
 511   5                                                      p->ul_runDelay = 0;
 512   5                                                      p->ul_pauseDelay = 0;
 513   5      
 514   5                                                      p->us_logStep = 55;
 515   5      
 516   5                                                      break;
 517   5                                                      
 518   5                                              }
 519   4                                      }
 520   3                              }       
 521   2                              else  /* 未下降到底部 */
 522   2                              {
 523   3                                      /* 当前不是暂停状态 */
 524   3                                      if (cLiftPauseFlag == 0)
 525   3                                      {
 526   4                                              /* 如果按踏板，则暂停 */
 527   4                                              if (t_Foot1RisingEdge.us_finishFlag != 0)
 528   4                                              {
 529   5                                                      t_Foot1RisingEdge.us_finishFlag = 0;
 530   5                                                      t_Foot1RisingEdge.us_logStep = 0;
 531   5      
 532   5                                                      cLiftPauseFlag = 1;  /* 置暂停标志 */
 533   5                                                      
 534   5                                                      IoReverseStop(CHN_STEP);
 535   5                                                      
 536   5                                                      OUTAC = AC_DISABLE;
 537   5      
 538   5                                                      public_val.Work_Pause_Flag = 1 | 0x80;
 539   5                                                      
 540   5                                                      p->ul_runDelay = 0;
 541   5                                                      p->ul_pauseDelay = 0;                           
 542   5      
 543   5                                                      break;
 544   5                                              }
 545   4                                      }
 546   3                              }
 547   2      
 548   2                              /* 如果不是暂停状态 */
 549   2                              if (cLiftPauseFlag == 0)
 550   2                              {                                                       
C51 COMPILER V9.00   XT                                                                    04/10/2015 13:57:45 PAGE 10  

 551   3                                  if (cAddMatrlByManu == 0)  /* 不需等待手动添料 */
 552   3                                  {
 553   4                                              OUTAC = AC_ENABLE;   /* 使能交流电机 */                                 
 554   4      
 555   4                                              /* 开始阶梯式下降 */
 556   4                                              if (p->ul_runDelay == 0)
 557   4                                              {
 558   5                                                      set_step_moto(STEP_START, public_val.menu_parm[PARM_LIFT_DOWN_SPD]);
 559   5                                                      p->ul_runDelay++;
 560   5                                              }
 561   4                                              else if (p->ul_runDelay 
 562   4                                                      > (public_val.menu_parm[PARM_LIFT_DN_MV_TIME] * 50))
 563   4                                              {                                                                                               
 564   5                                                      if (p->ul_pauseDelay == 0)
 565   5                                                      {
 566   6                                                              set_step_moto(STEP_STOP, 0);
 567   6                                                              p->ul_pauseDelay++;
 568   6                                                      }
 569   5                                                      else if (p->ul_pauseDelay 
 570   5                                                              > (public_val.menu_parm[PARM_LIFT_DN_PAU_TIME] * 50))
 571   5                                                      {
 572   6                                                              p->ul_runDelay = 0;
 573   6                                                              p->ul_pauseDelay = 0;
 574   6                                                      }
 575   5      
 576   5                                                      if (p->ul_pauseDelay > 0)
 577   5                                                      {
 578   6                                                              p->ul_pauseDelay++;
 579   6                                                      }
 580   5                                              }
 581   4      
 582   4                                              if (p->ul_runDelay > 0)
 583   4                                              {
 584   5                                                      p->ul_runDelay++;
 585   5                                              }
 586   4      
 587   4                                              /* 下降设定距离后置到位标志 */
 588   4                                              if (ulPulseCnt 
 589   4                                                      > ((unsigned long)public_val.menu_parm[PARM_LIFT_DOWN_LEN] * LIFT_LEN_STEP))
 590   4                                              {
 591   5                                                      cLiftDownFlag = 1;  /* 置下降到底部标志 */
 592   5      
 593   5                                                      ulPulseCnt = 0;     /* added for v19416 */
 594   5                                                      
 595   5                                                      //p->ul_actDelay++; /* deleted for v19416 */
 596   5                                              }
 597   4                                              
 598   4                                  }
 599   3                                      else  /* 需手动添料 */
 600   3                                      {
 601   4                                              /* 停止下降，关闭交流电机 */
 602   4                                              IoReverseStop(CHN_STEP);
 603   4                                              
 604   4                                              OUTAC = AC_DISABLE;
 605   4                                              
 606   4                                              p->ul_runDelay = 0;
 607   4                                              p->ul_pauseDelay = 0;
 608   4                                      }
 609   3                              }
 610   2                              else  /* 如果是暂停状态 */
 611   2                              {                                                               
 612   3                                      /* 如果按踏板 */
C51 COMPILER V9.00   XT                                                                    04/10/2015 13:57:45 PAGE 11  

 613   3                                      if (t_Foot1RisingEdge.us_finishFlag != 0)
 614   3                                      {
 615   4                                              /* 解除暂停状态标志 */
 616   4                                              cLiftPauseFlag = 0;
 617   4      
 618   4                                              public_val.Work_Pause_Flag = 0;
 619   4      
 620   4                                              /* 重新开启踏板检测 */
 621   4                                              t_Foot1RisingEdge.us_finishFlag = 0;
 622   4                                              t_Foot1RisingEdge.us_logStep = 0;
 623   4                                      }
 624   3                              }
 625   2      
 626   2                              break;                  
 627   2      
 628   2                      case 55:
 629   2      
 630   2                              p->ul_actDelay++;
 631   2      
 632   2                              /* 延时后推饼电机推出 */
 633   2                          if (p->ul_actDelay > STEP_STOP_DELAY)
 634   2                          {                           
 635   3                                      p->ul_actDelay = 0;
 636   3                                      
 637   3                                      /* 推饼电机推出 */
 638   3                                      SetAxisDirection(MOTOR_PUSH, NEGTIVE_DIR_PUSH);
 639   3      
 640   3                                      cMotorReverse = MOTOR_PUSH;  /* 设置推饼电机脉冲脚翻转 */
 641   3                                      ulPulseCnt = 0;              /* 脉冲翻转计数清零 */
 642   3                                      
 643   3                                      set_step_moto(STEP_START, public_val.menu_parm[PARM_PUSH_SPD]);
 644   3      
 645   3                                      SetAxisTQ(LITTLE_CURRENT);  /* 升降电机切换到小电流 */                          
 646   3      
 647   3                              #ifdef SENSOR_K_OUT 
 648   3                                      t_SensorGetToPos_K.us_logStep = 0;  /* 开启推饼接近检测 added for v19418 */
 649   3                              #endif
 650   3      
 651   3                                      p->us_logStep = 57;
 652   3                              }
 653   2                              
 654   2                              break;
 655   2      
 656   2                      case 57:
 657   2                              
 658   2                      #ifdef SENSOR_K_OUT
 659   2      
 660   2                              /* 如果推饼接近感应到则停止推出 */
 661   2                              //if (!SENSOR_STATUS_K)
 662   2                              if (t_SensorGetToPos_K.us_finishFlag != 0)  /* modified for v19418 */
 663   2                              {                               
 664   3                                      t_SensorGetToPos_K.us_finishFlag = 0;
 665   3                                      
 666   3                                      set_step_moto(STEP_STOP, 0);
 667   3      
 668   3                                      p->us_logStep = 60;
 669   3                              }
 670   2                              
 671   2                              /* 如果推饼电机推出超过设定距离3圈，则报E3错 */
 672   2                              else if (ulPulseCnt 
 673   2                                      > ((unsigned long)(public_val.menu_parm[PARM_PUSH_LEN] + 30) * 640))
 674   2                              {                               
C51 COMPILER V9.00   XT                                                                    04/10/2015 13:57:45 PAGE 12  

 675   3                                      /* 工作模式 */
 676   3                                      //if (public_val.menu_parm[PARM_TEST_MODE] == 0)
 677   3                                      if (test_mode == 0)
 678   3                                      {
 679   4                                              public_val.Err_Flag = 3;
 680   4      
 681   4                                              /* 关闭推饼电机 */
 682   4                                              EnableAxis(MOTOR_PUSH, 0);
 683   4                                                      
 684   4                                              p->us_logStep = 888;
 685   4                                      }
 686   3                                      else  /* 测试模式 */
 687   3                                      {
 688   4                                              /* 停止推出 */
 689   4                                              set_step_moto(STEP_STOP, 0);
 690   4      
 691   4                                              p->us_logStep = 60;
 692   4                                      }
 693   3                              }                       
 694   2      
 695   2                      #else
                              
                                      /* 推出设定距离后停止 */
                                      if (ulPulseCnt > ((unsigned long)public_val.menu_parm[PARM_PUSH_LEN] * 640))
                                      {
                                              set_step_moto(STEP_STOP, 0);                            
              
                                              p->us_logStep = 60;
                                      }
                                      
                              #endif
 706   2      
 707   2                              break;
 708   2      
 709   2                      case 60:
 710   2      
 711   2                              p->ul_actDelay++;
 712   2      
 713   2                              /* 延时后关闭推饼电机 */
 714   2                          if (p->ul_actDelay > STEP_STOP_DELAY)
 715   2                          {
 716   3                                      p->ul_actDelay = 0;
 717   3      
 718   3                                      EnableAxis(MOTOR_PUSH, 0);  
 719   3                                      
 720   3                                      t_SensorContiueHighTTL_X.us_logStep = 0;  /* 开启无炮饼检测 */
 721   3      
 722   3                                      p->us_logStep = 70;
 723   3                              }
 724   2                              
 725   2                              break;
 726   2      
 727   2                      case 70:
 728   2      
 729   2                              if (t_SensorContiueHighTTL_X.us_finishFlag)  /* 无饼 */
 730   2                              {                               
 731   3                                      public_val.main_disp_val++;              /* 已洗完饼数加1 */
 732   3      
 733   3                                      save_xt_num();  /* 保存洗筒饼数 */
 734   3      
 735   3                                      t_Foot1RisingEdge.us_logStep = 0;  /* 开启暂停踏板检测 added for v19402 */
 736   3      
C51 COMPILER V9.00   XT                                                                    04/10/2015 13:57:45 PAGE 13  

 737   3                                      /* 如果下料电机超时报E4错误，则升降电机不再上升 */
 738   3                                      if (public_val.Err_Flag == 4)
 739   3                                      {
 740   4                                              p->us_logStep = 888;
 741   4                                      }
 742   3                                      else  /* 无报错 */
 743   3                                      {                                                                               
 744   4                                              //SetAxisTQ(BIG_CURRENT);      /* 升降电机切回大电流 */
 745   4      
 746   4                                              /* 进行下一饼洗筒 */
 747   4                                              p->us_logStep = 20;
 748   4                                      }
 749   3                              }
 750   2      
 751   2                              break;  
 752   2                      default:
 753   2                              break;
 754   2                              
 755   2              }
 756   1      }
 757          
 758          
 759          /* 下料电机 
 760             1ms执行一次 */
 761          void xt_ctrl_door(_T_WORK_LOGIC_S *p)
 762          {
 763   1              int iDelay = 0;
 764   1              char cFlag = 0;
 765   1              
 766   1              switch (p->us_logStep)
 767   1              {               
 768   2                      case 0:
 769   2      
 770   2                              p->ul_actDelay++;
 771   2      
 772   2                              if (p->ul_actDelay >= APPROACH_DELAY)
 773   2                              {
 774   3                                      p->ul_actDelay = 0;
 775   3                                      p->us_logStep = 10;
 776   3                              }
 777   2                              
 778   2                              break;
 779   2                      
 780   2                      case 10:                        
 781   2      
 782   2                              if (t_SensorGetToPos_S.us_finishFlag != 0)  /* 下料门关闭 */
 783   2                              {
 784   3                                      t_SensorGetToPos_S.us_finishFlag = 0;
 785   3                                      
 786   3                                      p->us_logStep = 14;
 787   3                              }
 788   2                              else        /* 下料门开启，则先关闭 */
 789   2                              {
 790   3                                      set_zl_moto(STEP_START);
 791   3                                      
 792   3                                      t_SensorGetToPos_S.us_logStep = 0;   /* 开启下料门到位检测 */
 793   3      
 794   3                                      p->ul_actDelay = 0;
 795   3                                      
 796   3                                      p->us_logStep = 12;
 797   3                              }
 798   2                                                      
C51 COMPILER V9.00   XT                                                                    04/10/2015 13:57:45 PAGE 14  

 799   2                              break;
 800   2      
 801   2                      case 12:
 802   2      
 803   2                              if (t_SensorGetToPos_S.us_finishFlag != 0)  /* 运动到位 */
 804   2                              {
 805   3                                      t_SensorGetToPos_S.us_finishFlag = 0;
 806   3                                      
 807   3                                      set_zl_moto(STEP_STOP);
 808   3      
 809   3                                      p->ul_actDelay = 0;
 810   3                                      p->us_logStep = 14; 
 811   3                              }
 812   2                              else
 813   2                              {
 814   3                                      p->ul_actDelay++;
 815   3      
 816   3                                      /* 如超时未感应到接近，则报E-4错误 */
 817   3                                      if (p->ul_actDelay 
 818   3                                              > (public_val.menu_parm[PARM_DOOR_CLOSED_TIME] * 100))
 819   3                                      {
 820   4                                              p->ul_actDelay = 0;
 821   4      
 822   4                                              public_val.Err_Flag = 4;
 823   4                                              
 824   4                                              /* 下料电机关闭 */
 825   4                                              OUT1 = DC_DISABLE;
 826   4      
 827   4                                              p->us_logStep = 888; 
 828   4                                      }
 829   3                              }
 830   2      
 831   2                              break;
 832   2                      
 833   2                      case 14:
 834   2      
 835   2                              p->ul_actDelay++;
 836   2      
 837   2                              iDelay = (test_mode == 0) 
 838   2                                      ? DC_REOPEN_DELAY : (test_mode * 1000);
 839   2      
 840   2                              /* 下料门关闭后延时一小段开始下一次料不足检测 */
 841   2                              if (p->ul_actDelay > iDelay)
 842   2                              {
 843   3                                      p->ul_actDelay = 0;
 844   3      
 845   3                                      t_SensorLessEdge_S.us_logStep = 0;
 846   3                                      t_SensorEnoughEdge_S.us_logStep = 0;
 847   3                                      
 848   3                                      p->us_logStep = 15;                             
 849   3                              }
 850   2                              
 851   2                              break;
 852   2      
 853   2                      case 15:
 854   2      
 855   2                              if (t_SensorLessEdge_S.us_finishFlag)    /* 下料漫反射感应无料 */
 856   2                              {                               
 857   3                                      cFlag = !SENSOR_STATUS_S;  /* 检测下料接近状态 added for v19416 */
 858   3                                      
 859   3                                      /* 下料电机使能 */
 860   3                                      set_zl_moto(STEP_START);
C51 COMPILER V9.00   XT                                                                    04/10/2015 13:57:45 PAGE 15  

 861   3      
 862   3                                      if (test_mode == 0) /* 工作模式 */
 863   3                                      {
 864   4                                              /* 持续3次无料开门则报E-5错误 */
 865   4                                              if (p->us_doorCnt 
 866   4                                                      >= public_val.menu_parm[PARM_DOOR_WARN_CYCLE])   
 867   4                                              {
 868   5                                                      public_val.Err_Flag = 5;
 869   5                                              }
 870   4      
 871   4                                              /* 持续6次无料开门则需等待手动添料后洗筒 */
 872   4                                              if (p->us_doorCnt 
 873   4                                                      >= public_val.menu_parm[PARM_DOOR_PAU_CYCLE])   
 874   4                                              {
 875   5                                                      cAddMatrlByManu = 1;  
 876   5                                              }
 877   4                                      }
 878   3      
 879   3                                      /* added for v19416 */
 880   3                                      if (cFlag)  /* 下料门处于关闭位置 */
 881   3                                      {                                       
 882   4                                              p->us_logStep = 21;
 883   4                                      }
 884   3                                      else  /* 下料门处于开启位置 */
 885   3                                      {
 886   4                                              t_SensorGetToPos_S.us_logStep = 0; 
 887   4                                              
 888   4                                              p->us_logStep = 25;
 889   4                                      }                                       
 890   3      
 891   3                                      p->ul_actDelay = 0; 
 892   3                                      
 893   3                              }
 894   2                              
 895   2                              if (t_SensorEnoughEdge_S.us_finishFlag)         /* 下料漫反射感应有料 */
 896   2                              {
 897   3                                      p->us_doorCnt = 0;     /* 持续无料开门次数清零 */
 898   3                                      cAddMatrlByManu = 0;   /* 清除顶部无料标志 */
 899   3      
 900   3                                      if (public_val.Err_Flag == 5)
 901   3                                      {
 902   4                                              public_val.Err_Flag = 0;  /* 清除报错 */
 903   4                                      }
 904   3                              }
 905   2      
 906   2                              break;
 907   2      
 908   2                      case 21:
 909   2                      
 910   2                              cFlag = SENSOR_STATUS_S; 
 911   2                              
 912   2                              if (cFlag)  /* 感应到离开则开始进一步检测门关闭 */
 913   2                              {
 914   3                                      t_SensorGetToPos_S.us_logStep = 0;
 915   3                                      
 916   3                                      p->ul_actDelay = 0;
 917   3                                                              
 918   3                                      p->us_logStep = 25;
 919   3                              }
 920   2                              else                   /* 未感应到离开则开始超时计数 */
 921   2                              {
 922   3                                      p->ul_actDelay++;
C51 COMPILER V9.00   XT                                                                    04/10/2015 13:57:45 PAGE 16  

 923   3                                      
 924   3                                      /* 如超时未感应到离开，则报E-4错误 */
 925   3                                      if (p->ul_actDelay 
 926   3                                              > (public_val.menu_parm[PARM_DOOR_CLOSED_TIME] * 100))
 927   3                                      {
 928   4                                              p->ul_actDelay = 0;
 929   4      
 930   4                                              public_val.Err_Flag = 4;
 931   4                                              
 932   4                                              /* 下料电机关闭 */
 933   4                                              OUT1 = DC_DISABLE;
 934   4      
 935   4                                              p->us_logStep = 888;  /* 报错后需重启恢复 added at 2014-5-20 */
 936   4                                      }
 937   3                              }
 938   2                                                      
 939   2                              break;
 940   2      
 941   2                      case 25:
 942   2                              
 943   2                              //cFlag = !SENSOR_STATUS_S;    /* modified for v19416 */
 944   2      
 945   2                              /* 继续检测下料接近感应到即为门关闭 */
 946   2                              if (t_SensorGetToPos_S.us_finishFlag != 0)
 947   2                              {                               
 948   3                                      t_SensorGetToPos_S.us_finishFlag = 0;
 949   3                                      
 950   3                                      /* 下料电机关闭 */
 951   3                                      set_zl_moto(STEP_STOP);
 952   3      
 953   3                                      p->us_doorCnt++;
 954   3                                      
 955   3                                      p->ul_actDelay = 0;
 956   3                                      
 957   3                                      p->us_logStep = 14;    /* modified for v19416 */
 958   3                              }
 959   2                              else
 960   2                              {
 961   3                                      p->ul_actDelay++;
 962   3      
 963   3                                      /* 如超时未感应到接近，则报E-4错误 */
 964   3                                      if (p->ul_actDelay 
 965   3                                              > (public_val.menu_parm[PARM_DOOR_CLOSED_TIME] * 100))
 966   3                                      {
 967   4                                              p->ul_actDelay = 0;
 968   4      
 969   4                                              public_val.Err_Flag = 4;
 970   4                                              
 971   4                                              /* 下料电机关闭 */
 972   4                                              OUT1 = DC_DISABLE;
 973   4      
 974   4                                              p->us_logStep = 888;  /* 报错后需重启恢复 added at 2014-5-20 */
 975   4                                      }
 976   3                              }
 977   2                                      
 978   2                              break;
 979   2      
 980   2      
 981   2                      default:
 982   2      
 983   2                              break;
 984   2              }
C51 COMPILER V9.00   XT                                                                    04/10/2015 13:57:45 PAGE 17  

 985   1      }
 986          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3883    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    157    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2      19
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
