C51 COMPILER V9.00   LED_DISPLAY                                                           05/16/2016 14:48:04 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE LED_DISPLAY
OBJECT MODULE PLACED IN .\out\LED_Display.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE LED_Display.c LARGE BROWSE DEBUG OBJECTEXTEND PRINT(.\lst\LED_Display.lst) 
                    -OBJECT(.\out\LED_Display.obj)

line level    source

   1          /**
   2           * Copyright (c) 2012, 长沙晗光电子科技有限公司
   3           * All rights reserved.
   4           *
   5           * FILE:   LED_Display.c
   6           * LED显示程序
   7           *
   8           * @file LED_Display.h led_driver.h
   9           * 头文件.
  10           *
  11           * @author JWD
  12           * @date 2012-12-21
  13           *
  14           */
  15          #include "eeprom.h"
  16          #include "LED_Display.h"
  17          #include "I2c.h"
  18          #include "reg51.h"
  19          #include "save_cnt.h"
  20          #include "global.h"
  21          #include "sys.h"
  22          
  23          #include "uart.h"
  24          #include <stdio.h>
  25          #include <string.h>
  26          
  27          #ifdef DISP_C
  28          
  29          #define BELL P25
  30          
  31          #define MAIN_ADJ_DELAY 2000
  32          #define KEY_DOU_DELY 50
  33          #define KEY_LONG_DELY 100
  34          #define BELL_ON_DELY 50
  35          #define LONG_KEY_STEP_SWITCH 50
  36          #define DISP_ERR_TIMER 1000 //延时数据修改失败时间 和 错误显示时间
  37          
  38          //#define NO_KEY_RETURN_MAIN 15000 //00000菜单无按键返回主页面延时
  39          #define NO_KEY_RETURN_MAIN 30000 //00000菜单无按键返回主页面延时
  40          
  41          #define TEST_MODE_CNT    40
  42          //#define LEARN_MODE_CNT   20
  43          #define LEARN_MODE_CNT   30
  44          
  45          
  46          extern char eeprom_en;
  47          extern xdata unsigned int disp_buf[5];
  48          
  49          /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  50           |                                函数声明                                    |
  51          ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
  52          //void InitLEDDrivers(void);
  53          void LEDShowFlashString(const char  * buff,char x);
  54          //void LEDShowString(char  * buff,char x);
C51 COMPILER V9.00   LED_DISPLAY                                                           05/16/2016 14:48:04 PAGE 2   

  55          void LEDShowCharS(const char * buff,char num,char x);
  56          void LEDClearChar(char x,char n);
  57          void LEDClearCharS(char num,char x);
  58          void LED_ShowNumber(char * buff,char x);
  59          //void LED_ShowData(char * buff,char x,char nPoint);
  60          
  61          static char DataToStr(void * const pData,char size,char nBit,char nPoint,char *string,char nFlag,char nTyp
             -e);
  62          static long StrToData(char *string,char len,char nType);
  63          
  64          //extern void ResetDoorForTest();
  65          
  66          
  67          //sbit P17 = P1^7;
  68          //sbit P37 = P3^7;
  69          sbit P25 = P2^5;
  70          //sbit P21 = P2^1;
  71          //sbit P22 = P2^2;
  72          //sbit P14 = P1^4;
  73          
  74          //#define RED P17
  75          //#define YELLOW P54
  76          //#define BLUE P55
  77          
  78          
  79          
  80          
  81          //char xdata DIS_OPTIONING;                                                                                     ///<【不允许插引工作标志。0：允许插引；1：不允许插引】
  82          char xdata DIS_ERR_FLGA = 0;
  83          
  84          //内部变量定义
  85          //static xdata unsigned int  l_state;                                                           //显示画面状态
  86          
  87          //static xdata unsigned long  l_input_value;                                            //参数修改画面输入值
  88          static xdata char  l_stop_poll;                                                                 //停止循环显示
  89          
  90          //static xdata char DisplayStateOld;                                                            //记忆画面状态
  91          
  92          static xdata char  DisplayMainID;                                                                       //主画面序号
  93          static xdata char  DisplayMenuID;                                                                       //菜单画面序号
  94          
  95          static xdata char  DisplayMainTotal;                                                            //主画面总数
  96          static xdata char  MenuTotals;                                                                  //主菜单画面总数
  97          
  98          
  99          static xdata char  DisplayMenuTotal;                                                            //菜单画面总数
 100          
 101          static xdata char  DisplayItemNum;                                                              //显示项目序号
 102          static xdata char  DisplayBitNum;                                                                       //显示位号
 103          
 104          //static xdata char  MenuUpdateState;                                                           //菜单显示更新状态
 105          static xdata char  PasswordBuff[5];                                                             //密码数据缓冲区
 106          static xdata char  DisplayBuff[10];
 107          
 108          int  DisplayState;                                                                                      //画面状态
 109          xdata int  LCDDisplayState;
 110          xdata int  LCDChildDisplayState = 0;
 111          
 112          static xdata const MAIN_SHOW * pMain;                                                           //主画面数据指针
 113          static xdata const MENU_SHOW * pMenu;                                                           //菜单指针
 114          static xdata const MENU_ITEM * pItem;                                                           //菜单项目指针
 115          
C51 COMPILER V9.00   LED_DISPLAY                                                           05/16/2016 14:48:04 PAGE 3   

 116          //static xdata const MENU_SHOW * pCode;
 117          static xdata const MENU_SHOW * pDataValue;
 118          
 119          //static xdata const TYPE_CODE * disp_code;
 120          
 121          //static xdata char  UpdateDataCount;
 122          static xdata char  CycShowCount;
 123          static xdata char  InputDataLen;
 124          static xdata long  TempInputData;
 125          static xdata char  DataType;
 126          
 127          
 128          xdata public_stru public_val;
 129          xdata MENU_CHANG now_menu;
 130          
 131          xdata char cPauseBell = 0; 
 132          
 133          xdata char test_mode = 0;   /* 测试模式标志: 0正常工作模式，1测试模式 */
 134          
 135          
 136          xdata char uart_send_buf[100];
 137          
 138          
 139          //菜单配置界面
 140          //参数组定义
 141          //#define DEBUG_MENU_GS_VAL 30
 142          //#define USE_MENU_NUM 16
 143          
 144          static xdata MENU_SHOW Menu00000[MENU_ID_00000_MAX_ITEM];
 145          static xdata MENU_SHOW Menu10101[MENU_ID_10101_MAX_ITEM];
 146          static xdata MENU_SHOW Menu10102[MENU_ID_10102_MAX_ITEM];
 147          static xdata MENU_SHOW Menu10103[MENU_ID_10103_MAX_ITEM];
 148          static xdata MENU_SHOW Menu10104[MENU_ID_10104_MAX_ITEM];
 149          static xdata MENU_SHOW Menu20101[MENU_ID_20101_MAX_ITEM];
 150          
 151          xdata char Menu_Number[MENU_NUM] = {MENU_ID_00000_MAX_ITEM,
 152                                                                                  MENU_ID_10101_MAX_ITEM,
 153                                                                                  MENU_ID_10102_MAX_ITEM,
 154                                                                                  MENU_ID_10104_MAX_ITEM,
 155                                                                                  MENU_ID_20101_MAX_ITEM
 156                  };
 157          //xdata char Menu0_Number = 10, Menu1_Number = 20;
 158          
 159          /*--------------菜单设置画面 数据配置-------------*/
 160          code MENU_ITEM MenuItem[]={
 161            //菜单序号,菜单地址,密码 数据存储首地址 最大数据个数
 162                  {MENU_ID_00000,Menu00000,"00000",EEPROM_MENU_1,MENU_ID_00000_MAX_ITEM,0,&Menu_Number[0]}, 
 163                  {MENU_ID_10101,Menu10101,"10101",EEPROM_MENU_2,MENU_ID_10101_MAX_ITEM,0,&Menu_Number[2]}, 
 164                  {MENU_ID_10102,Menu10102,"10102",EEPROM_MENU_3,MENU_ID_10102_MAX_ITEM,0,&Menu_Number[3]}, 
 165                  {MENU_ID_10103,Menu10103,"10103",EEPROM_MENU_4,MENU_ID_10103_MAX_ITEM,0,&Menu_Number[4]}, 
 166                  {MENU_ID_10104,Menu10104,"10104",EEPROM_MENU_5,MENU_ID_10104_MAX_ITEM,0,&Menu_Number[5]}, 
 167                  {MENU_ID_20101,Menu20101,"20101",EEPROM_MENU_6,MENU_ID_20101_MAX_ITEM,0,&Menu_Number[6]}, 
 168                  {0,0,0}
 169          };
 170          
 171          code MAIN_SHOW MainItem[]={
 172              //显示的字符串,数据显示类型,数据地址,函数名
 173              {"",TY_D_A,0,&(public_val.main_disp_val),INT32_SIZE,5,0,99999,0},           
 174              {0,0,0}
 175          };
 176          
 177          /*-------------------------主画面数据配置,全局变量----------------------------*/
C51 COMPILER V9.00   LED_DISPLAY                                                           05/16/2016 14:48:04 PAGE 4   

 178          xdata const MAIN_PIC main_menu_cfg[]={
 179              {4,2,MainItem,MenuItem},
 180          };
 181          
 182          static code const char LED_ASCII[128]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //0x0
 183                                                      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
 184                                                      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //0x1
 185                                                      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
 186                                                      0x00,0xFE,0xB0,0xED,0xF9,0xB3,0xDB,0xDF, //0x2
 187                                                      0xF0,0xFF,0xFB,0x00,0x00,0x40,0x80,0x00, 
 188                                                      0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07, // 起始48:0-7
 189                                                      0x7f,0x6F,0x77,0x1F,0x4E,0x3D,0x4F,0x47, //     56
 190                                                      0xFB,0x77,0x1F,0x4E,0x3D,0x79,0x71,0xFB, //     64
 191                                                      0x37,0x06,0x0E,0x07,0x38,0x6A,0x76,0x1D, //     72
 192                                                      0x73,0x67,0x05,0x5B,0x31,0x3E,0x1C,0x5C, //     80
 193                                                      0x31,0x3B,0xED,0x00,0x00,0x00,0x62,0x08,
 194                                                      0x00,0x77,0x1F,0x4E,0x3D,0x4F,0x47,0xFB, //0x6
 195                                                      0x37,0x06,0x38,0x07,0x0E,0x6A,0x15,0x1D, 
 196                                                      0x67,0x73,0x50,0x5B,0x78,0x3E,0x1C,0x5C, //0x7
 197                                                      0x31,0x3B,0xED,0x00,0x00,0x00,0x00,0x00, 
 198                                     };
 199          
 200          //unsigned short usParamNum = 30;   /* 主板的配置参数个数，最大为30个 */
 201          
 202          xdata int gsKeyVal = 0;    /* 按键值 */
 203          xdata char gcKeyType = 0;  /* 按键类型: 0短按, 1长按下，2长按抬起 */
 204          
 205          //xdata char gcKeyLongUpFlag = 0;    /* 长按抬起标志:0未抬起，1抬起 */
 206          //xdata char gcKeyLongDownFlag = 0;  /* 长按按下标志:0未按下，1按下 */
 207          
 208          xdata _U_BIT_PARAM unKey;
 209           
 210          
 211          xdata char speed_mode = 1;   //速度模式: 1高速， 0低速
 212          
 213          xdata char qz_wait = 0;      //等待切纸确认: 0未等待，1等待
 214          
 215          //add by yq
 216          #define E1                              1       //完成设定筒数  本错误码只告警提示，不停机，为非故障报警。
 217          #define E2                                      2   //搓条机下料处无杆钎报错。
 218          #define E3                                      3   //搓条机弹片处无杆钎报错。
 219          #define E4                                      4   //切刀堵纸光电传感器报错。
 220          #define E5                                      5   //下料堵纸光电传感器报错。
 221          #define E6                                      6   //切刀零位接近传感器报错。
 222          #define E7                                      7   //储纸光电传感器感应到无纸。
 223          #define E8                                      8   //搓条周期接近传感器报错。
 224          #define E9                                      9       //打胶到位感应器报错。
 225          xdata int g_key_val_2;
 226          xdata char Menu0_Number;
 227          xdata unsigned int g_iFlashOldTime = 0;
 228          xdata unsigned int g_iInterfaceChangOldTime=0;
 229          xdata char* g_pcStatus = 0;
 230          xdata int g_iErrStatus =0;
 231          xdata int g_iErrUIChange =0;
 232          void ClearLCDScreen(int c);     
 233          void IOCheck();
 234          /*++++++++++++++++++++++++++++++++++++++++++++++++
 235          功能：显示字符串。
 236          
 237          参数：buff:欲发送的数据缓冲区；x:坐标
 238          
 239          返回值：无。
C51 COMPILER V9.00   LED_DISPLAY                                                           05/16/2016 14:48:04 PAGE 5   

 240          
 241          说明：
 242          ++++++++++++++++++++++++++++++++++++++++++++++++*/
 243          void  LEDShowFlashString(const char  * buff,char x) 
 244          {
 245   1              do
 246   1              {
 247   2                      disp_buf[x++] = LED_ASCII[*buff++];
 248   2              }while(x<6 && *buff!=0);
 249   1      }
 250          
 251          void  LEDShowCaption(char num) 
 252          {
 253   1      char *buff,x = 0;
 254   1      switch(num)
 255   1              {
 256   2                      case 0:
 257   2                              buff = "1-";
 258   2                      break;
 259   2                      case 1:
 260   2                              buff = "2-";
 261   2                      break;          
 262   2                      case 2:
 263   2                              buff = "3-";
 264   2                      break;  
 265   2                      case 3:
 266   2                              buff = "4-";
 267   2                      break;          
 268   2                      case 4:
 269   2                              buff = "5-";
 270   2                      break;          
 271   2                      case 5:
 272   2                              buff = "6-";
 273   2                      break;          
 274   2                      case 6:
 275   2                              buff = "7-";
 276   2                      break;          
 277   2                      case 7:
 278   2                              buff = "8-";
 279   2                      break;          
 280   2                      case 8:
 281   2                              buff = "9-";
 282   2                      break;          
 283   2                      case 9:
 284   2                              buff = "10";
 285   2                      break;          
 286   2                      case 10:
 287   2                              buff = "11";
 288   2                      break;          
 289   2                      case 11:
 290   2                              buff = "12";
 291   2                      break;          
 292   2                      case 12:
 293   2                              buff = "13";
 294   2                      break;  
 295   2                      case 13:
 296   2                              buff = "14";
 297   2                      break;  
 298   2                      case 14:
 299   2                              buff = "15";
 300   2                      break;  
 301   2                      case 15:
C51 COMPILER V9.00   LED_DISPLAY                                                           05/16/2016 14:48:04 PAGE 6   

 302   2                              buff = "16";
 303   2                      break;  
 304   2                      case 16:
 305   2                              buff = "17";
 306   2                      break;
 307   2                      case 17:
 308   2                              buff = "18";
 309   2                      break;  
 310   2                      case 18:
 311   2                              buff = "19";
 312   2                      break;  
 313   2                      case 19:
 314   2                              buff = "20";
 315   2                      break;                  
 316   2                      case 20:
 317   2                              buff = "21";
 318   2                      break;          
 319   2                      case 21:
 320   2                              buff = "22";
 321   2                      break;          
 322   2                      case 22:
 323   2                              buff = "23";
 324   2                      break;  
 325   2                      case 23:
 326   2                              buff = "24";
 327   2                      break;  
 328   2                      case 24:
 329   2                              buff = "25";
 330   2                      break;  
 331   2                      case 25:
 332   2                              buff = "26";
 333   2                      break;  
 334   2                      case 26:
 335   2                              buff = "27";
 336   2                      break;
 337   2                      case 27:
 338   2                              buff = "28";
 339   2                      break;  
 340   2                      case 28:
 341   2                              buff = "29";
 342   2                      break;  
 343   2                      case 29:
 344   2                              buff = "30";
 345   2                      break;  
 346   2                      case 80:
 347   2                              buff = "   A1";
 348   2                      break;
 349   2                      case 81:
 350   2                              buff = "   A2";
 351   2                      break;
 352   2                      case 82:
 353   2                              buff = "   A3";
 354   2                      break;
 355   2                      case 83:
 356   2                              buff = "   A4";
 357   2                      break;
 358   2                      case 84:
 359   2                              buff = "   A5";
 360   2                      break;
 361   2                      case 85:
 362   2                              buff = "   A6";
 363   2                      break;
C51 COMPILER V9.00   LED_DISPLAY                                                           05/16/2016 14:48:04 PAGE 7   

 364   2                      case 86:
 365   2                              buff = "   A7";
 366   2                      break;
 367   2                      case 87:
 368   2                              buff = "   A8";
 369   2                      break;
 370   2                      case 88:
 371   2                              buff = "   A9";
 372   2                      break;
 373   2                      case 89:
 374   2                              buff = "  A10";
 375   2                      break;
 376   2              }
 377   1              do
 378   1              {
 379   2                      disp_buf[x++] = LED_ASCII[*buff++];
 380   2              }while(x<6 && *buff!=0);
 381   1      }
 382          
 383          /*++++++++++++++++++++++++++++++++++++++++++++++++
 384          功能：显示字符串。
 385          
 386          参数：buff:欲发送的数据缓冲区；x:坐标
 387          
 388          返回值：无。
 389          
 390          说明：
 391          ++++++++++++++++++++++++++++++++++++++++++++++++*/
 392          /*void  LEDShowString(char  * buff,char x) 
 393          {
 394                  do
 395                  {
 396                          disp_buf[x++] = LED_ASCII[*buff++];
 397                  
 398                  }while(x<6 && *buff!=0);
 399          }*/
 400          
 401          /*void  LED_ShowData(char * buff,char x,char nPoint)
 402          {
 403              do
 404                  {
 405                  if(nPoint !=0 && (8-nPoint)==x)
 406                          disp_buf[x++] = LED_ASCII[*buff++] | 0x80;              ///<【位7置1】
 407                          else
 408                                  disp_buf[x++] = LED_ASCII[*buff++];
 409                  }while(x<6 && *buff!=0);
 410          }*/
 411          
 412          /*++++++++++++++++++++++++++++++++++++++++++++++++
 413          功能：清除指定行号列号的字符。
 414          
 415          参数：x:坐标1-8。
 416          
 417          返回值：无。
 418          
 419          说明： 无。
 420          ++++++++++++++++++++++++++++++++++++++++++++++++*/
 421          void  LEDClearChar(char x,char n)
 422          {
 423   1              char i;
 424   1              for(i = x; i< (x+n); i++ )
 425   1                      {
C51 COMPILER V9.00   LED_DISPLAY                                                           05/16/2016 14:48:04 PAGE 8   

 426   2                              disp_buf[i] = 0;                
 427   2                      }
 428   1      }
 429          
 430          
 431          /*++++++++++++++++++++++++++++++++++++++++++++++++
 432          功能：显示数字。
 433          参数：buff:欲发送的数据缓冲区；x:坐标
 434          返回值：无。
 435          说明：
 436          ++++++++++++++++++++++++++++++++++++++++++++++++*/
 437          void  LED_ShowNumber(char * buff,char x) 
 438          {
 439   1              char TempFlag=0;
 440   1              do
 441   1              {
 442   2                      if(*(buff+1)!='.' || TempFlag==1)
 443   2                      {
 444   3                              disp_buf[x++] = LED_ASCII[*buff++];
 445   3                              //SendLed(x++,LED_ASCII[*buff++]);
 446   3                      }
 447   2                      else
 448   2                      {
 449   3                              disp_buf[x++] = LED_ASCII[*buff++] | 0x80;
 450   3                              //SendLed(x++,(LED_ASCII[*buff++] | 0x80));
 451   3                              TempFlag=1;
 452   3                              buff++;
 453   3                      }
 454   2              }while(x<6);
 455   1              
 456   1      }
 457          
 458          //菜单数据指向
 459          void menu_cfg(void)
 460          {
 461   1              char i;
 462   1              for(i = 0; i < MENU_ID_00000_MAX_ITEM ; i++)
 463   1                      {
 464   2                              Menu00000[i].m_data_vale = &public_val.Disp_Dz_00000[i];
 465   2                      }
 466   1      
 467   1              for(i = 0; i < MENU_ID_10101_MAX_ITEM ; i++)
 468   1                      {
 469   2                              Menu10101[i].m_data_vale = &public_val.Disp_Dz_10101[i];
 470   2                      }
 471   1      
 472   1              for(i = 0; i < MENU_ID_10102_MAX_ITEM ; i++)
 473   1                      {
 474   2                              Menu10102[i].m_data_vale = &public_val.Disp_Dz_10102[i];
 475   2                      }
 476   1              
 477   1              for(i = 0; i < MENU_ID_10103_MAX_ITEM ; i++)
 478   1                      {
 479   2                              Menu10103[i].m_data_vale = &public_val.Disp_Dz_10103[i];
 480   2                      }
 481   1      
 482   1              for(i = 0; i < MENU_ID_10104_MAX_ITEM ; i++)
 483   1                      {
 484   2                              Menu10104[i].m_data_vale = &public_val.Disp_Dz_10104[i];
 485   2                      }
 486   1      
 487   1              for(i = 0; i < MENU_ID_20101_MAX_ITEM ; i++)
C51 COMPILER V9.00   LED_DISPLAY                                                           05/16/2016 14:48:04 PAGE 9   

 488   1                      {
 489   2                              Menu20101[i].m_data_vale = &public_val.Disp_Dz_20101[i];
 490   2                      }
 491   1      }
 492          
 493          /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 494          名称:   read_menu_data(char menu_id)
 495          功能：  读取菜单配置数据 和 菜单数据
 496          参数：  无
 497          返回值：无
 498          ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
 499          
 500          
 501          void read_menu_data(char menu_id)
 502          {
 503   1              unsigned char *progbyte,read_byte;
 504   1              unsigned int progadd;
 505   1      
 506   1              int i;
 507   1      
 508   1              progadd = MenuItem[menu_id].eeprom_cfg_add;
 509   1              read_byte = IapReadByte(progadd++);
 510   1              
 511   1              for(i = 0; i < MenuItem[menu_id].MenuItem_Max; i++)
 512   1                      {
 513   2                              if(menu_id == MENU_ID_10104)
 514   2                                      MenuItem[menu_id].m_pcfg[i].m_max = 450;
 515   2                              else
 516   2                                      MenuItem[menu_id].m_pcfg[i].m_max = 999;
 517   2                              MenuItem[menu_id].m_pcfg[i].m_min = 0;
 518   2                              MenuItem[menu_id].m_pcfg[i].ext_property = 0; //read_byte;
 519   2                      }
 520   1              MenuItem[MENU_ID_10104].m_pcfg[PASS_LOCK_COUNT - 1].m_max = 500;
 521   1              
 522   1              switch(menu_id)
 523   1                      {
 524   2                              case MENU_ID_00000:
 525   2                                      progbyte = (unsigned char *)&public_val.Disp_Dz_00000[0];
 526   2                              break;                  
 527   2                              case MENU_ID_10101:
 528   2                                      progbyte = (unsigned char *)&public_val.Disp_Dz_10101[0];
 529   2                              break;
 530   2                              case MENU_ID_10102:
 531   2                                      progbyte = (unsigned char *)&public_val.Disp_Dz_10102[0];
 532   2                              break;
 533   2                              case MENU_ID_10103:
 534   2                                      progbyte = (unsigned char *)&public_val.Disp_Dz_10103[0];
 535   2                              break;
 536   2                              case MENU_ID_10104:
 537   2                                      progbyte = (unsigned char *)&public_val.Disp_Dz_10104[0];
 538   2                              break;
 539   2                              case MENU_ID_20101:
 540   2                                      progbyte = (unsigned char *)&public_val.Disp_Dz_20101[0];
 541   2                              break;
 542   2                      }
 543   1              progadd = MenuItem[menu_id].eeprom_add;
 544   1              for(i = 0; i < MenuItem[menu_id].MenuItem_Max + 1; i++)
 545   1                      {
 546   2                              *progbyte = IapReadByte(progadd++);
 547   2                              progbyte++;
 548   2                              *progbyte = IapReadByte(progadd++);
 549   2                              progbyte++;
C51 COMPILER V9.00   LED_DISPLAY                                                           05/16/2016 14:48:04 PAGE 10  

 550   2                      }
 551   1                      
 552   1              
 553   1      }
 554          
 555          //将菜单值更新到通讯菜单值，合并两个菜单。
 556          void update_menu_to_com(void)
 557          {
 558   1              char TempB;
 559   1              for(TempB = 0; TempB < MENU_ID_00000_MAX_ITEM; TempB++)
 560   1                      {
 561   2                              public_val.menu_parm[TempB] = public_val.Disp_Dz_00000[TempB];
 562   2                      }
 563   1      
 564   1              for(TempB = 0; TempB < MENU_ID_10101_MAX_ITEM; TempB++)
 565   1                      {
 566   2                              public_val.menu_parm[TempB + MENU_ID_00000_MAX_ITEM] = public_val.Disp_Dz_10101[TempB];
 567   2                      }       
 568   1      }
 569          
 570          //读取MCU的ID号 值举例:0D 00 00 2C 02 4B E5
 571          //                                         0D 00 00 30 03 64 E4(开发板载MCU)
 572          void read_id()
 573          {
 574   1          char code *cptr;
 575   1              char i,read_byte[7];
 576   1          cptr = ID_ADDR_ROM;         //从程序区读取ID号
 577   1          for(i=0; i<7; i++)         //读7个字节
 578   1                  {
 579   2                      read_byte[i] = *cptr++; // 0xff; // 
 580   2                  }
 581   1              public_val.password_index_disp = (int)read_byte[5];
 582   1              public_val.password_index_disp <<= 8;
 583   1              public_val.password_index_disp |= (int)read_byte[6] & 0xff;
 584   1              public_val.password_index = public_val.password_index_disp % 2000;
 585   1      
 586   1              cptr = EEPROM_PASSWORD;
 587   1              read_byte[0] = IapReadByte(EEPROM_PASSWORD + (public_val.password_index<<1));
 588   1              read_byte[1] = IapReadByte(EEPROM_PASSWORD + (public_val.password_index<<1)+1);
 589   1              public_val.password_val[0] = (int)read_byte[0] & 0xff;
 590   1              public_val.password_val[1] = (int)read_byte[1] & 0xff;
 591   1      }       
 592          
 593          /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 594          名称:   void InitLEDDisplay(void)
 595          
 596          功能：  显示初始化程序
 597          
 598          参数：  无
 599                
 600          返回值：无
 601          ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
 602          void InitLEDDisplay(void)
 603          {
 604   1          char TempB;
 605   1          //unsigned int temp_int;
 606   1                      
 607   1              BELL = 0;
 608   1      
 609   1              //LEDShowFlashString("Lt-2 ",0);
 610   1              LEDShowFlashString("60409",0);    /* 显示操作板版本号 */
 611   1              
C51 COMPILER V9.00   LED_DISPLAY                                                           05/16/2016 14:48:04 PAGE 11  

 612   1      //      TM1637_Write();
 613   1      
 614   1              ///【统计主界面需要显示的项数】
 615   1              pMain = main_menu_cfg[0].m_main;
 616   1              for( TempB = 0; pMain[TempB].m_str; TempB++ ) ///<【空串不为0，即不为假】
 617   1                      {
 618   2                              ;
 619   2                      }                       
 620   1              DisplayMainTotal = TempB;
 621   1      
 622   1              ///【统计下级子菜单数量】
 623   1              pItem = main_menu_cfg[0].m_menu;
 624   1              pMenu = pItem[0].m_pcfg;
 625   1              for(TempB = 0; TempB == pItem[TempB].MenuID; TempB++) 
 626   1                      {
 627   2                              read_menu_data(TempB); //读取菜单数据值;
 628   2                      }
 629   1              MenuTotals = TempB;
 630   1              update_menu_to_com();
 631   1      
 632   1              menu_cfg();
 633   1              
 634   1              
 635   1              CycShowCount = 0;
 636   1              DisplayItemNum = 0;
 637   1              DisplayState = ST_MAIN;                                                                 //进入主画面
 638   1              l_stop_poll = 0;                                                                                //默认定格显示
 639   1              
 640   1              //标志位初始化
 641   1              public_val.Work_Pause_Flag = 0; 
 642   1              public_val.Err_Flag = 0;
 643   1              public_val.Bell_Flag = 0;
 644   1      
 645   1              public_val.cnt_after_powered = 0;
 646   1              public_val.Lock_Flag = 0;
 647   1      
 648   1              //加密相关变量初始化
 649   1              read_id();
 650   1      
 651   1              public_val.Disp_Dz_10103[12] = public_val.password_val[0];
 652   1              public_val.Disp_Dz_10103[13] = public_val.password_val[1];
 653   1              
 654   1              public_val.input_pass_mask = 0;
 655   1              for(TempB = 0; TempB < PASS_LOCK_COUNT; TempB++)
 656   1                      {
 657   2                              if( (public_val.Disp_Dz_10103[TempB * 2] == 0)
 658   2                                      && (public_val.Disp_Dz_10103[TempB * 2 + 1] == 0)
 659   2                                      )
 660   2                                      {
 661   3                                              public_val.input_pass_mask |= 1 << TempB;
 662   3                                      }
 663   2                              public_val.Disp_Dz_10102[TempB * 2] = 0;
 664   2                              public_val.Disp_Dz_10102[TempB * 2 + 1] = 0;
 665   2                      }
 666   1              
 667   1              read_loack_count();
 668   1              read_user_count();
 669   1              public_val.Disp_Dz_20101[0] = public_val.work_count / LOCK_UNIT; //已生产根数赋值
 670   1              /* added by james */
 671   1          public_val.ms_timer = 0;
 672   1              public_val.io_read = 0;
 673   1      
C51 COMPILER V9.00   LED_DISPLAY                                                           05/16/2016 14:48:04 PAGE 12  

 674   1              unKey.all = 0xFFFF;
 675   1      
 676   1      }
 677          
 678          
 679          //完成对菜单数据的存储
 680          void func_menu_update(int menu_id)
 681          {
 682   1              unsigned char *progbyte,i,readbyte;
 683   1              unsigned int progadd;
 684   1              
 685   1              eeprom_en = 0xaa;
 686   1              IapEraseSector(MenuItem[menu_id].eeprom_add);
 687   1              eeprom_en = 0;
 688   1              switch(menu_id)
 689   1                      {
 690   2                              case MENU_ID_00000:
 691   2                                      progbyte = (unsigned char *)&public_val.Disp_Dz_00000[0];
 692   2                              break;                  
 693   2                              case MENU_ID_10101:
 694   2                                      progbyte = (unsigned char *)&public_val.Disp_Dz_10101[0];
 695   2                              break;
 696   2                              case MENU_ID_10102:
 697   2                                      progbyte = (unsigned char *)&public_val.Disp_Dz_10102[0];
 698   2                              break;
 699   2                              case MENU_ID_10103:
 700   2                                      progbyte = (unsigned char *)&public_val.Disp_Dz_10103[0];
 701   2                              break;
 702   2                              case MENU_ID_10104:
 703   2                                      progbyte = (unsigned char *)&public_val.Disp_Dz_10104[0];
 704   2                              break;
 705   2                              case MENU_ID_20101:
 706   2                                      progbyte = (unsigned char *)&public_val.Disp_Dz_20101[0];
 707   2                              break;
 708   2                              break;                  
 709   2                      }
 710   1              progadd = MenuItem[menu_id].eeprom_add;
 711   1              for(i = 0; i < MenuItem[menu_id].MenuItem_Max + 1; i++)
 712   1                      {
 713   2                              //SendData(*(progbyte));
 714   2                              eeprom_en = 0xaa;
 715   2                              IapProgramByte(progadd,*(progbyte));
 716   2                              readbyte = IapReadByte(progadd);
 717   2                              if(readbyte != *progbyte)
 718   2                                      public_val.Err_Flag |= ERR_NUM_EEP_ERR; //写EERPOM错误
 719   2                              progbyte++;
 720   2                              progadd++;
 721   2                              //SendData(*(progbyte));
 722   2                              IapProgramByte(progadd,*(progbyte));
 723   2                              readbyte = IapReadByte(progadd);
 724   2                              if(readbyte != *progbyte)
 725   2                                      public_val.Err_Flag |= ERR_NUM_EEP_ERR;
 726   2                              progbyte++;
 727   2                              progadd++;
 728   2                              eeprom_en = 0;
 729   2                      }
 730   1              update_menu_to_com();
 731   1              write_param_flag = 1;    // 更新下位机参数
 732   1                              
 733   1      }
 734          
 735          #if 0
C51 COMPILER V9.00   LED_DISPLAY                                                           05/16/2016 14:48:04 PAGE 13  

              //完成对版本号的存储
              void func_ver_update(void)
              {
                      char progbyte;
                      eeprom_en = 0xaa;
                      IapEraseSector(EEPROM_DRIVE_TYPE);
                      eeprom_en = 0;
                      progbyte = (unsigned char)(public_val.drive_type >> 8);
                      eeprom_en = 0xaa;
                      IapProgramByte(EEPROM_DRIVE_TYPE,progbyte);
                      progbyte = (unsigned char)(public_val.drive_type & 0xff);
                      IapProgramByte(EEPROM_DRIVE_TYPE + 1,progbyte);
                      progbyte = public_val.drive_indx;
                      
                      IapProgramByte(EEPROM_DRIVE_INDX,progbyte);
                      eeprom_en = 0;
              }
              
              //完成对菜单配置的存储
              void func_cfg_update(int menu_id)
              {
              unsigned char i,progbyte;
              unsigned int progadd;
                      eeprom_en = 0xaa;
                      IapEraseSector(MenuItem[menu_id].eeprom_cfg_add);
                      progadd = MenuItem[menu_id].eeprom_cfg_add;
                      progbyte = (unsigned char)(*(MenuItem[menu_id].com_max_item));
                      IapProgramByte(progadd++,progbyte);
                      
                      for(i = 0; i < MenuItem[menu_id].MenuItem_Max; i++)
                              {
                                      progbyte = (unsigned char)(MenuItem[menu_id].m_pcfg[i].m_max >> 8);
                                      IapProgramByte(progadd++,progbyte);
                                      progbyte = (unsigned char)(MenuItem[menu_id].m_pcfg[i].m_max & 0xff);
                                      IapProgramByte(progadd++,progbyte);
                                      progbyte = (unsigned char)(MenuItem[menu_id].m_pcfg[i].m_min >> 8);
                                      IapProgramByte(progadd++,progbyte);
                                      progbyte = (unsigned char)(MenuItem[menu_id].m_pcfg[i].m_min & 0xff);
                                      IapProgramByte(progadd++,progbyte);
                                      progbyte = (unsigned char)(MenuItem[menu_id].m_pcfg[i].ext_property);
                                      IapProgramByte(progadd++,progbyte);
                              }
                      eeprom_en = 0;
              }
              
              #endif
 782          
 783          /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 784          名称:   void LEDDisplay(char Key,char UpdateState)
 785          功能：  显示运行程序
 786          参数：  无
 787          返回值：无
 788          ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
 789          
 790          
 791          /* 测试模式内容显示 */
 792          void test_set_display(char test_mode)
 793          {
 794   1              switch (test_mode)
 795   1              {
 796   2                      case 0:
 797   2                              LEDShowFlashString(" F--0",0);                  
C51 COMPILER V9.00   LED_DISPLAY                                                           05/16/2016 14:48:04 PAGE 14  

 798   2                              break;
 799   2                      case 1:
 800   2                              LEDShowFlashString(" F--1",0);
 801   2                              break;
 802   2                      case 2:
 803   2                              LEDShowFlashString(" F--2",0);
 804   2                              break;                  
 805   2                      case 3:
 806   2                              LEDShowFlashString(" F--3",0);
 807   2                              break;  
 808   2                      case 4:
 809   2                              LEDShowFlashString(" F--4",0);
 810   2                              break;                          
 811   2                      case 5:
 812   2                              LEDShowFlashString(" F--5",0);
 813   2                              break;                          
 814   2                      default:
 815   2                              break;
 816   2              }       
 817   1      }
 818          
 819          
 820          
 821          void LEDDisplay(void)
 822          {
 823   1          char TempCountB,TempDataB,TempValue,i,TempB;
 824   1          static xdata char Bell_flag = 0,zc_key_flag = 0;
 825   1          static xdata unsigned int UpdateCountB,TempCount,flash_flag = 0;    
 826   1              static xdata long DisplayValueTemp;
 827   1              
 828   1              //static xdata char Key_Val = 0,Pr_Key_Val = 0;
 829   1              //static xdata char old_key = 0;
 830   1              static xdata int Key_Val = 0,Pr_Key_Val = 0, old_key = 0;
 831   1      
 832   1              static xdata char UpdateState = 0;
 833   1      
 834   1              static xdata int Read_key_dely = 0,Read_key_dely_2 = 0,long_count = 0,long_input_flag = 0;
 835   1              static xdata int Read_key_dely_3 = 0,No_key_delay = 0;
 836   1              static xdata int Main_adj_key_delay = 0,Main_disp_other = 0;
 837   1              static xdata int edit_menu_id = 0;
 838   1              static xdata int bell_delay;
 839   1              static xdata int long_key_count = 0,long_key_step = 1,pr_long_input_flag;
 840   1              static xdata char war_bell_step = 0;
 841   1              static xdata int war_bell_delay = 0;
 842   1      
 843   1              static xdata char test_key_cnt = 0;   /* 主界面下选择键连按计数 added by james for v19407 */
 844   1              //static xdata char learn_key_cnt = 0; 
 845   1      
 846   1              int temp_max;   
 847   1              int iBellOnTime, iBellOffTime;
 848   1      
 849   1              static xdata unsigned int dj_key_dely = 0,dj_key_step = 0;
 850   1              //ADD by yq
 851   1              xdata char lcd_disp_buf[50*2] = {0};
 852   1              xdata unsigned char  cMenuSn;
 853   1              xdata int iLen=0,iCount=0;
 854   1              MENU_SHOW *pLCDDataValue;
 855   1              xdata unsigned char  cLcd_data_buf[6]={0},cLcd_len_data_buf[6]={0},cLcd_count_data_buf[6]={0};
 856   1              
 857   1              
 858   1              unKey.u_bit.K1 = P24;
 859   1              unKey.u_bit.K2 = P23;
C51 COMPILER V9.00   LED_DISPLAY                                                           05/16/2016 14:48:04 PAGE 15  

 860   1              unKey.u_bit.K3 = P22;
 861   1              unKey.u_bit.K4 = P21;
 862   1              
 863   1              unKey.u_bit.IO1 = P20;
 864   1              unKey.u_bit.IO2 = P35;
 865   1              unKey.u_bit.IO3 = P33;
 866   1              unKey.u_bit.IO4 = P32;
 867   1              unKey.u_bit.IO5 = P26;
 868   1              unKey.u_bit.IO6 = P27;
 869   1              unKey.u_bit.IO7 = P12;
 870   1              unKey.u_bit.IO8 = P13;
 871   1              unKey.u_bit.IO9 = P16;
 872   1      
 873   1              unKey.u_bit.RED = P17;
 874   1              unKey.u_bit.GREEN = P54;
 875   1              unKey.u_bit.BLUE = P55; 
 876   1      
 877   1              Key_Val = (int)unKey.all; 
 878   1              
 879   1              //Key_Val = (P2 >> 1) & 0x0f;
 880   1              //Key_Val |= 0xf0;
 881   1              if(Key_Val != old_key) //有按键
 882   1              {
 883   2                      No_key_delay = public_val.ms_timer;
 884   2                      
 885   2                      if(!long_input_flag)
 886   2                      {
 887   3                              bell_delay = public_val.ms_timer;
 888   3                              Bell_flag |= 0x01;
 889   3                      }
 890   2                      else
 891   2                      {
 892   3                              Bell_flag &= 0xfe;
 893   3                      }
 894   2                      
 895   2                      if( (public_val.ms_timer - Read_key_dely_2) > KEY_DOU_DELY)
 896   2                      {
 897   3                              old_key = Key_Val;
 898   3                              Read_key_dely = public_val.ms_timer;
 899   3                              long_count = 0;
 900   3                              long_input_flag = 0;
 901   3                              long_key_step = 1;
 902   3                      }
 903   2                      else
 904   2                      {
 905   3                              Key_Val = 0;
 906   3                      }
 907   2                      
 908   2              }
 909   1              else
 910   1              {
 911   2                      if( (public_val.ms_timer - bell_delay) > BELL_ON_DELY)
 912   2                      {
 913   3                              Bell_flag &= 0xfe;
 914   3                      }
 915   2      
 916   2                      if( (public_val.ms_timer - No_key_delay) > NO_KEY_RETURN_MAIN)
 917   2                      {
 918   3                              No_key_delay = public_val.ms_timer;
 919   3                              
 920   3                              //if(edit_menu_id == MENU_ID_00000)
 921   3                              if ((edit_menu_id == MENU_ID_00000) && (DisplayState != ST_LEARN))
C51 COMPILER V9.00   LED_DISPLAY                                                           05/16/2016 14:48:04 PAGE 16  

 922   3                              {
 923   4                                      DisplayState = ST_MAIN;
 924   4                                      Main_disp_other = 0;    /* added by james for v19407 */
 925   4                              }
 926   3                      }
 927   2                      
 928   2                      if( (public_val.ms_timer - Read_key_dely) > KEY_DOU_DELY)
 929   2                      {
 930   3                              Read_key_dely_2 = public_val.ms_timer;
 931   3                              
 932   3                              //if( ( (Key_Val&0xff) != 0xff) && (!long_input_flag) )
 933   3                              if( ( (Key_Val&0xffff) != 0xffff) && (!long_input_flag) )
 934   3                              {
 935   4                                      long_count++;
 936   4                                      
 937   4                                      //if(long_count > 10)
 938   4                                      if(long_count > 100)   
 939   4                                      {                                                       
 940   5                                              long_input_flag = 1;
 941   5                                              long_key_step = 1;
 942   5                                              long_key_count = 0;
 943   5                                              Read_key_dely_3 = public_val.ms_timer; 
 944   5                                              long_count = 10;
 945   5                                      }
 946   4                              }                                       
 947   3                      }
 948   2                      else
 949   2                      {
 950   3                              Key_Val = 0;
 951   3      
 952   3                      }
 953   2              }
 954   1              
 955   1              if(long_input_flag)  /* 长按 */
 956   1              {
 957   2                      if(public_val.ms_timer - Read_key_dely_3 > KEY_LONG_DELY)
 958   2                      {
 959   3                              long_key_count ++;
 960   3                              if(long_key_count > LONG_KEY_STEP_SWITCH)
 961   3                              {
 962   4                                      long_key_step = 10;
 963   4                              }
 964   3                              if(long_key_count)
 965   3                                      Read_key_dely_3 = public_val.ms_timer;
 966   3                              Pr_Key_Val = 0xFF;
 967   3                      }
 968   2              }
 969   1              
 970   1              if(Key_Val)
 971   1              {
 972   2                      if(Key_Val != Pr_Key_Val)
 973   2                      {
 974   3                              Pr_Key_Val = Key_Val;
 975   3                      }
 976   2                      else
 977   2                      {
 978   3                              Key_Val = 0;
 979   3                      }
 980   2              }
 981   1      
 982   1      
 983   1              /* 有按键则下发按键值和按键类型 */
C51 COMPILER V9.00   LED_DISPLAY                                                           05/16/2016 14:48:04 PAGE 17  

 984   1                      
 985   1              if ((Key_Val == KEY_IO6) || (Key_Val == KEY_IO7) 
 986   1                      || (Key_Val == KEY_IO8))
 987   1              {
 988   2                      if(public_val.Lock_Flag && (Key_Val == KEY_IO7))
 989   2                              {
 990   3                                      public_val.Err_Flag = ERR_LOCK_SYS_ERR + public_val.Lock_Flag;  //锁机错误20
 991   3                              }
 992   2                      else
 993   2                              {
 994   3                                      write_key_flag = 1;   /* 有按键，需要写按键到主板 */
 995   3                                      
 996   3                                      gsKeyVal = Key_Val;
 997   3                                      gcKeyType = KEY_SHORT_UP_FLAG;                          
 998   3                              }
 999   2      
1000   2              }
1001   1      
1002   1              //打胶按键单独处理。
1003   1              switch(dj_key_step)
1004   1                      {
1005   2                              case 0:
1006   2                                      if(!P14)
1007   2                                      {
1008   3                                              dj_key_step = 10;
1009   3                                              dj_key_dely = public_val.ms_timer;
1010   3                                      }
1011   2                              break;
1012   2                              case 10:
1013   2                                      if(!P14)
1014   2                                              {
1015   3                                                      if(public_val.ms_timer - dj_key_dely > 100)
1016   3                                                              {
1017   4                                                                      dj_key_step = 20;
1018   4                                                              }
1019   3                                              }
1020   2                                      else
1021   2                                              {
1022   3                                                      dj_key_step = 0;
1023   3                                              }
1024   2                              break;
1025   2                              case 20:
1026   2                                      if(P14)
1027   2                                              {
1028   3                                                      write_key_flag = 1;   /* 有按键，需要写按键到主板 */
1029   3                                                      gsKeyVal = KEY_DJ;
1030   3                                                      gcKeyType = KEY_SHORT_UP_FLAG;
1031   3                                                      dj_key_step = 0;
1032   3                                                      //add by yq
1033   3                                                      g_key_val_2= KEY_DJ;
1034   3                                              }
1035   2                              break;
1036   2                      }
1037   1                      
1038   1              //按键状态显示  add by yq
1039   1              if(LCDChildDisplayState != 8)
1040   1              switch(Key_Val)
1041   1              {
1042   2                      case 0xFFFF://无按键
1043   2                      case 0x0000:
1044   2                              if(g_key_val_2 == KEY_DJ)
1045   2                              {
C51 COMPILER V9.00   LED_DISPLAY                                                           05/16/2016 14:48:04 PAGE 18  

1046   3                                      g_key_val_2= 0; //清除打胶键值
1047   3                                      g_pcStatus= "打胶";
1048   3                              }
1049   2                              else
1050   2                                      g_pcStatus = 0;
1051   2                              break;
1052   2                      case KEY_K2:
1053   2                              //public_val.Err_Flag++;
1054   2                              break;
1055   2                      case KEY_K3:
1056   2                              //public_val.Err_Flag--;
1057   2                              break;
1058   2                      case KEY_K1: //选择
1059   2                              if((LCDChildDisplayState == 2  ||  LCDChildDisplayState == 3 )&& DisplayState == ST_MAIN)
1060   2                              {
1061   3                                      LCDDisplayState = 0x00;
1062   3                                      LCDChildDisplayState = 0;
1063   3                              }
1064   2                              if(g_iErrStatus == 1)
1065   2                                      g_iErrUIChange =1;
1066   2                              break;
1067   2                      case KEY_K4:           /* 确认 */
1068   2                              if((LCDChildDisplayState == 2 || LCDChildDisplayState == 3 ) && DisplayState == ST_MAIN)//如果处于主界
             -娴淖咏缑嬗邪醇就返回
1069   2                              {                       
1070   3                              //      LCDChildDisplayState =0;
1071   3                              //      LCDDisplayState = 0x00;
1072   3                              }
1073   2                              else if(LCDChildDisplayState == 0 && DisplayState == ST_MAIN)
1074   2                                      LCDChildDisplayState = 1;
1075   2                              if(g_iErrStatus == 1)
1076   2                                      g_iErrUIChange =1;      
1077   2                              break;
1078   2                      case KEY_IO1:          /* 进纸 */
1079   2                              g_pcStatus = "进纸";
1080   2                              break;
1081   2                      case KEY_IO2:              /* 退纸 */
1082   2                              g_pcStatus = "退纸";
1083   2                              break;
1084   2                      case KEY_IO3:          /* 切纸 */
1085   2                              //g_pcStatus = "切纸";
1086   2                              
1087   2                              if(g_iErrStatus == 1)
1088   2                                      g_iErrUIChange =1;
1089   2                              
1090   2                              LCDChildDisplayState =8;
1091   2                              break;
1092   2                      case KEY_IO4:              /* 下料 */
1093   2                              g_pcStatus = "下料";
1094   2                              break;
1095   2                      case KEY_IO5:          /* 搓条 */
1096   2                              g_pcStatus = "搓条";
1097   2                              break;
1098   2                      case KEY_IO6:          /* 停止送纸 */
1099   2                              g_pcStatus = "停纸";    
1100   2                              break;
1101   2                      case KEY_IO7:          /* 启动 */
1102   2                              g_pcStatus = "启动";
1103   2                              break;
1104   2                      case KEY_IO8:          /* 停止 */
1105   2                              g_pcStatus = "停止";
1106   2                              break;
C51 COMPILER V9.00   LED_DISPLAY                                                           05/16/2016 14:48:04 PAGE 19  

1107   2                      case KEY_IO9:          /* 发纸 */
1108   2                              g_pcStatus = "发纸";
1109   2                              break;
1110   2                      case KEY_RED:          /* 收纸 */
1111   2                              g_pcStatus = "收纸";
1112   2                              break;
1113   2                      case KEY_GREEN:            /* 纸长 */
1114   2                              if(g_iErrStatus == 1)
1115   2                                      g_iErrUIChange =1;
1116   2                              break;
1117   2                      case KEY_BLUE:         /* 捆数 */
1118   2                              if(g_iErrStatus == 1)
1119   2                                      g_iErrUIChange =1;
1120   2                              break;
1121   2                      case KEY_DJ:        /* 打胶 */
1122   2                              g_pcStatus= "打胶";
1123   2                              break;
1124   2                      default:
1125   2                              
1126   2                              break;
1127   2              }
1128   1              
1129   1          switch(DisplayState)
1130   1              {
1131   2                  case ST_MAIN:   /* 主界面 */
1132   2                  {
1133   3                      switch(Key_Val)
1134   3                          {
1135   4                              case KEY_SEL:
1136   4      
1137   4                                              test_key_cnt = 0;
1138   4                                              //learn_key_cnt = 0;
1139   4      
1140   4                                              if(Main_disp_other == 0)
1141   4                                              {
1142   5                                          PasswordBuff[0] = '0';
1143   5                                          PasswordBuff[1] = '0';
1144   5                                          PasswordBuff[2] = '0';
1145   5                                          PasswordBuff[3] = '0';  
1146   5                                          PasswordBuff[4] = '0';  
1147   5                                          DisplayBitNum = 4;
1148   5      
1149   5                                                      LEDShowFlashString(&PasswordBuff[0],0);
1150   5                                          DisplayState = ST_PASSWORD;
1151   5      
1152   5                                                      return;
1153   5                                              }
1154   4                                              else
1155   4                                              {
1156   5                                                      if (qz_wait == 1)
1157   5                                                      {
1158   6                                                              qz_wait = 0;   // 清等待状态
1159   6      
1160   6                                                              war_bell_step = 0;  // 清除蜂鸣器响声
1161   6                                                              cPauseBell = 0;                                                 
1162   6                                                      }
1163   5                                                      
1164   5                                                      Main_disp_other = 0;
1165   5                                              }
1166   4                                                                                      
1167   4                                              
1168   4                                  break;      
C51 COMPILER V9.00   LED_DISPLAY                                                           05/16/2016 14:48:04 PAGE 20  

1169   4                                              
1170   4                              case KEY_REDUCE:         //减号
1171   4                              
1172   4                                              test_key_cnt = 0;
1173   4                                              //learn_key_cnt = 0;
1174   4                                              
1175   4                                              if (long_input_flag && (Main_disp_other == 0))
1176   4                                              {
1177   5                                                      if(public_val.work_count_user != public_val.work_count)
1178   5                                                              {
1179   6                                                                      public_val.work_count_user = public_val.work_count;
1180   6                                                                      write_clear_cnt_flag = 1;    /* 发送命令至主板清除开机后计数 */
1181   6                                                                      save_user_count();
1182   6                                                              }
1183   5                                              }                                       
1184   4      
1185   4                                              if (speed_mode == 1)  //高速
1186   4                                              {
1187   5                                                      write_speed_mode_flag = 1;  
1188   5                                                      speed_mode = 0;   //切到低速
1189   5                                              }
1190   4                                      
1191   4                                              break;  
1192   4                                              
1193   4                              case KEY_INCREASE:       //加号
1194   4      
1195   4                                              test_key_cnt = 0;
1196   4                                              
1197   4                                              Main_adj_key_delay = public_val.ms_timer;                                       
1198   4                                              Main_disp_other = 5;
1199   4                                              if (speed_mode == 0)  //低速
1200   4                                              {
1201   5                                                      write_speed_mode_flag = 1;  
1202   5                                                      speed_mode = 1;  //切到高速
1203   5                                              }
1204   4      #if 0
                                                      if (Main_disp_other == 0)
                                                      {
                                                              /* 进入参数菜单 */
                                                          pMenu = pItem[0].m_pcfg;    // 指向数据                             
                                                              now_menu.menu_id = 0;
                                                              now_menu.par_id = 0;
                                                              now_menu.event_flag = 1;
                                              DisplayItemNum  = 0;
              
                                                              //DisplayMenuTotal = Menu_Number[0];
                                                              DisplayMenuTotal = Menu0_Number;
                                                              if(DisplayMenuTotal > 0)
                                                      DisplayState=ST_MENU;                                                           //进入相应菜单  
                                          return;
                                                      }
              #endif                                          
1221   4                                                                                      
1222   4                                              break;  
1223   4      
1224   4                              case KEY_GREEN:          //纸长
1225   4      
1226   4                                              test_key_cnt = 0;
1227   4                                              
1228   4                                              if (Main_disp_other == 0)
1229   4                                              {
1230   5                                                      /* 进入参数菜单 */
C51 COMPILER V9.00   LED_DISPLAY                                                           05/16/2016 14:48:04 PAGE 21  

1231   5                                                  pMenu = pItem[0].m_pcfg;    // 指向数据     
1232   5                                                      now_menu.menu_id = 0;
1233   5                                                      now_menu.par_id = 0;
1234   5                                                      now_menu.event_flag = 1;
1235   5                                      DisplayItemNum  = 0;
1236   5                                                      zc_key_flag = 1;
1237   5                                                      //DisplayMenuTotal = Menu_Number[0];
1238   5                                                  edit_menu_id = 0;
1239   5                                                      DisplayMenuTotal = pItem[edit_menu_id].MenuItem_Max;;
1240   5                                                      if(DisplayMenuTotal > 0)
1241   5                                              DisplayState=ST_MENU;                                                           //进入相应菜单                                                  
1242   5                                  return;
1243   5                                              }
1244   4                                                                                      
1245   4                                              break;  
1246   4      
1247   4                              case KEY_BLUE:           //捆数
1248   4      
1249   4                                              test_key_cnt = 0;
1250   4                                              
1251   4                                              if (Main_disp_other == 0)
1252   4                                              {
1253   5                                                      /* 进入参数菜单 */
1254   5                                                  pMenu = pItem[0].m_pcfg;    // 指向数据                             
1255   5                                                      now_menu.menu_id = 0;
1256   5                                                      now_menu.par_id = 1;
1257   5                                                      now_menu.event_flag = 1;
1258   5                                      DisplayItemNum  = 1;                    
1259   5                                                      zc_key_flag = 1;
1260   5                                                      //DisplayMenuTotal = Menu_Number[0];
1261   5                                                  edit_menu_id = 0;
1262   5                                                      DisplayMenuTotal = pItem[edit_menu_id].MenuItem_Max;;
1263   5                                                      if(DisplayMenuTotal > 0)
1264   5                                              DisplayState=ST_MENU;                                                           //进入相应菜单  
1265   5                                                      
1266   5                                  return;
1267   5                                              }
1268   4                                                                                      
1269   4                                              break;  
1270   4      
1271   4                                              
1272   4                              case KEY_ENT:   //查看程序版本
1273   4      
1274   4                                              if (qz_wait == 0)  //不是切纸等待状态
1275   4                                              {
1276   5                                                      //learn_key_cnt = 0;
1277   5      
1278   5                                                      if (long_input_flag)
1279   5                                                      {                                               
1280   6                                                              if (test_key_cnt < TEST_MODE_CNT)
1281   6                                                              {
1282   7                                                                      test_key_cnt++;
1283   7                                                              }
1284   6                                                      }
1285   5                                                      else
1286   5                                                      {
1287   6                                                              test_key_cnt = 0;
1288   6                                                      }
1289   5                                                      
1290   5                                                      Main_adj_key_delay = public_val.ms_timer;
1291   5                                                      Main_disp_other = 2;
1292   5                                              } 
C51 COMPILER V9.00   LED_DISPLAY                                                           05/16/2016 14:48:04 PAGE 22  

1293   4                                              else   // 切纸等待状态
1294   4                                              {
1295   5                                                      write_key_flag = 1;   /* 有按键，需要写按键到主板 */
1296   5      
1297   5                                                      // 下发切纸命令
1298   5                                                      gsKeyVal = KEY_IO3;
1299   5                                                      gcKeyType = KEY_SHORT_UP_FLAG; 
1300   5                                                      
1301   5                                                      Main_disp_other = 0;  // 返回显示筒数
1302   5                                                      qz_wait = 0;   // 清等待状态
1303   5      
1304   5                                                      war_bell_step = 0;  // 清除蜂鸣器响声
1305   5                                                      cPauseBell = 0;
1306   5                                                      
1307   5                                              }
1308   4                                              //add by yq;
1309   4                                              
1310   4                                              
1311   4                                              break;          
1312   4      
1313   4                                      case KEY_IO3:   // 切纸
1314   4      
1315   4                                              if (qz_wait == 0)  //未等待切纸
1316   4                                              {
1317   5                                                      write_warning_flag = 1;   // 下发报警消息
1318   5                                                      
1319   5                                                      //进入切纸等待
1320   5                                                      Main_disp_other = 4;
1321   5                                                      qz_wait = 1;                                            
1322   5                                              }
1323   4                                              
1324   4                                              break;
1325   4                                              
1326   4                          }
1327   3              
1328   3                              if(Main_disp_other == 0)  /* 返回主界面 */
1329   3                              {
1330   4                                      TempCount = main_menu_cfg[0].m_rate;  
1331   4                                      TempDataB = DisplayItemNum;
1332   4                              
1333   4                                      if(!public_val.Err_Flag)                                //无报错
1334   4                                      {
1335   5                                              if(!public_val.Work_Pause_Flag)     /* 无暂停，刷新显示当前已洗饼数 */
1336   5                                              {
1337   6                                                      if(public_val.Bell_Flag == YES)   /* 蜂鸣器长暂停响 added for v19416 */
1338   6                                                      {
1339   7                                                              cPauseBell = 1;
1340   7                                                              if(!war_bell_step) war_bell_step = 1;
1341   7                                                      }
1342   6                                                      else
1343   6                                                      {
1344   7                                                              Bell_flag &= 0xfd;
1345   7                                                      }
1346   6                                                      public_val.main_disp_val = public_val.work_count - public_val.work_count_user;
1347   6                                                      DisplayValueTemp = (long)public_val.main_disp_val; 
1348   6                                                      TempValue=DataToStr(&DisplayValueTemp,
1349   6                                                                          INT32_SIZE,
1350   6                                                                                              5,
1351   6                                                                                              0,
1352   6                                                                                              DisplayBuff,0,TY_D );           
1353   6                                                      LED_ShowNumber(&DisplayBuff[0],0);
1354   6                                                      
C51 COMPILER V9.00   LED_DISPLAY                                                           05/16/2016 14:48:04 PAGE 23  

1355   6                                                      //Bell_flag &= 0xfd;   
1356   6      
1357   6                                                      
1358   6                                              }
1359   5                                              else
1360   5                                              {
1361   6                                                      LEDShowFlashString("P--",0);                                            //显示项目名称内容
1362   6                                                      DisplayValueTemp = public_val.Work_Pause_Flag & 0x7F;
1363   6                                                      if(public_val.Work_Pause_Flag & 0x80)
1364   6                                                              {
1365   7                                                                      if(!war_bell_step) war_bell_step = 1;
1366   7                                                              }
1367   6                                                      TempValue=DataToStr(&DisplayValueTemp,
1368   6                                                                          INT32_SIZE,
1369   6                                                                                              5,
1370   6                                                                                              0,
1371   6                                                                                              DisplayBuff,0,TY_D );           
1372   6                                                      LED_ShowNumber(&DisplayBuff[3],3);      
1373   6      
1374   6                                                      cPauseBell = 1;
1375   6      
1376   6                                              }
1377   5                                      }
1378   4                                      else
1379   4                                      {
1380   5                              
1381   5                                              if ((public_val.Err_Flag == P_FINISH_LEARN1)
1382   5                                                      || (public_val.Err_Flag == P_FINISH_LEARN2)) 
1383   5                                              {
1384   6                                                      //学习完成也显示送纸计数
1385   6                                                      if(public_val.Bell_Flag == YES)   /* 蜂鸣器长暂停响 added for v19416 */
1386   6                                                      {
1387   7                                                              cPauseBell = 1;
1388   7                                                              if(!war_bell_step) war_bell_step = 1;
1389   7                                                      }
1390   6                                                      else
1391   6                                                      {
1392   7                                                              Bell_flag &= 0xfd;
1393   7                                                      }
1394   6                                                      
1395   6                                                      DisplayValueTemp = (long)public_val.main_disp_val; 
1396   6                                                      TempValue=DataToStr(&DisplayValueTemp,
1397   6                                                                          INT32_SIZE,
1398   6                                                                                              5,
1399   6                                                                                              0,
1400   6                                                                                              DisplayBuff,0,TY_D );           
1401   6                                                      LED_ShowNumber(&DisplayBuff[0],0);
1402   6      
1403   6                                                      
1404   6                                              }
1405   5                                              else             // 正常报错                    
1406   5                                              {
1407   6                                                      LEDShowFlashString("E--",0);            /* modified by james at 2014-4-12 */
1408   6                                                      
1409   6                                                      if(!war_bell_step) 
1410   6                                                              war_bell_step = 1;
1411   6                                                      
1412   6                                                      DisplayValueTemp = public_val.Err_Flag;
1413   6                                                      TempValue=DataToStr(&DisplayValueTemp,
1414   6                                                                          INT32_SIZE,
1415   6                                                                                              5,
1416   6                                                                                              0,
C51 COMPILER V9.00   LED_DISPLAY                                                           05/16/2016 14:48:04 PAGE 24  

1417   6                                                                                              DisplayBuff,0,TY_D );           
1418   6                                                      LED_ShowNumber(&DisplayBuff[3],3);              
1419   6      
1420   6                                                      cPauseBell = 0;
1421   6                                              }
1422   5                                      }
1423   4      
1424   4                                      if(l_stop_poll)                                                                                         //循环显示
1425   4                                      if(++CycShowCount > main_menu_cfg[0].m_time)                            //---------------周期计数器判断     
1426   4                                      {
1427   5                                          CycShowCount=0;
1428   5                                              DisplayItemNum++;
1429   5                                              TempCount = 0; 
1430   5                                      }
1431   4                              }
1432   3                              else if(Main_disp_other == 2)    /* 显示版本号 */
1433   3                              {
1434   4                                      DisplayValueTemp = public_val.version;
1435   4                                      //DisplayValueTemp = public_val.input_pass_mask;
1436   4                                      TempValue=DataToStr(&DisplayValueTemp,
1437   4                                                          INT32_SIZE,
1438   4                                                                              5,
1439   4                                                                              0,
1440   4                                                                              DisplayBuff,0,TY_D );           
1441   4                                      LED_ShowNumber(&DisplayBuff[0],0);      
1442   4                                      if( (public_val.ms_timer - Main_adj_key_delay) > MAIN_ADJ_DELAY)
1443   4                                      {
1444   5                                              Main_disp_other = 3;
1445   5                                      }
1446   4                              }
1447   3                              else if(Main_disp_other == 3)    /* 显示传感器等输入IO值 */
1448   3                              {
1449   4                                      DisplayValueTemp = (long)public_val.io_read;
1450   4                                      //DisplayValueTemp &= 0xff;
1451   4                                      DisplayValueTemp &= 0xffff;
1452   4                                      TempValue=DataToStr(&DisplayValueTemp,
1453   4                                                          INT32_SIZE,
1454   4                                                                              5,
1455   4                                                                              0,
1456   4                                                                              DisplayBuff,0,TY_D );           
1457   4                                      LED_ShowNumber(&DisplayBuff[0],0);      
1458   4                              }
1459   3                              else if (Main_disp_other == 4)    /* 切纸等待 */
1460   3                              {
1461   4                                      LEDShowFlashString("Q2---",0);
1462   4      
1463   4                                      if(!war_bell_step) 
1464   4                                              war_bell_step = 1;                                              
1465   4      
1466   4                                      cPauseBell = 1;         
1467   4                              }
1468   3                              else if(Main_disp_other == 5)    /* 显示传感器等输入IO值 */
1469   3                              {
1470   4                                      DisplayValueTemp = (long)public_val.password_index_disp;
1471   4                                      //DisplayValueTemp = (long)(public_val.password_val[0] << 8) + public_val.password_val[1];
1472   4                                      //DisplayValueTemp &= 0xff;
1473   4                                      DisplayValueTemp &= 0xffff;
1474   4                                      TempValue=DataToStr(&DisplayValueTemp,
1475   4                                                          INT32_SIZE,
1476   4                                                                              5,
1477   4                                                                              0,
1478   4                                                                              DisplayBuff,0,TY_D );           
C51 COMPILER V9.00   LED_DISPLAY                                                           05/16/2016 14:48:04 PAGE 25  

1479   4                                      LED_ShowNumber(&DisplayBuff[0],0);      
1480   4                              }
1481   3                  }
1482   2      
1483   2                      if (test_key_cnt == TEST_MODE_CNT)  /* 长按计数后进入测试参数设置界面 added by james for v19407 */
1484   2                      {
1485   3                              test_key_cnt = 0;
1486   3                              DisplayState = ST_TEST;
1487   3                              Main_disp_other = 4;
1488   3                              
1489   3                              test_set_display(test_mode);
1490   3                      }               
1491   2      
1492   2              #if 0
                              if (learn_key_cnt == LEARN_MODE_CNT)  /* 长按计数后进入测试参数设置界面 added by james for v19407 */
                              {
                                      learn_key_cnt = 0;
                                      DisplayState = ST_LEARN;
                                      Main_disp_other = 0;    
                                      
                                      LEDShowFlashString("P-- 0",0);
              
                                      public_val.Err_Flag = 0;   
              
                                      write_learn_mode_flag = 1;  
                              }       
                      #endif
1506   2                      
1507   2                  break;
1508   2      
1509   2      
1510   2                      case ST_PASSWORD://---------------------------------------------密码输入界面
1511   2      
1512   2                      switch(Key_Val)
1513   2                          {
1514   3                              case KEY_SEL:
1515   3                                  DisplayItemNum = 0;                 
1516   3                                              //DisplayItemNum0 = 0;
1517   3                                              //DisplayItemNum1 = 0;
1518   3                                  DisplayState = ST_MAIN;
1519   3                                  return;  
1520   3                                  break;      
1521   3                              case KEY_REDUCE:
1522   3                                      if(--DisplayBitNum < 0)
1523   3                                          DisplayBitNum=4;            
1524   3                                  break;      
1525   3                              case KEY_INCREASE:
1526   3                                      if( ++PasswordBuff[DisplayBitNum] > '9')
1527   3                                          PasswordBuff[DisplayBitNum]='0';                    
1528   3                                  break;      
1529   3                              case KEY_ENT:
1530   3                                  for(TempCountB=1;TempCountB<MenuTotals;TempCountB++)
1531   3                                  {
1532   4                                      if(PasswordBuff[0]==pItem[TempCountB].m_pass[0])//
1533   4                                      if(PasswordBuff[1]==pItem[TempCountB].m_pass[1])//
1534   4                                      if(PasswordBuff[2]==pItem[TempCountB].m_pass[2])//
1535   4                                      if(PasswordBuff[3]==pItem[TempCountB].m_pass[3])//
1536   4                                      if(PasswordBuff[4]==pItem[TempCountB].m_pass[4])//密码符合要求
1537   4                                      {
1538   5                                              if(TempCountB == MENU_ID_10104)
1539   5                                                      {
1540   6                                                              if(  ((public_val.Disp_Dz_10103[10] == 0)     //密码6为空或者校验成功，允许进入10104
C51 COMPILER V9.00   LED_DISPLAY                                                           05/16/2016 14:48:04 PAGE 26  

1541   6                                                                                      &&(public_val.Disp_Dz_10103[11] == 0))
1542   6                                                                                      ||(public_val.input_pass_mask & 0x20)
1543   6                                                                                      ||(public_val.Disp_Dz_10104[PASS_LOCK_COUNT - 1] == 0)
1544   6                                                                                 )
1545   6                                                                      {
1546   7                                                                              ;
1547   7                                                                      }
1548   6                                                                              else
1549   6                                                                                      return;
1550   6                                                      }
1551   5                                                              edit_menu_id = TempCountB; 
1552   5                                                          pMenu = pItem[TempCountB].m_pcfg;                                   
1553   5                                                              now_menu.menu_id = edit_menu_id;
1554   5                                                              now_menu.par_id = 0;
1555   5                                                              now_menu.event_flag = 1;
1556   5                                          DisplayItemNum  = 0;                                        
1557   5                                                              DisplayMenuTotal = pItem[edit_menu_id].MenuItem_Max;
1558   5                                                              if(DisplayMenuTotal > 0)
1559   5                                              DisplayState=ST_MENU;                                                           //进入相应菜单
1560   5                                                              //add by yq
1561   5                                                              if(DisplayMenuTotal > 20)
1562   5                                                                      DisplayMenuTotal = 20;
1563   5                                                              cMenuSn = 10;
1564   5                                          return;
1565   5                                      }                
1566   4                                  }
1567   3                                              return;
1568   3                                  break;      
1569   3                          }
1570   2                      if( flash_flag  && !long_input_flag  )                                                                                          //闪烁功能
1571   2                      {       
1572   3                          LEDClearChar(DisplayBitNum, 1);
1573   3                      }
1574   2                      else
1575   2                      {
1576   3                          LEDShowFlashString(&PasswordBuff[0], 0);            
1577   3                      }               
1578   2                  
1579   2                              break;
1580   2      
1581   2                      case ST_LEARN:
1582   2      
1583   2                              switch(Key_Val) 
1584   2                          {
1585   3                              case KEY_SEL:  // 选择键返回
1586   3                                      Main_disp_other = 0;
1587   3                                              DisplayBitNum = 4;
1588   3                                              CycShowCount  = 0;
1589   3                                              now_menu.menu_id = 888;
1590   3                                              now_menu.event_flag = 1;
1591   3                                  DisplayItemNum = 0; 
1592   3                                  DisplayState   = ST_MAIN;                                                                                   //返回主界面
1593   3                                  
1594   3                                              war_bell_step = 0;  // 清除蜂鸣器响声
1595   3                                              cPauseBell = 0;
1596   3      
1597   3                                              return;
1598   3                                              
1599   3                                              break;  
1600   3                                              
1601   3                                      default:
1602   3                                              break;
C51 COMPILER V9.00   LED_DISPLAY                                                           05/16/2016 14:48:04 PAGE 27  

1603   3                              }
1604   2      
1605   2                              if ((public_val.Err_Flag == P_FINISH_LEARN1)
1606   2                                      || (public_val.Err_Flag == P_FINISH_LEARN2))
1607   2                              {
1608   3                                      if (public_val.Err_Flag == P_FINISH_LEARN1)    // 学习完成
1609   3                                      {
1610   4                                              LEDShowFlashString("P-- 1",0);
1611   4      
1612   4                                              if(!war_bell_step) 
1613   4                                                      war_bell_step = 1;                                              
1614   4      
1615   4                                              cPauseBell = 1;                                         
1616   4                                      }
1617   3                                      else if (public_val.Err_Flag == P_FINISH_LEARN2)    // 学习完成
1618   3                                      {
1619   4                                              LEDShowFlashString("P-- 2",0);
1620   4      
1621   4                                              if(!war_bell_step) 
1622   4                                                      war_bell_step = 1;                                              
1623   4      
1624   4                                              cPauseBell = 1;                                         
1625   4                                      }
1626   3                              }       
1627   2                              else
1628   2                              {
1629   3                                      LEDShowFlashString("P-- 0",0);
1630   3                                      war_bell_step = 0;
1631   3                                      cPauseBell = 0; 
1632   3                              }
1633   2      
1634   2                              break;
1635   2      
1636   2                      case ST_TEST:        /* 测试参数设置界面响应 added by james for v19407 */
1637   2                              switch(Key_Val)
1638   2                          {
1639   3                              case KEY_SEL:
1640   3                                      Main_disp_other = 0;
1641   3                                              DisplayBitNum = 4;
1642   3                                              CycShowCount  = 0;
1643   3                                              now_menu.menu_id = 888;
1644   3                                              now_menu.event_flag = 1;
1645   3                                  DisplayItemNum = 0; 
1646   3                                  DisplayState   = ST_MAIN;                                                                                   //返回主界面
1647   3                                  break;      
1648   3      
1649   3                                      case KEY_INCREASE:
1650   3                                              if (test_mode < 1)
1651   3                                              {
1652   4                                                      test_mode++;
1653   4      
1654   4                                                      write_test_mode_flag = 1;  /* 写测试模式到主板 */
1655   4                                              }
1656   3                                              test_set_display(test_mode);
1657   3                                              
1658   3                                              if (test_mode > 0)  /* 测试模式 */
1659   3                                              {
1660   4                                                      //ResetDoorForTest();
1661   4                                              }                                       
1662   3                                              break;
1663   3      
1664   3                                      case KEY_REDUCE:
C51 COMPILER V9.00   LED_DISPLAY                                                           05/16/2016 14:48:04 PAGE 28  

1665   3                                              if (test_mode > 0)
1666   3                                              {
1667   4                                                      test_mode--;
1668   4      
1669   4                                                      write_test_mode_flag = 1;  /* 写测试模式到主板 */                                               
1670   4                                              }
1671   3                                              test_set_display(test_mode);                                    
1672   3                                              break;
1673   3      
1674   3                                      case KEY_IO7:  // 启动
1675   3                                              LEDShowFlashString("   11",0);
1676   3                                              break;
1677   3      
1678   3                                      case KEY_IO8:  // 停止
1679   3                                              LEDShowFlashString("   12",0);
1680   3                                              break;
1681   3      
1682   3                                      case KEY_RED:  // 收纸
1683   3                                              LEDShowFlashString("   13",0);
1684   3                                              break;
1685   3      
1686   3                                      case KEY_IO9:  // 发纸
1687   3                                              LEDShowFlashString("   14",0);
1688   3                                              break;
1689   3      
1690   3                                      case KEY_IO2:  // 退纸
1691   3                                              LEDShowFlashString("   15",0);
1692   3                                              break;
1693   3      
1694   3                                      case KEY_IO1:  // 进纸
1695   3                                              LEDShowFlashString("   16",0);
1696   3                                              break;
1697   3      
1698   3                                      case KEY_IO4:  // 下料
1699   3                                              LEDShowFlashString("   17",0);
1700   3                                              break;
1701   3      
1702   3                                      case KEY_IO5:  // 搓条
1703   3                                              LEDShowFlashString("   18",0);
1704   3                                              break;
1705   3      
1706   3                                      case KEY_IO6:  // 停止送纸
1707   3                                              LEDShowFlashString("   19",0);
1708   3                                              break;
1709   3      
1710   3                                      case KEY_IO3:  // 切纸
1711   3                                              LEDShowFlashString("   20",0);
1712   3                                              break;
1713   3                                              
1714   3                                      case KEY_GREEN:  // 纸长
1715   3                                              LEDShowFlashString("   21",0);
1716   3                                              break;
1717   3      
1718   3                                      case KEY_BLUE:  // 捆数
1719   3                                              LEDShowFlashString("   22",0);
1720   3                                              break;
1721   3                                              
1722   3                                      default:
1723   3                                              break;
1724   3                              }
1725   2      
1726   2      
C51 COMPILER V9.00   LED_DISPLAY                                                           05/16/2016 14:48:04 PAGE 29  

1727   2                      break;
1728   2      
1729   2                  case ST_MENU:                       /* 菜单数据查看 */
1730   2                  { 
1731   3                      switch(Key_Val)
1732   3                          {
1733   4                              case KEY_SEL:
1734   4                                      Main_disp_other = 0;
1735   4                                              DisplayBitNum = 4;
1736   4                                              CycShowCount  = 0;
1737   4                                              now_menu.menu_id = 888;
1738   4                                              now_menu.event_flag = 1;
1739   4                                  DisplayItemNum = 0; 
1740   4                                  DisplayState   = ST_MAIN;                                                                                   //返回主界面
1741   4                                              //DIS_OPTIONING=0;
1742   4                                  break;      
1743   4                              case KEY_REDUCE:
1744   4                                  if (DisplayItemNum-- == 0)
1745   4                                      DisplayItemNum = DisplayMenuTotal-1;    
1746   4                                              now_menu.par_id = DisplayItemNum;
1747   4                                              
1748   4                                              now_menu.par_id = DisplayItemNum;
1749   4                                              now_menu.event_flag = 1;
1750   4                                              //add by yq
1751   4                                              if (cMenuSn-- <= 10)
1752   4                                                      cMenuSn = 29;
1753   4                                  break;      
1754   4                              case KEY_INCREASE:
1755   4      
1756   4                                  if (++DisplayItemNum >= DisplayMenuTotal) 
1757   4                                      DisplayItemNum = 0;     
1758   4      
1759   4                                              now_menu.par_id = DisplayItemNum;
1760   4                                              now_menu.event_flag = 1;
1761   4                                              //add by yq
1762   4                                              if (cMenuSn++ >= 29)
1763   4                                                      cMenuSn = 10;
1764   4                                  break;      
1765   4                              case KEY_ENT:   
1766   4                                              if(
1767   4                                                      (now_menu.menu_id == MENU_ID_10104)  //设定数校验是否有权限修改
1768   4                                                      )
1769   4                                                      {
1770   5                                                              if(public_val.input_pass_mask & (1<<DisplayItemNum))
1771   5                                                                      {
1772   6                                                                              zc_key_flag = 5;
1773   6                                                                      }
1774   5                                                      }
1775   4                                              else if(now_menu.menu_id == MENU_ID_10103)
1776   4                                                      {
1777   5                                                              if(public_val.input_pass_mask & (1<<(DisplayItemNum>>1)))
1778   5                                                                      {
1779   6                                                                              zc_key_flag = 5;
1780   6                                                                      }
1781   5                                                      }
1782   4                                              else
1783   4                                                      {
1784   5                                                              zc_key_flag = 5;
1785   5                                                      }
1786   4                                  break;                      
1787   4                          }        
1788   3      
C51 COMPILER V9.00   LED_DISPLAY                                                           05/16/2016 14:48:04 PAGE 30  

1789   3                              //纸长按键特殊处理
1790   3                              //////////////////////////////////////////////////////////////////////////////////////
1791   3                              if (now_menu.menu_id == 0 && zc_key_flag)
1792   3                                      {
1793   4                                              zc_key_flag ++;
1794   4                                      }
1795   3      
1796   3                              if(zc_key_flag == 5)
1797   3                                      {
1798   4                                              zc_key_flag = 0;
1799   4                                          TempDataB = DisplayItemNum;
1800   4                                              if (TY_D == TY_B  || 
1801   4                                                      TY_D == TY_D  ||  
1802   4                                                      TY_D == TY_H)                                                                   //数值类
1803   4                                              {
1804   5                                                      DisplayBitNum = 4;
1805   5                                                      DataType=TY_D;
1806   5      
1807   5                                                      //锁机相关操作特殊处理
1808   5                                                      if( (now_menu.menu_id == MENU_ID_10103)                 //未解锁不显示密码
1809   5                                                          && (!(public_val.input_pass_mask & (1<<(DisplayItemNum>>1)))) //锁定状态下锁机参数全部显示为0
1810   5                                                              )
1811   5                                                              TempInputData = 0;
1812   5                                                  else
1813   5                                                      TempInputData = *(int *)pDataValue->m_data_vale;                        
1814   5      
1815   5                                                      DisplayState=ST_DATA_INPUT;                                                                             //进入参数输入界面
1816   5      
1817   5                                                      pDataValue=&pMenu[TempDataB];
1818   5                                                      DataType=TY_D;
1819   5                                                      TempValue=DataToStr(pDataValue->m_data_vale,
1820   5                                                                      INT16_SIZE,
1821   5                                                                                          DEFAUT_POSE,
1822   5                                                                                          DEFAUT_POT,
1823   5                                                                                          DisplayBuff,0,DataType);                            
1824   5                                                      
1825   5                                                      InputDataLen = DEFAUT_POSE+DEFAUT_POT;
1826   5                                                      //DisplayBitNum = InputDataLen - 1; 
1827   5                                                      PasswordBuff[0] = '0';
1828   5                                                      PasswordBuff[1] = '0';
1829   5                                                      switch(InputDataLen)
1830   5                                                      {       /*用于复制显示缓冲区数据*/                                  
1831   6                                                      case 3:
1832   6                                                              PasswordBuff[2]=DisplayBuff[TempValue];
1833   6                                                              if(PasswordBuff[2] == ' ') PasswordBuff[2] = '0';
1834   6                                                              PasswordBuff[3]=DisplayBuff[TempValue+1];
1835   6                                                              if(PasswordBuff[3] == ' ') PasswordBuff[3] = '0';
1836   6                                                              PasswordBuff[4]=DisplayBuff[TempValue+2];                               
1837   6                                                          break;                      
1838   6                                                      case 2:
1839   6                                                              PasswordBuff[2]=' ';
1840   6                                                              PasswordBuff[3]=DisplayBuff[TempValue+1];
1841   6                                                              if(PasswordBuff[3] == ' ') PasswordBuff[3] = '0';
1842   6                                                              PasswordBuff[4]=DisplayBuff[TempValue+2];                               
1843   6                                                          break;              
1844   6                                                      case 1:
1845   6                                                              PasswordBuff[2]=' ';
1846   6                                                              PasswordBuff[3]=' ';
1847   6                                                              PasswordBuff[4]=DisplayBuff[TempValue+2];
1848   6                                                              break;                          
1849   6                                                      }
1850   5                                                      pr_long_input_flag = 0;
C51 COMPILER V9.00   LED_DISPLAY                                                           05/16/2016 14:48:04 PAGE 31  

1851   5                                                      //pDataValue.m_max = 999;
1852   5                                                      //pDataValue.m_min = 0;
1853   5                                                      DisplayState=ST_DATA_INPUT;                                                                             //进入参数输入界面
1854   5                                              }       
1855   4                                      }
1856   3                              //////////////////////////////////////////////////////////////////////////////////////
1857   3                                      
1858   3                              if(TempCount > 0)           
1859   3                              {       
1860   4                                      TempCount-- ;
1861   4                                      break;          
1862   4                              }
1863   3                              TempCount = main_menu_cfg[0].m_rate;  
1864   3      
1865   3                          pDataValue=&pMenu[DisplayItemNum];  
1866   3      //密码校验成功，进入菜单显示内容，以及翻动参数显示内容
1867   3      #if MENU_PASS_ON
1868   3                              //锁机相关操作特殊处理
1869   3                              if( (now_menu.menu_id == MENU_ID_10103)                 //未解锁不显示密码
1870   3                                  && (!(public_val.input_pass_mask & (1<<(DisplayItemNum>>1)))) //锁定状态下锁机参数全部显示为0
1871   3                                      )
1872   3                                      TempInputData = 0;
1873   3                          else
1874   3      #endif                          
1875   3                              TempInputData = *(int *)pDataValue->m_data_vale;                        
1876   3      
1877   3                              LEDShowCaption(DisplayItemNum);
1878   3      
1879   3                              TempValue=DataToStr(&TempInputData,   //pDataValue->m_data_vale
1880   3                                                  INT32_SIZE,      //pDataValue->m_size,
1881   3                                                                      DEFAUT_POSE,
1882   3                                                                      DEFAUT_POT,
1883   3                                                                      DisplayBuff,0,TY_D );           
1884   3                              LED_ShowNumber(&DisplayBuff[TempValue],2);
1885   3                  }
1886   2                  break;
1887   2      
1888   2                  case ST_DATA_INPUT: /* 数据输入画面 */
1889   2                  {
1890   3                      switch(Key_Val)
1891   3                          {
1892   4                              case KEY_SEL:   
1893   4                                              if (now_menu.menu_id == 0)
1894   4                                                      {
1895   5                                                      Main_disp_other = 0;
1896   5                                                              DisplayBitNum = 4;
1897   5                                                              CycShowCount  = 0;
1898   5                                                              now_menu.menu_id = 888;
1899   5                                                              now_menu.event_flag = 1;
1900   5                                                  DisplayItemNum = 0; 
1901   5                                                  DisplayState   = ST_MAIN;                                                                                   //返回主界面
1902   5                                                      }
1903   4                                              else
1904   4                                              DisplayState = ST_MENU;
1905   4                                  break;      
1906   4                              case KEY_REDUCE: //减少
1907   4                                      if(pMenu[DisplayItemNum].ext_property & 0x01)
1908   4                                              {
1909   5                                                      ;
1910   5                                              }
1911   4                                      else
1912   4                                              {
C51 COMPILER V9.00   LED_DISPLAY                                                           05/16/2016 14:48:04 PAGE 32  

1913   5                                                              TempInputData-=long_key_step;
1914   5                                                              if(TempInputData<pDataValue->m_min) //
1915   5                                                                      TempInputData = pDataValue->m_min; //pDataValue->m_min;
1916   5                                                      }
1917   4                                  break;      
1918   4                              case KEY_INCREASE: //增加
1919   4                                      if(pMenu[DisplayItemNum].ext_property & 0x01)
1920   4                                              {
1921   5                                                              ;
1922   5                                              }
1923   4                                      else
1924   4                                              {
1925   5                                                              TempInputData+=long_key_step;
1926   5                                                              temp_max = pDataValue->m_max;
1927   5                                                              if(TempInputData>temp_max) // temp_max
1928   5                                                                      TempInputData=temp_max;
1929   5                                                      }
1930   4                                  break;      
1931   4                              case KEY_ENT:
1932   4                                      if(!long_input_flag)
1933   4                                      {                       
1934   5                                                      TempInputData=StrToData(PasswordBuff,5,DataType);
1935   5                                                      if(TempInputData <= pDataValue->m_max && TempInputData >= pDataValue->m_min)
1936   5                                                      {
1937   6                                                      switch(INT16_SIZE)
1938   6                                                          {
1939   7                                                          case INT32_SIZE:
1940   7                                                              *(long *)pDataValue->m_data_vale = TempInputData;
1941   7                                                              break;
1942   7                                                          case INT16_SIZE:
1943   7                                                              *(int *)pDataValue->m_data_vale = (int)TempInputData;
1944   7                                                              break;                  
1945   7                                                          case INT8_SIZE:
1946   7                                                              *(char *)pDataValue->m_data_vale = (char)TempInputData;
1947   7                                                              break;                  
1948   7                                                              }       
1949   6                                                              if(PasswordBuff[2] == '0')
1950   6                                                                      {
1951   7                                                                              PasswordBuff[2] = ' ';
1952   7                                                                              if(PasswordBuff[3] == '0') PasswordBuff[3] = ' ';
1953   7                                                                      }
1954   6                                                              LED_ShowNumber(&PasswordBuff[2],2);
1955   6      
1956   6      #if MENU_PASS_ON
1957   6                                                              //修改操作，校对密码是否与保存的一致
1958   6                                                              if( now_menu.menu_id == MENU_ID_10102)
1959   6                                                                      {
1960   7                                                                              TempB = DisplayItemNum / 2;
1961   7                                                                              //for(TempB = 0; TempB < PASS_LOCK_COUNT; TempB++)
1962   7                                                                                      {
1963   8                                                                                              if( (public_val.Disp_Dz_10103[TempB * 2] == public_val.Disp_Dz_10102[TempB * 2])
1964   8                                                                                                      && (public_val.Disp_Dz_10103[TempB * 2 + 1] == public_val.Disp_Dz_10102[TempB * 2 + 1]) 
1965   8                                                                                                      )
1966   8                                                                                                      {
1967   9                                                                                                              public_val.input_pass_mask |= 1 << TempB;
1968   9                                                                                                              public_val.Disp_Dz_10104[TempB] = 0;
1969   9                                                                                                              for(i = 0; i < TempB; i ++)                             //此段以下的都清除
1970   9                                                                                                                      public_val.Disp_Dz_10104[i] = 0;
1971   9                                                                                                              func_menu_update(MENU_ID_10104);
1972   9                                                                                                      }
1973   8                                                                                      }
1974   7                                                                              
C51 COMPILER V9.00   LED_DISPLAY                                                           05/16/2016 14:48:04 PAGE 33  

1975   7                                                                                      DisplayState = ST_MENU;;                                                                        
1976   7                                                                      }
1977   6                                                              else
1978   6      #endif
1979   6                                                                      func_menu_update(now_menu.menu_id);
1980   6                                                                              
1981   6      
1982   6                                                              /* 如果将倒数第2个参数改为1则全部恢复默认参数 added by james for v19407 */
1983   6                                                              /*if ((DisplayItemNum == PARM_DEFAULT)
1984   6                                                                      && (TempInputData == 1))
1985   6                                                              {
1986   6                                                                      for (i = 0; i < MENU_ID_00000_MAX_ITEM; i++)
1987   6                                                                      {
1988   6                                                                              public_val.menu_parm[i] = iDefaultParm[i];
1989   6                                                                      }
1990   6                                                              }*/
1991   6                                                              
1992   6                                                              
1993   6                                                      }
1994   5                                      }
1995   4      
1996   4                                              if (now_menu.menu_id == 0)
1997   4                                                      {
1998   5                                                      Main_disp_other = 0;
1999   5                                                              DisplayBitNum = 4;
2000   5                                                              CycShowCount  = 0;
2001   5                                                              now_menu.menu_id = 888;
2002   5                                                              now_menu.event_flag = 1;
2003   5                                                  DisplayItemNum = 0; 
2004   5                                                  DisplayState   = ST_MAIN;                                                                                   //返回主界面
2005   5                                                      }
2006   4                                              else
2007   4                                              DisplayState = ST_MENU;
2008   4                                              
2009   4                                  break;                      
2010   4                          }
2011   3      
2012   3                      if( flash_flag && !long_input_flag )  //闪烁功能
2013   3                      {       
2014   4                          LEDClearChar(DisplayBitNum,1);
2015   4                      }
2016   3                      else                    
2017   3                      {
2018   4                                              LEDShowCaption(DisplayItemNum);
2019   4                                      TempValue=DataToStr(&TempInputData,
2020   4                                                      INT32_SIZE,
2021   4                                                                      5,
2022   4                                                                      0,
2023   4                                                                      DisplayBuff,0,TY_D );   
2024   4      
2025   4                                      PasswordBuff[2]=DisplayBuff[TempValue];
2026   4                                      if(PasswordBuff[2] == ' ') PasswordBuff[2] = '0';
2027   4                                      PasswordBuff[3]=DisplayBuff[TempValue+1];
2028   4                                      if(PasswordBuff[3] == ' ') PasswordBuff[3] = '0';
2029   4                                      PasswordBuff[4]=DisplayBuff[TempValue+2];                                               
2030   4                                      LED_ShowNumber(&PasswordBuff[2],2);     
2031   4                                      
2032   4                      }
2033   3                  }   
2034   2                  break;      
2035   2                      
2036   2                      case ST_DISP_ERR:
C51 COMPILER V9.00   LED_DISPLAY                                                           05/16/2016 14:48:04 PAGE 34  

2037   2                      {
2038   3                              if(public_val.ms_timer - now_menu.err_dsip_delay > DISP_ERR_TIMER )
2039   3                              {
2040   4                                      DisplayState = now_menu.chang_next_step;
2041   4                              }
2042   3                              else
2043   3                              {
2044   4                                      LEDShowFlashString("  Err",0);
2045   4                              }
2046   3                      }
2047   2                      break;
2048   2                      
2049   2                      default :
2050   2                      DisplayState = ST_MAIN;
2051   2                              //DIS_OPTIONING=0;
2052   2                  break;                              
2053   2                      
2054   2              }
2055   1              
2056   1          if(LCDDisplayState != DisplayState )//各个界面静态显示
2057   1              {
2058   2                      xdata char* paperLen = "纸长";
2059   2                      xdata char* paperNum = "捆数";
2060   2                      xdata char* paperTatol = "总数";
2061   2                      
2062   2                      if(g_iErrStatus == 1)
2063   2                                      g_iErrUIChange =1;
2064   2                      
2065   2                      LCDDisplayState = DisplayState;
2066   2                      switch(LCDDisplayState)
2067   2                      {
2068   3                              case ST_MAIN:
2069   3                              if(public_val.Err_Flag == 0)
2070   3                              {
2071   4                                      ClearLCDScreen(0);
2072   4                                      //GpuSend("SPG(52);\r\n");      
2073   4                                      GpuSend("W8DF(5,3,'111662226633333');\r\n");
2074   4                                      DELAY_US(UART2_DELAY);
2075   4                                      GpuSend("W8MU(0,0,80,80,1,2);\r\n");
2076   4                                      DELAY_US(UART2_DELAY);
2077   4                                      GpuSend("W8UE(1);\r\n");//查看串口发送的数据是正确的，必须两条才能起作用。液晶屏BUG
2078   4                                      GpuSend("W8UE(1);\r\n");
2079   4                                      DELAY_US(UART2_DELAY);
2080   4                                      sprintf(lcd_disp_buf,"DS64(1,8,'%s',15);\r\n",paperLen);
2081   4                                      GpuSend(lcd_disp_buf);
2082   4                                      DELAY_US(UART2_DELAY);
2083   4                                      GpuSend("SXY(0,0)\r\n");
2084   4                                      GpuSend("W8UE(3);\r\n");
2085   4                                      DELAY_US(UART2_DELAY);
2086   4                                      sprintf(lcd_disp_buf,"DS64(1,8,'%s',15);\r\n",paperNum);
2087   4                                      GpuSend(lcd_disp_buf);
2088   4                                      GpuSend("SXY(0,0)\r\n");
2089   4                                      DELAY_US(UART2_DELAY);
2090   4                                      GpuSend("W8UE(4);\r\n");
2091   4                                      sprintf(lcd_disp_buf,"DS64(1,8,'%s',15);\r\n",paperTatol);
2092   4                                      GpuSend(lcd_disp_buf);
2093   4                                      GpuSend("SXY(0,0)\r\n");
2094   4                                      DELAY_US(UART2_DELAY);
2095   4                              }       
2096   3                                      break;
2097   3                              case ST_PASSWORD:
2098   3                                      //GpuSend("SPG(53);\r\n");
C51 COMPILER V9.00   LED_DISPLAY                                                           05/16/2016 14:48:04 PAGE 35  

2099   3      /*                              GpuSend("W8DF(5,3,'111662226633333');\r\n");
2100   3                                      DELAY_US(UART2_DELAY);
2101   3                                      GpuSend("W8MU(0,0,80,80,1,2);\r\n");
2102   3                                      DELAY_US(UART2_DELAY);
2103   3                                      GpuSend("SBC(51);\r\n");
2104   3                                      GpuSend("SBC(51);\r\n");
2105   3                                      DELAY_US(UART2_DELAY);
2106   3                                      GpuSend("DS64(1,7,'纸长',15);\r\n");
2107   3                                      DELAY_US(UART2_DELAY);
2108   3                                      GpuSend("SBC(52);\r\n");
2109   3                                      DELAY_US(UART2_DELAY);
2110   3                                      GpuSend("DS64(1,90,'捆数',15);\r\n");
2111   3                                      GpuSend("SBC(53);\r\n");
2112   3                                      GpuSend("DS64(1,170,'总数',15);\r\n");
2113   3                                      GpuSend("SBC(0);\r\n");
2114   3      */                              
2115   3                                      ClearLCDScreen(0);
2116   3                                      DELAY_US(UART2_DELAY);          
2117   3                                      GpuSend("DS48(1,86,'请输入密码:',15);\r\n");
2118   3                                      DELAY_US(UART2_DELAY);
2119   3                                      
2120   3                                      break;
2121   3                              case ST_MENU ://--参数查看画面
2122   3                                      ClearLCDScreen(0);
2123   3                                      if(now_menu.menu_id == 0 && now_menu.par_id ==0)//纸长
2124   3                                      {
2125   4                                              
2126   4                                              sprintf(lcd_disp_buf,"DS64(1,1,'%s',15);\r\n","1-");
2127   4                                              GpuSend(lcd_disp_buf);
2128   4                                              DELAY_US(UART2_DELAY);
2129   4                                              
2130   4                                              sprintf(lcd_disp_buf,"DS64(1,100,'%s',15);\r\n",paperLen);
2131   4                                              GpuSend(lcd_disp_buf);
2132   4                                      }
2133   3                                      else if(now_menu.menu_id == 0 && now_menu.par_id ==1)//捆数
2134   3                                      {
2135   4                                              sprintf(lcd_disp_buf,"DS64(1,1,'%s',15);\r\n","2-");
2136   4                                              GpuSend(lcd_disp_buf);
2137   4                              
2138   4                                              sprintf(lcd_disp_buf,"DS64(1,100,'%s',15);\r\n",paperNum);
2139   4                                              GpuSend(lcd_disp_buf);
2140   4                                      }
2141   3                                      else
2142   3                                      {
2143   4                                              GpuSend("CLS(0);\r\n");
2144   4                                              MenuEditLook(now_menu.par_id + 10);                             
2145   4                                              pLCDDataValue=&pMenu[now_menu.par_id];
2146   4                                              TempInputData = *(int *)pLCDDataValue->m_data_vale;
2147   4                                              iCount = TempInputData;
2148   4                                              //sprintf(cLcd_data_buf,"%d ,%d ,%d,%d",iCount,(int)DisplayMenuTotal,(int)now_menu.par_id,(int)Displa
             -yItemNum);
2149   4                                              sprintf(cLcd_data_buf,"%d",(int)TempInputData);
2150   4                                              sprintf(lcd_disp_buf,"DS48(30,190,'%s',1);\r\n",cLcd_data_buf);
2151   4                                              GpuSend(lcd_disp_buf);
2152   4                                              
2153   4                                      }
2154   3                                      
2155   3                                      break;
2156   3                              case ST_DATA_INPUT://--数据输入画面
2157   3                                      
2158   3                                      break;
2159   3                              case ST_CODE_INPUT://--代码输入画面
C51 COMPILER V9.00   LED_DISPLAY                                                           05/16/2016 14:48:04 PAGE 36  

2160   3                                      GpuSend("CLS(0);\r\n");
2161   3                                      DELAY_US(UART2_DELAY);
2162   3                                      sprintf(lcd_disp_buf,"DS64(200,100,'%s',15);\r\n","代码输入画面");
2163   3                                      GpuSend(lcd_disp_buf);
2164   3                                      DELAY_US(UART2_DELAY);
2165   3                                      break;
2166   3                              case ST_Show_Err://--错误提示画面
2167   3                                      GpuSend("CLS(0);\r\n");
2168   3                                      DELAY_US(UART2_DELAY);
2169   3                                      sprintf(lcd_disp_buf,"DS64(200,100,'%s',15);\r\n","错误提示");
2170   3                                      GpuSend(lcd_disp_buf);
2171   3                                      break;
2172   3                              case ST_ADJ://--直接调参数画面
2173   3                                      GpuSend("CLS(0);\r\n");
2174   3                                      DELAY_US(UART2_DELAY);
2175   3                                      sprintf(lcd_disp_buf,"DS64(200,100,'%s',15);\r\n","直接调参数");
2176   3                                      GpuSend(lcd_disp_buf);
2177   3                              
2178   3                                      break;
2179   3                              case ST_WAIT_VER://--等待返校结果
2180   3                                      GpuSend("CLS(0);\r\n");
2181   3                                      DELAY_US(UART2_DELAY);
2182   3                                      sprintf(lcd_disp_buf,"DS64(200,100,'%s',15);\r\n","等待返校结果");
2183   3                                      GpuSend(lcd_disp_buf);
2184   3                                      break;
2185   3                              case ST_DISP_ERR://延时显示修改出错
2186   3                                      GpuSend("CLS(0);\r\n");
2187   3                                      DELAY_US(UART2_DELAY);
2188   3                                      sprintf(lcd_disp_buf,"DS64(200,100,'%s',15);\r\n","延时显示修改出错");
2189   3                                      GpuSend(lcd_disp_buf);
2190   3                                      break;
2191   3                              case ST_TEST://--测试参数设置  added by james for v19407
2192   3                                      GpuSend("CLS(0);\r\n");
2193   3                                      DELAY_US(UART2_DELAY);
2194   3                                      sprintf(lcd_disp_buf,"DS64(200,100,'%s',15);\r\n","测试参数设置");
2195   3                                      GpuSend(lcd_disp_buf);
2196   3                                      break;
2197   3                              case ST_LEARN://--学习模式
2198   3                                      GpuSend("CLS(0);\r\n");
2199   3                                      DELAY_US(UART2_DELAY);
2200   3                                      sprintf(lcd_disp_buf,"DS64(200,100,'%s',15);\r\n","学习模式");
2201   3                                      GpuSend(lcd_disp_buf);
2202   3                                      break;
2203   3                              case 0:
2204   3                              
2205   3                              break;
2206   3                      }
2207   2              }
2208   1              
2209   1      
2210   1              
2211   1              switch(DisplayState)//数据更新以及显示
2212   1              {
2213   2                      case ST_MAIN:
2214   2                              switch(LCDChildDisplayState)
2215   2                              {
2216   3                                      case 0:
2217   3                                              if(public_val.ms_timer - g_iInterfaceChangOldTime  > 500 && g_iErrStatus == 0)
2218   3                                              //if(now_menu.menu_id == 0 && now_menu.par_id ==1)//纸长
2219   3                                              {
2220   4                                                      xdata char total[9] = {'0'};
2221   4                                                      xdata int numLen=0;
C51 COMPILER V9.00   LED_DISPLAY                                                           05/16/2016 14:48:04 PAGE 37  

2222   4                                                      g_iInterfaceChangOldTime = public_val.ms_timer;
2223   4                                                      pLCDDataValue=pItem[0].m_pcfg;
2224   4                                                      iLen = *(int *)pLCDDataValue->m_data_vale;
2225   4                                                      sprintf(cLcd_len_data_buf,"%d",iLen);
2226   4                                              
2227   4                                                      //else if(now_menu.menu_id == 0 && now_menu.par_id ==0)//捆数
2228   4                                                                                              
2229   4                                                      pLCDDataValue=pItem[0].m_pcfg + 1;
2230   4                                                      iCount= *(int *)pLCDDataValue->m_data_vale;
2231   4                                                      sprintf(cLcd_count_data_buf,"%d",iCount);
2232   4                                                      GpuSend("W8UE(1);\r\n");
2233   4                                                      sprintf(lcd_disp_buf,"DS64(142,8,'%s',15);\r\n",cLcd_len_data_buf);
2234   4                                                      GpuSend(lcd_disp_buf);
2235   4                                                      GpuSend("W8UE(3);\r\n");
2236   4                                                      sprintf(lcd_disp_buf,"DS64(142,8,'%s',15);\r\n",cLcd_count_data_buf);
2237   4                                                      GpuSend(lcd_disp_buf);
2238   4                                                      GpuSend("W8UE(4);\r\n");
2239   4                                                      sprintf(lcd_disp_buf,"%ld",public_val.main_disp_val);
2240   4                                                      numLen =strlen(lcd_disp_buf);
2241   4                                                      for(i =0;i< 9  ;i++)
2242   4                                                              total[i]='0';
2243   4                                                      for(i=0; ((i< numLen) && i< 8);i++)
2244   4                                                      {
2245   5                                                              
2246   5                                                              total[8 - numLen + i] = lcd_disp_buf[i];
2247   5                                                      }
2248   4      
2249   4                                                      total[8]='\0';
2250   4                                                      //sprintf(lcd_disp_buf,"DS64(138,8,'%7ld',15);\r\n",public_val.main_disp_val);
2251   4                                                      sprintf(lcd_disp_buf,"DS64(142,8,'%s',15);\r\n",total);
2252   4                                                      GpuSend(lcd_disp_buf);
2253   4                                                      GpuSend("SXY(0,0)\r\n");
2254   4                                              }
2255   3                                              if(g_pcStatus && g_iErrStatus == 0)
2256   3                                              {
2257   4                                                      
2258   4                                                      if(public_val.ms_timer -  g_iFlashOldTime> 500)
2259   4                                                      {
2260   5                                                              static xdata staFlashFlag=0;
2261   5                                                              g_iFlashOldTime = public_val.ms_timer;
2262   5                                                              GpuSend("W8UE(2);\r\n");
2263   5                                                              if(staFlashFlag)
2264   5                                                              {       
2265   6                                                                      sprintf(lcd_disp_buf,"DS48(20,60,'%s',15);\r\n",g_pcStatus);
2266   6                                                                      GpuSend(lcd_disp_buf);                  
2267   6                                                              }
2268   5                                                              else
2269   5                                                              {
2270   6                                                                      sprintf(lcd_disp_buf,"DS48(20,60,'%s',1);\r\n",g_pcStatus);
2271   6                                                                      GpuSend(lcd_disp_buf);
2272   6                                                              }
2273   5                                                              GpuSend("SXY(0);\r\n");
2274   5                                                              staFlashFlag = !staFlashFlag;
2275   5                                                      }
2276   4                                                      
2277   4                                                      
2278   4                                              }else if(g_pcStatus == 0 && g_iErrStatus == 0)
2279   3                                              {
2280   4                                                      if(public_val.ms_timer -  g_iFlashOldTime> 500)
2281   4                                                      {
2282   5                                                              GpuSend("W8UE(2);\r\n");
2283   5                                                              sprintf(lcd_disp_buf,"DS48(20,60,'    ',1);\r\n");
C51 COMPILER V9.00   LED_DISPLAY                                                           05/16/2016 14:48:04 PAGE 38  

2284   5                                                              GpuSend(lcd_disp_buf);
2285   5                                                              GpuSend("SXY(0);\r\n");
2286   5                                                      }
2287   4                                              }
2288   3                                              
2289   3                                              break;
2290   3                                      case 1:
2291   3      
2292   3                                              ClearLCDScreen(0);
2293   3                                              GpuSend("SPG(57);\r\n");
2294   3                                              DELAY_US(10000);
2295   3                                              GpuSend("W8UE(1);\r\n");
2296   3                                              sprintf(cLcd_count_data_buf,"%s","16-5-12");
2297   3                                              sprintf(lcd_disp_buf,"DS64(130,2,'%s',15);\r\n",cLcd_count_data_buf);
2298   3                                              GpuSend(lcd_disp_buf);
2299   3                                              GpuSend("W8UE(2);\r\n");
2300   3                                              sprintf(cLcd_count_data_buf,"%d",public_val.version);
2301   3                                              sprintf(lcd_disp_buf,"DS64(130,1,'%s',15);\r\n",cLcd_count_data_buf);
2302   3                                              GpuSend(lcd_disp_buf);
2303   3                                              GpuSend("W8UE(3);\r\n");
2304   3                                              sprintf(lcd_disp_buf,"DS64(130,1,'%ld',15);\r\n",public_val.main_disp_val);
2305   3                                              GpuSend(lcd_disp_buf);
2306   3                                              GpuSend("SXY(0,0)\r\n");
2307   3                                              g_iInterfaceChangOldTime = public_val.ms_timer;
2308   3                                              LCDChildDisplayState++;
2309   3                                              break;
2310   3                                      case 2:
2311   3                                              if(public_val.ms_timer - g_iInterfaceChangOldTime  > 2000)
2312   3                                              {
2313   4                                                      ClearLCDScreen(0);
2314   4                                                      GpuSend("SPG(60);\r\n");
2315   4                                                      DELAY_US(10000);
2316   4                                                      g_iInterfaceChangOldTime  = public_val.ms_timer;
2317   4                                                      LCDChildDisplayState++;                                         
2318   4                                              }
2319   3                                              break;
2320   3                                      case 3:
2321   3                                              {
2322   4                                                      if(public_val.ms_timer - g_iFlashOldTime > 200 )
2323   4                                                      {
2324   5                                                              g_iFlashOldTime = public_val.ms_timer;
2325   5                                                              IOCheck();
2326   5                                                      }
2327   4                                              }
2328   3                                              break;
2329   3                                      
2330   3                                      case 8://切纸询问界面
2331   3                                              if(public_val.ms_timer -  g_iFlashOldTime> 500)
2332   3                                              {
2333   4                                                      static xdata int icutFlashFlag =0;
2334   4                                                      g_iFlashOldTime = public_val.ms_timer;
2335   4                                                      ClearLCDScreen(0);
2336   4                                                      if(icutFlashFlag)
2337   4                                                      {
2338   5                                                              GpuSend("SPG(62);\r\n");
2339   5                                                      }
2340   4                                                      else
2341   4                                                      {
2342   5                                                              GpuSend("SPG(63);\r\n");
2343   5                                                      }
2344   4                                                      icutFlashFlag = !icutFlashFlag;
2345   4                                              }
C51 COMPILER V9.00   LED_DISPLAY                                                           05/16/2016 14:48:04 PAGE 39  

2346   3                                              
2347   3                                              switch(Key_Val)
2348   3                                              {
2349   4                                                      case 0xFFFF:
2350   4                                                      case 0x0000:
2351   4                                                              break;
2352   4                                                      case KEY_IO3://切纸                                                     
2353   4                                                              break;
2354   4                                                      case KEY_K4://确认
2355   4                                                      //清除显示
2356   4                                                              g_pcStatus = 0;
2357   4                                                              LCDChildDisplayState =0;
2358   4                                                              LCDDisplayState = 0x00;
2359   4                                                              break;
2360   4                                                      case KEY_K1://选择
2361   4                                                              //sprintf(lcd_disp_buf,"DS64(130,1,'%X',15);\r\n",Key_Val);
2362   4                                                              //GpuSend(lcd_disp_buf);
2363   4                                                              LCDChildDisplayState =0;
2364   4                                                              LCDDisplayState = 0x00;
2365   4                                                              break;
2366   4                                                      default:
2367   4                                                              break;
2368   4                                              }
2369   3                                              
2370   3                                              break;
2371   3                                      default:
2372   3                                              break;
2373   3                              }
2374   2                              
2375   2                              
2376   2                              break;
2377   2                      case ST_PASSWORD:
2378   2                              for(i=0 ;i < 5; i++)
2379   2                                      cLcd_data_buf[i] = PasswordBuff[i];
2380   2                              break;
2381   2                      case ST_MENU:
2382   2                              if(Key_Val == KEY_REDUCE || Key_Val == KEY_INCREASE)
2383   2                              {
2384   3                                      LCDDisplayState = 0x00;
2385   3                              }
2386   2                              break;
2387   2                              //now_menu.par_id
2388   2                      case ST_DATA_INPUT:
2389   2                              if(now_menu.menu_id == 0 && now_menu.par_id ==0)//纸长
2390   2                              {
2391   3                                      pLCDDataValue=&pMenu[0];
2392   3                                      iLen = *(int *)pLCDDataValue->m_data_vale;
2393   3                              //      sprintf(cLcd_data_buf,"%d",iLen);
2394   3                              }
2395   2                              else if(now_menu.menu_id == 0 && now_menu.par_id ==1)//捆数
2396   2                              {                                       
2397   3                                      pLCDDataValue=&pMenu[1];
2398   3                                      iCount= *(int *)pLCDDataValue->m_data_vale;
2399   3                              //      sprintf(cLcd_data_buf,"%d",iCount);
2400   3                              }
2401   2                              iCount = TempInputData;
2402   2                              sprintf(cLcd_data_buf,"%d",iCount);
2403   2                              break;
2404   2              }
2405   1              //错误标志 低4位:主控板错误号 高4位:操作板错误
2406   1              if(public_val.Err_Flag && DisplayState == ST_MAIN && LCDChildDisplayState == 0)
2407   1              {
C51 COMPILER V9.00   LED_DISPLAY                                                           05/16/2016 14:48:04 PAGE 40  

2408   2                      xdata int iErrPosX,iErrPosY,iPicNum;
2409   2                      if(g_iErrStatus == 0 || g_iErrUIChange == 1)//出现错误 或者 错误界面被更改
2410   2                      {
2411   3                              g_iErrStatus = 1;
2412   3                              g_iErrUIChange =0;
2413   3                              ClearLCDScreen(0);
2414   3                              switch(public_val.Err_Flag)
2415   3                              {
2416   4                                      case E1   ://完成设定筒数错误   本错误码只告警提示，不停机，为非故障报警。
2417   4                                              iErrPosX=320;
2418   4                                              iErrPosY=200;
2419   4                                              GpuSend("BPIC(1,0,0,1);\r\n");
2420   4                                              DELAY_US(5000);
2421   4                                              iPicNum =1;
2422   4                                              GpuSend("PS32(1,1,1,'完成一捆,请捆条',15);\r\n");                                       
2423   4                                              break;
2424   4                                      case E2   ://搓条机下料处无杆钎报错。
2425   4                                              iErrPosX=200;
2426   4                                              iErrPosY=80;
2427   4      
2428   4                                              GpuSend("BPIC(2,0,0,2);\r\n");
2429   4                                              DELAY_US(5000);
2430   4                                              iPicNum =2;
2431   4                                              GpuSend("PS32(2,1,1,'搓条机下料处无杆钎报错',15);\r\n");
2432   4                                              break;
2433   4                                      case E3   ://搓条机弹片处无杆钎报错。
2434   4                                              iErrPosX=200;
2435   4                                              iErrPosY=80;
2436   4                                              GpuSend("BPIC(3,0,0,3);\r\n");
2437   4                                              DELAY_US(3500);
2438   4                                              iPicNum =3;
2439   4                                              GpuSend("PS32(3,1,1,'搓条机弹片处无杆钎报错',15);\r\n");
2440   4                                              
2441   4                                              break;
2442   4                                      case E4   ://切刀堵纸光电传感器报错。
2443   4                                              iErrPosX=100;
2444   4                                              iErrPosY=170;
2445   4                                              GpuSend("BPIC(4,0,0,4);\r\n");
2446   4                                              DELAY_US(3500);
2447   4                                              iPicNum =4;
2448   4                                              GpuSend("PS32(4,1,1,'切刀堵纸光电传感器报错',15);\r\n");
2449   4                                              break;
2450   4                                      case E5   ://下料堵纸光电传感器报错。
2451   4                                              iErrPosX=180;
2452   4                                              iErrPosY=34;
2453   4                                              GpuSend("BPIC(5,0,0,5);\r\n");
2454   4                                              DELAY_US(3500);
2455   4                                              iPicNum =5;          
2456   4                                              GpuSend("PS32(5,1,1,'下料堵纸光电传感器报错。',15);\r\n");
2457   4                                              break;
2458   4                                      case E6   ://切刀零位接近传感器报错 
2459   4                                              iErrPosX=300;
2460   4                                              iErrPosY=100;
2461   4                                              GpuSend("BPIC(6,0,0,6);\r\n");
2462   4                                              iPicNum =6;
2463   4                                              DELAY_US(3500);
2464   4                                              GpuSend("PS32(6,1,1,'切刀零位接近传感器报错。',15);\r\n");
2465   4                                              break;
2466   4                                      case E7   ://储纸光电传感器感应到无纸。
2467   4                                              iErrPosX=160;
2468   4                                              iErrPosY=60;
2469   4                                              GpuSend("BPIC(7,0,0,7);\r\n");
C51 COMPILER V9.00   LED_DISPLAY                                                           05/16/2016 14:48:04 PAGE 41  

2470   4                                              iPicNum =7;
2471   4                                              DELAY_US(3500);
2472   4                                              GpuSend("PS32(7,1,1,'储纸光电传感器感应到无纸。',15);\r\n");
2473   4                                              break;
2474   4                                      case E8  : //搓条周期接近传感器报错。
2475   4                                              iErrPosX=140;
2476   4                                              iErrPosY=200;
2477   4                                              GpuSend("BPIC(8,0,0,8);\r\n");
2478   4                                              DELAY_US(3500);
2479   4                                              iPicNum =8;
2480   4                                              GpuSend("PS32(8,1,1,'搓条周期接近传感器报错。',15);\r\n");
2481   4                                              break;
2482   4                                      case E9 :  //打胶到位感应器报错。
2483   4                                              iErrPosX=180;
2484   4                                              iErrPosY=34;
2485   4                                              GpuSend("BPIC(9,0,0,1);\r\n");
2486   4                                              DELAY_US(3500);
2487   4                                              iPicNum =9;
2488   4                                              GpuSend("PS32(9,1,1,'打胶到位感应器报错。',15);\r\n");
2489   4                                              break;
2490   4                                      default:
2491   4                                              iErrPosX=180;
2492   4                                              iErrPosY=1;
2493   4                                              iPicNum=0;
2494   4                                              GpuSend("BPIC(0,0,0,1);\r\n");
2495   4                                              break;
2496   4                              }
2497   3                      }
2498   2                      
2499   2                      if(public_val.ms_timer -  g_iFlashOldTime> 500)
2500   2                      {
2501   3                              static xdata errFlashFlag=0;
2502   3                              if(g_pcStatus)
2503   3                              {
2504   4                                      g_pcStatus = 0;
2505   4                              }
2506   3                              g_iFlashOldTime = public_val.ms_timer;
2507   3                              //GpuSend("W8UE(2);\r\n");
2508   3      /*                      if(public_val.Err_Flag > 0xf)
2509   3                              {       
2510   3                                      sprintf(lcd_disp_buf,"PS32(%d,3,1,'%s',15);\r\n",iPicNum,"主控板错误：");
2511   3                                      //sprintf(lcd_disp_buf,"DS32(3,1,'%s',15);\r\n","主控板错误：");
2512   3                                      GpuSend(lcd_disp_buf);
2513   3                              }
2514   3                              else
2515   3                              {
2516   3                                      sprintf(lcd_disp_buf,"PS32(%d,3,1,'%s',15);\r\n",iPicNum,"操作板错误：");
2517   3                                      //sprintf(lcd_disp_buf,"DS32(3,1,'%s',15);\r\n","操作板错误：");
2518   3                                      GpuSend(lcd_disp_buf);
2519   3                              }
2520   3      */                      
2521   3                              if(errFlashFlag)
2522   3                              {       
2523   4                                      sprintf(lcd_disp_buf,"PS32(%d,%d,%d,'E%d',1);\r\n",iPicNum,iErrPosX,iErrPosY,public_val.Err_Flag);
2524   4                                      GpuSend(lcd_disp_buf);
2525   4                              }
2526   3                              else
2527   3                              {
2528   4                                      sprintf(lcd_disp_buf,"PS32(%d,%d,%d,'E%d',15);\r\n",iPicNum,iErrPosX,iErrPosY,public_val.Err_Flag);
2529   4                                      GpuSend(lcd_disp_buf);
2530   4                              }
2531   3                              //GpuSend("SXY(0);\r\n");
C51 COMPILER V9.00   LED_DISPLAY                                                           05/16/2016 14:48:04 PAGE 42  

2532   3                              errFlashFlag = !errFlashFlag;
2533   3                      }
2534   2                      
2535   2                      
2536   2              }
2537   1              else if(public_val.Err_Flag == 0)
2538   1              {
2539   2                      if(g_iErrStatus == 1)//从错误中恢复
2540   2                      {
2541   3                              LCDDisplayState = 0x00;
2542   3                              g_iErrStatus = 0;
2543   3                      }
2544   2              }
2545   1              
2546   1              if((DisplayState ==ST_PASSWORD  || DisplayState == ST_DATA_INPUT) )
2547   1              {
2548   2                      xdata char lcd_disp_buf[50*2] = {0};
2549   2                      xdata char old_disp;
2550   2                      if(public_val.ms_timer -  g_iFlashOldTime> 300)//闪烁频率
2551   2                      {
2552   3                              static xdata int flash = 0;
2553   3                              static xdata int oldDataLen =0;
2554   3      
2555   3                              g_iFlashOldTime = public_val.ms_timer;
2556   3                              
2557   3                              if(flash)
2558   3                              {
2559   4                                      if(strlen(cLcd_data_buf) >= oldDataLen )//当cLcd_data_buf中变成另一个参数时，会导致判断不准确。
2560   4                                      {
2561   5                                              sprintf(lcd_disp_buf,"DS48(30,190,'%s',1);\r\n",cLcd_data_buf);
2562   5                                              GpuSend(lcd_disp_buf);
2563   5                                      }
2564   4                                      else
2565   4                                      {
2566   5                                              sprintf(lcd_disp_buf,"DS48(30,190,'%s  ',1);\r\n",cLcd_data_buf);
2567   5                                              GpuSend(lcd_disp_buf);
2568   5                                      }
2569   4                              }
2570   3                              else
2571   3                              {
2572   4                                      if(  DisplayState ==ST_PASSWORD )
2573   4                                      {
2574   5                                              old_disp = cLcd_data_buf[DisplayBitNum];
2575   5                                              cLcd_data_buf[DisplayBitNum] = '_';
2576   5                                      }
2577   4                                      else
2578   4                                      {
2579   5                                              i=0;
2580   5                                              while(cLcd_data_buf[i] != '\0')
2581   5                                                      i++;
2582   5                                              i--;
2583   5                                              old_disp = cLcd_data_buf[i];
2584   5                                              cLcd_data_buf[i]='_';
2585   5                                      }
2586   4                                      sprintf(lcd_disp_buf,"DS48(30,190,'%s  ',1);\r\n",cLcd_data_buf);//不分情况直接多输出两个空格，
2587   4                                      GpuSend(lcd_disp_buf);
2588   4                                      if(  DisplayState ==ST_PASSWORD )
2589   4                                      {
2590   5                                              cLcd_data_buf[DisplayBitNum] = old_disp;
2591   5                                      }
2592   4                                      else
2593   4                                      {
C51 COMPILER V9.00   LED_DISPLAY                                                           05/16/2016 14:48:04 PAGE 43  

2594   5                                              cLcd_data_buf[i]=old_disp;
2595   5                                      }
2596   4                              }
2597   3                              flash = !flash;
2598   3                      }
2599   2              }
2600   1      
2601   1      
2602   1                      
2603   1      
2604   1              if(!UpdateState)
2605   1              {
2606   2                      UpdateState = 1;
2607   2                      UpdateCountB = public_val.ms_timer;
2608   2              }
2609   1              else
2610   1              {
2611   2                      if(public_val.ms_timer - UpdateCountB > 100)
2612   2                      {
2613   3                              flash_flag = !flash_flag;
2614   3                              UpdateState = 0;
2615   3                      }               
2616   2              }
2617   1      
2618   1      
2619   1              switch(war_bell_step)  /* 蜂鸣器报警处理 */
2620   1              {
2621   2                      case 1:
2622   2                              war_bell_delay = public_val.ms_timer;
2623   2                              Bell_flag |= 0x02;
2624   2                              war_bell_step = 10;
2625   2                      break;
2626   2                      case 10:
2627   2                              iBellOnTime = (cPauseBell == 0) ? 500 : 50;
2628   2                              //iBellOnTime = (cPauseBell == 0) ? 2000 : 50;
2629   2                              if(public_val.ms_timer - war_bell_delay > iBellOnTime) //响的时间
2630   2                                      {
2631   3                                              war_bell_delay = public_val.ms_timer;
2632   3                                              Bell_flag &= 0xfd;
2633   3                                              war_bell_step = 20;
2634   3                                      }
2635   2                      break;
2636   2                      case 20:
2637   2                              iBellOffTime = (cPauseBell == 0) ? 2000 : 2000;                 
2638   2                              //iBellOffTime = (cPauseBell == 0) ? 200 : 2000;                        
2639   2                              if(public_val.ms_timer - war_bell_delay > iBellOffTime) //不响的时间
2640   2                                      {
2641   3                                              war_bell_delay = public_val.ms_timer;
2642   3                                              war_bell_step = 30;
2643   3                                      }                       
2644   2                      break;
2645   2                      case 30:
2646   2                              if((!public_val.Err_Flag) 
2647   2                                 && (!(public_val.Work_Pause_Flag & 0x80))
2648   2                                 && (!public_val.Bell_Flag))  /* added for v19416 */
2649   2                                      {
2650   3                                              war_bell_step = 0;   /* 无报错 */
2651   3                                      }
2652   2                              else
2653   2                                      {
2654   3                                              war_bell_step = 1;
2655   3                                      }
C51 COMPILER V9.00   LED_DISPLAY                                                           05/16/2016 14:48:04 PAGE 44  

2656   2                      break;
2657   2              }
2658   1              
2659   1              if(Bell_flag)
2660   1              {
2661   2                      BELL = 1;
2662   2              }
2663   1              else
2664   1              {
2665   2                      BELL = 0;
2666   2              }
2667   1              
2668   1      
2669   1      //      TM1637_Write();
2670   1      
2671   1              
2672   1      }
2673                          
2674          
2675          /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
2676          功能：整形变字符型
2677          
2678          参数：nBit:整数位个数，nPoint:小数位个数  ,nFlag==1整数位前的0以空格补充
2679          
2680          返回值：高位空格数
2681          ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
2682          static char DataToStr(void * const pData,char size,char nBit,char nPoint,char *string,char nFlag,char nTyp
             -e)
2683          {       
2684   1              long DataS32Bit;
2685   1              char spaces;
2686   1              char Temp,module;
2687   1              char SignZero;//负数标志位,  >0: 0,  <0: 1
2688   1              
2689   1              if(size==0 || size>4)//判断size的合理性
2690   1                  return 0;
2691   1              size--;
2692   1      //      if( ( *((char *)(pData)+size) ) & 0x80 )//判断最高位是否为1
2693   1      //          SignZero=1;
2694   1      //      else
2695   1                  SignZero=0; 
2696   1                  
2697   1          DataS32Bit=0;
2698   1              if(size==3)//LONG型数据
2699   1              {                           
2700   2                      if(SignZero)
2701   2                          *((long *)&DataS32Bit) = 0 - *((long *)pData);
2702   2                      else
2703   2                          *((long *)&DataS32Bit) = *((long *)pData);
2704   2              }       
2705   1              else if(size==1)//INT型数据
2706   1              {
2707   2                  if(SignZero)
2708   2                          *((int *)&DataS32Bit) = 0 - *((int *)pData);                                                
2709   2                      else
2710   2                          *((int *)&DataS32Bit) = *((int *)pData);    
2711   2              }       
2712   1              else if(size==0)//char型数据
2713   1              {
2714   2                  if(SignZero)
2715   2                          *((char *)&DataS32Bit) = 0 - *((char *)pData);
2716   2                      else
C51 COMPILER V9.00   LED_DISPLAY                                                           05/16/2016 14:48:04 PAGE 45  

2717   2                          *((char *)&DataS32Bit) = *((char *)pData);
2718   2              }
2719   1              else
2720   1                      return 0;       
2721   1              
2722   1              switch(nType){
2723   2              case TY_B:
2724   2                      module=2;
2725   2                      break;
2726   2              case TY_D:
2727   2              case TY_RD:
2728   2              case TY_D_A:
2729   2              case TY_D_L:
2730   2              module=10;
2731   2                      break;
2732   2              case TY_H:
2733   2              module=16;
2734   2                      break;
2735   2              }
2736   1              
2737   1          spaces = 3-(nPoint+nBit);
2738   1              Temp = nPoint+nBit;
2739   1              if(Temp<3)
2740   1              {
2741   2                  nBit += (3-Temp);
2742   2                      Temp=3;
2743   2              }
2744   1                      
2745   1              do
2746   1          {
2747   2              if(Temp!=nBit || nFlag)
2748   2              {
2749   3                  string[Temp]='0'+(char)(DataS32Bit%(module));
2750   3                  DataS32Bit/=module;
2751   3              }
2752   2              else 
2753   2                      {
2754   3                              if(nPoint!=0)
2755   3                                  string[Temp]='.';
2756   3                              else
2757   3                                  string[Temp]=' ';
2758   3                      }
2759   2              
2760   2          }while( Temp-- >0 );
2761   1              
2762   1              if(nFlag)//nFlag==1整数位前的0以空格补充
2763   1              {
2764   2                  if(SignZero && spaces<3)
2765   2                          string[spaces]='-';
2766   2                      return 0;
2767   2          }
2768   1              
2769   1              Temp=0;
2770   1              spaces=0;
2771   1          do
2772   1          {
2773   2             if(string[Temp]=='0' && (Temp+1<nBit)) 
2774   2             {
2775   3                         string[Temp]=' ';
2776   3                         spaces++;
2777   3                 }
2778   2             else
C51 COMPILER V9.00   LED_DISPLAY                                                           05/16/2016 14:48:04 PAGE 46  

2779   2                 {
2780   3                 break;
2781   3                 }
2782   2             Temp++;
2783   2          }while(1);
2784   1              if(SignZero)
2785   1              {
2786   2                  string[--spaces]='-';
2787   2              }
2788   1              Temp=nPoint+nBit-spaces;
2789   1              if(Temp<3)
2790   1                  spaces -= (3-Temp);
2791   1              return spaces;
2792   1      }
2793          
2794          /*++++++++++++++++++++++++++++++++++++++++++++++++++++
2795          功能：需要一个函数将字符化整形
2796          
2797          参数：len 为字符长度
2798          
2799          返回值：无
2800          ++++++++++++++++++++++++++++++++++++++++++++++++++++*/
2801          static long StrToData(char *string,char len,char nType)
2802          {       
2803   1          unsigned long x,bi;     
2804   1          char i,module;
2805   1      
2806   1          switch(nType){
2807   2              case TY_B:
2808   2                      module=2;
2809   2                      break;
2810   2              case TY_D:
2811   2              module=10;
2812   2                      break;
2813   2              case TY_H:
2814   2              module=16;
2815   2                      break;
2816   2              }
2817   1              x=0;
2818   1              bi=1;
2819   1              for(i=len;i>0;)
2820   1          {
2821   2              i--;
2822   2                      if(string[i] >= '0' && string[i]<=0x3F)
2823   2                      {
2824   3                         x+=(string[i] - '0')*bi;
2825   3                         bi*=module;
2826   3              }
2827   2              }
2828   1              if(string[0]=='-' || string[1]=='-' || string[2]=='-' )//负数
2829   1                  return (0-x);
2830   1              else
2831   1                  return x;
2832   1      
2833   1      }
2834          void MenuEditLook(unsigned char cDisplayItemNum)
2835          {
2836   1              
2837   1              //unsigned char DisplayItemNum;
2838   1              switch(cDisplayItemNum)
2839   1              {
2840   2                      case 10:
C51 COMPILER V9.00   LED_DISPLAY                                                           05/16/2016 14:48:04 PAGE 47  

2841   2                              GpuSend("SPG(31);\r\n");                
2842   2                      break;
2843   2              
2844   2                      case 11:
2845   2                              GpuSend("SPG(32);\r\n");                
2846   2                      break;
2847   2                      
2848   2                      case 12:
2849   2                              GpuSend("SPG(33);\r\n");                
2850   2                      break;
2851   2                      
2852   2                      case 13:
2853   2                              GpuSend("SPG(34);\r\n");                
2854   2                      break;
2855   2                      
2856   2                      case 14:
2857   2                              GpuSend("SPG(35);\r\n");                
2858   2                      break;
2859   2                      
2860   2                      case 15:
2861   2                              GpuSend("SPG(36);\r\n");                
2862   2                      break;
2863   2                      
2864   2                      case 16:
2865   2                              GpuSend("SPG(37);\r\n");                
2866   2                      break;
2867   2                      
2868   2                      case 17:
2869   2                              GpuSend("SPG(38);\r\n");                
2870   2                      break;
2871   2                      
2872   2                      case 18:
2873   2                              GpuSend("SPG(39);\r\n");                
2874   2                      break;
2875   2                      
2876   2                      case 19:
2877   2                              GpuSend("SPG(40);\r\n");                
2878   2                      break;
2879   2                      
2880   2                      
2881   2                      case 20:
2882   2                              GpuSend("SPG(41);\r\n");                
2883   2                      break;
2884   2                      
2885   2                      
2886   2                      case 21:
2887   2                              GpuSend("SPG(42);\r\n");                
2888   2                      break;
2889   2                      
2890   2                      case 22:
2891   2                              GpuSend("SPG(43);\r\n");                
2892   2                      break;
2893   2                      
2894   2                      case 23:
2895   2                              GpuSend("SPG(44);\r\n");                
2896   2                      break;
2897   2                      
2898   2                      case 24:
2899   2                              GpuSend("SPG(45);\r\n");                
2900   2                      break;
2901   2                      
2902   2                      case 25:
C51 COMPILER V9.00   LED_DISPLAY                                                           05/16/2016 14:48:04 PAGE 48  

2903   2                              GpuSend("SPG(46);\r\n");                
2904   2                      break;
2905   2                      
2906   2                      case 26:
2907   2                              GpuSend("SPG(47);\r\n");                
2908   2                      break;
2909   2                      
2910   2                      case 27:
2911   2                              GpuSend("SPG(48);\r\n");                
2912   2                      break;
2913   2                      
2914   2                      case 28:
2915   2                              GpuSend("SPG(49);\r\n");                
2916   2                      break;
2917   2                      
2918   2                      case 29:
2919   2                              GpuSend("SPG(50);\r\n");                
2920   2                      break;
2921   2                      default:
2922   2                              GpuSend("SPG(31);\r\n");
2923   2                              break;
2924   2              
2925   2              }
2926   1              
2927   1              DELAY_US(UART1s_DELAY);
2928   1      }
2929          
2930          void ClearLCDScreen(int c)
2931          {
2932   1              xdata char buf[20];
2933   1              DELAY_US(1000);
2934   1              sprintf(buf,"CLS(%d);\r\n",c);
2935   1              GpuSend(buf);
2936   1              DELAY_US(1000);
2937   1              
2938   1      }
2939          
2940          void TextOut(char *text)
2941          {
2942   1      //      xdata char lcd_disp_buf[50*2] = {0};
2943   1      //      sprintf(lcd_disp_buf,"DS%d(%d,%d,'%s',%d);\r\n",fontsize,x,y,text,colour);
2944   1      //      GpuSend(lcd_disp_buf);
2945   1      }
*** WARNING C280 IN LINE 2940 OF LED_DISPLAY.C: 'text': unreferenced local variable
2946          void IOCheck()
2947          {
2948   1              xdata int i =0;
2949   1              xdata int tool = 0x01;
2950   1              xdata char usart2_buf[30]={0}; 
2951   1      //                              sprintf(usart2_buf,"DS32(3,1,'%s,%d',15);\r\n","IO：",public_val.io_read);
2952   1                                      //sprintf(lcd_disp_buf,"DS32(3,1,'%s',15);\r\n","操作板错误：");
2953   1      //                              GpuSend(usart2_buf);
2954   1              for(i=1;i < 5 ;i ++)
2955   1              {
2956   2                      sprintf(usart2_buf,"W8UE(%d);\r\n",i);
2957   2                      GpuSend(usart2_buf);
2958   2                      
2959   2                      if ((public_val.io_read & (tool << ((i -1 ) *2  ))) == 0)//(sziostatus[8] - '0' == 0)
2960   2                      {
2961   3                              GpuSend("CIRF(65,55,15,1);\r\n");
2962   3                      }
2963   2                      else
C51 COMPILER V9.00   LED_DISPLAY                                                           05/16/2016 14:48:04 PAGE 49  

2964   2                      {
2965   3                              GpuSend("CIRF(65,55,15,2);\r\n");
2966   3                      }
2967   2                      DELAY_US(UART2_DELAY);
2968   2                      if ((public_val.io_read & (tool << ( (i-1)  * 2 + 1)) )== 0)//sziostatus[9] - '0' == 0)
2969   2                      {
2970   3                              GpuSend("CIRF(165,55,15,1);\r\n");
2971   3                      }
2972   2                      else
2973   2                      {
2974   3                              GpuSend("CIRF(165,55,15,2);\r\n");
2975   3                      }                               
2976   2                      GpuSend("SXY(0,0);\r\n");
2977   2                      DELAY_US(UART2_DELAY);
2978   2              }
2979   1              for(i =5;i< 7 ;i++)
2980   1              {
2981   2                      sprintf(usart2_buf,"W8UE(%d);\r\n",i);
2982   2                      GpuSend(usart2_buf);
2983   2                      
2984   2                      if ((public_val.io_read & (tool << ((i) *2  ))) == 0)//(sziostatus[8] - '0' == 0)
2985   2                      {
2986   3                              GpuSend("CIRF(65,55,15,1);\r\n");
2987   3                      }
2988   2                      else
2989   2                      {
2990   3                              GpuSend("CIRF(65,55,15,2);\r\n");
2991   3                      }
2992   2                      DELAY_US(UART2_DELAY);
2993   2                      if ((public_val.io_read & (tool << ( (i)  * 2 + 1)) )== 0)//sziostatus[9] - '0' == 0)
2994   2                      {
2995   3                              GpuSend("CIRF(165,55,15,1);\r\n");
2996   3                      }
2997   2                      else
2998   2                      {
2999   3                              GpuSend("CIRF(165,55,15,2);\r\n");
3000   3                      }                               
3001   2                      GpuSend("SXY(0,0);\r\n");
3002   2                      DELAY_US(UART2_DELAY);
3003   2              }
3004   1      
3005   1      }
3006          
3007          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  16802    ----
   CONSTANT SIZE    =   2491    ----
   XDATA SIZE       =   1073     366
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
