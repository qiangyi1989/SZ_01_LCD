C51 COMPILER V9.00   LED_DISPLAY                                                           05/12/2016 11:15:08 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE LED_DISPLAY
OBJECT MODULE PLACED IN .\out\LED_Display.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE LED_Display.c LARGE BROWSE DEBUG OBJECTEXTEND PRINT(.\lst\LED_Display.lst) 
                    -OBJECT(.\out\LED_Display.obj)

line level    source

   1          /**
   2           * Copyright (c) 2012, 长沙晗光电子科技有限公司
   3           * All rights reserved.
   4           *
   5           * FILE:   LED_Display.c
   6           * LED显示程序
   7           *
   8           * @file LED_Display.h led_driver.h
   9           * 头文件.
  10           *
  11           * @author JWD
  12           * @date 2012-12-21
  13           *
  14           */
  15          #include "eeprom.h"
  16          #include "LED_Display.h"
  17          #include "I2c.h"
  18          #include "reg51.h"
  19          #include "save_cnt.h"
  20          #include "global.h"
  21          #include "sys.h"
  22          
  23          #include "uart.h"
  24          #include <stdio.h>
  25          #include <string.h>
  26          
  27          #ifdef DISP_C
  28          
  29          #define BELL P25
  30          
  31          #define MAIN_ADJ_DELAY 2000
  32          #define KEY_DOU_DELY 50
  33          #define KEY_LONG_DELY 100
  34          #define BELL_ON_DELY 50
  35          #define LONG_KEY_STEP_SWITCH 50
  36          #define DISP_ERR_TIMER 1000 //延时数据修改失败时间 和 错误显示时间
  37          
  38          //#define NO_KEY_RETURN_MAIN 15000 //00000菜单无按键返回主页面延时
  39          #define NO_KEY_RETURN_MAIN 30000 //00000菜单无按键返回主页面延时
  40          
  41          #define TEST_MODE_CNT    40
  42          //#define LEARN_MODE_CNT   20
  43          #define LEARN_MODE_CNT   30
  44          
  45          
  46          extern char eeprom_en;
  47          extern xdata unsigned int disp_buf[5];
  48          
  49          /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  50           |                                函数声明                                    |
  51          ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
  52          //void InitLEDDrivers(void);
  53          void LEDShowFlashString(const char  * buff,char x);
  54          //void LEDShowString(char  * buff,char x);
C51 COMPILER V9.00   LED_DISPLAY                                                           05/12/2016 11:15:08 PAGE 2   

  55          void LEDShowCharS(const char * buff,char num,char x);
  56          void LEDClearChar(char x,char n);
  57          void LEDClearCharS(char num,char x);
  58          void LED_ShowNumber(char * buff,char x);
  59          //void LED_ShowData(char * buff,char x,char nPoint);
  60          
  61          static char DataToStr(void * const pData,char size,char nBit,char nPoint,char *string,char nFlag,char nTyp
             -e);
  62          static long StrToData(char *string,char len,char nType);
  63          
  64          //extern void ResetDoorForTest();
  65          
  66          
  67          //sbit P17 = P1^7;
  68          //sbit P37 = P3^7;
  69          sbit P25 = P2^5;
  70          //sbit P21 = P2^1;
  71          //sbit P22 = P2^2;
  72          //sbit P14 = P1^4;
  73          
  74          //#define RED P17
  75          //#define YELLOW P54
  76          //#define BLUE P55
  77          
  78          
  79          
  80          
  81          //char xdata DIS_OPTIONING;                                                                                     ///<【不允许插引工作标志。0：允许插引；1：不允许插引】
  82          char xdata DIS_ERR_FLGA = 0;
  83          
  84          //内部变量定义
  85          //static xdata unsigned int  l_state;                                                           //显示画面状态
  86          
  87          //static xdata unsigned long  l_input_value;                                            //参数修改画面输入值
  88          static xdata char  l_stop_poll;                                                                 //停止循环显示
  89          
  90          //static xdata char DisplayStateOld;                                                            //记忆画面状态
  91          
  92          static xdata char  DisplayMainID;                                                                       //主画面序号
  93          static xdata char  DisplayMenuID;                                                                       //菜单画面序号
  94          
  95          static xdata char  DisplayMainTotal;                                                            //主画面总数
  96          static xdata char  MenuTotals;                                                                  //主菜单画面总数
  97          
  98          
  99          static xdata char  DisplayMenuTotal;                                                            //菜单画面总数
 100          
 101          static xdata char  DisplayItemNum;                                                              //显示项目序号
 102          static xdata char  DisplayBitNum;                                                                       //显示位号
 103          
 104          //static xdata char  MenuUpdateState;                                                           //菜单显示更新状态
 105          static xdata char  PasswordBuff[5];                                                             //密码数据缓冲区
 106          static xdata char  DisplayBuff[10];
 107          
 108          int  DisplayState;                                                                                      //画面状态
 109          xdata int  LCDDisplayState;
 110          xdata int  LCDChildDisplayState = 0;
 111          
 112          static xdata const MAIN_SHOW * pMain;                                                           //主画面数据指针
 113          static xdata const MENU_SHOW * pMenu;                                                           //菜单指针
 114          static xdata const MENU_ITEM * pItem;                                                           //菜单项目指针
 115          
C51 COMPILER V9.00   LED_DISPLAY                                                           05/12/2016 11:15:08 PAGE 3   

 116          //static xdata const MENU_SHOW * pCode;
 117          static xdata const MENU_SHOW * pDataValue;
 118          
 119          //static xdata const TYPE_CODE * disp_code;
 120          
 121          //static xdata char  UpdateDataCount;
 122          static xdata char  CycShowCount;
 123          static xdata char  InputDataLen;
 124          static xdata long  TempInputData;
 125          static xdata char  DataType;
 126          
 127          
 128          xdata public_stru public_val;
 129          xdata MENU_CHANG now_menu;
 130          
 131          xdata char cPauseBell = 0; 
 132          
 133          xdata char test_mode = 0;   /* 测试模式标志: 0正常工作模式，1测试模式 */
 134          
 135          
 136          xdata char uart_send_buf[100];
 137          
 138          
 139          //菜单配置界面
 140          //参数组定义
 141          //#define DEBUG_MENU_GS_VAL 30
 142          //#define USE_MENU_NUM 16
 143          
 144          static xdata MENU_SHOW Menu00000[MENU_ID_00000_MAX_ITEM];
 145          static xdata MENU_SHOW Menu10101[MENU_ID_10101_MAX_ITEM];
 146          static xdata MENU_SHOW Menu10102[MENU_ID_10102_MAX_ITEM];
 147          static xdata MENU_SHOW Menu10103[MENU_ID_10103_MAX_ITEM];
 148          static xdata MENU_SHOW Menu10104[MENU_ID_10104_MAX_ITEM];
 149          static xdata MENU_SHOW Menu20101[MENU_ID_20101_MAX_ITEM];
 150          
 151          xdata char Menu_Number[MENU_NUM] = {MENU_ID_00000_MAX_ITEM,
 152                                                                                  MENU_ID_10101_MAX_ITEM,
 153                                                                                  MENU_ID_10102_MAX_ITEM,
 154                                                                                  MENU_ID_10104_MAX_ITEM,
 155                                                                                  MENU_ID_20101_MAX_ITEM
 156                  };
 157          //xdata char Menu0_Number = 10, Menu1_Number = 20;
 158          
 159          /*--------------菜单设置画面 数据配置-------------*/
 160          code MENU_ITEM MenuItem[]={
 161            //菜单序号,菜单地址,密码 数据存储首地址 最大数据个数
 162                  {MENU_ID_00000,Menu00000,"00000",EEPROM_MENU_1,MENU_ID_00000_MAX_ITEM,0,&Menu_Number[0]}, 
 163                  {MENU_ID_10101,Menu10101,"10101",EEPROM_MENU_2,MENU_ID_10101_MAX_ITEM,0,&Menu_Number[2]}, 
 164                  {MENU_ID_10102,Menu10102,"10102",EEPROM_MENU_3,MENU_ID_10102_MAX_ITEM,0,&Menu_Number[3]}, 
 165                  {MENU_ID_10103,Menu10103,"10103",EEPROM_MENU_4,MENU_ID_10103_MAX_ITEM,0,&Menu_Number[4]}, 
 166                  {MENU_ID_10104,Menu10104,"10104",EEPROM_MENU_5,MENU_ID_10104_MAX_ITEM,0,&Menu_Number[5]}, 
 167                  {MENU_ID_20101,Menu20101,"20101",EEPROM_MENU_6,MENU_ID_20101_MAX_ITEM,0,&Menu_Number[6]}, 
 168                  {0,0,0}
 169          };
 170          
 171          code MAIN_SHOW MainItem[]={
 172              //显示的字符串,数据显示类型,数据地址,函数名
 173              {"",TY_D_A,0,&(public_val.main_disp_val),INT32_SIZE,5,0,99999,0},           
 174              {0,0,0}
 175          };
 176          
 177          /*-------------------------主画面数据配置,全局变量----------------------------*/
C51 COMPILER V9.00   LED_DISPLAY                                                           05/12/2016 11:15:08 PAGE 4   

 178          xdata const MAIN_PIC main_menu_cfg[]={
 179              {4,2,MainItem,MenuItem},
 180          };
 181          
 182          static code const char LED_ASCII[128]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //0x0
 183                                                      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
 184                                                      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //0x1
 185                                                      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
 186                                                      0x00,0xFE,0xB0,0xED,0xF9,0xB3,0xDB,0xDF, //0x2
 187                                                      0xF0,0xFF,0xFB,0x00,0x00,0x40,0x80,0x00, 
 188                                                      0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07, // 起始48:0-7
 189                                                      0x7f,0x6F,0x77,0x1F,0x4E,0x3D,0x4F,0x47, //     56
 190                                                      0xFB,0x77,0x1F,0x4E,0x3D,0x79,0x71,0xFB, //     64
 191                                                      0x37,0x06,0x0E,0x07,0x38,0x6A,0x76,0x1D, //     72
 192                                                      0x73,0x67,0x05,0x5B,0x31,0x3E,0x1C,0x5C, //     80
 193                                                      0x31,0x3B,0xED,0x00,0x00,0x00,0x62,0x08,
 194                                                      0x00,0x77,0x1F,0x4E,0x3D,0x4F,0x47,0xFB, //0x6
 195                                                      0x37,0x06,0x38,0x07,0x0E,0x6A,0x15,0x1D, 
 196                                                      0x67,0x73,0x50,0x5B,0x78,0x3E,0x1C,0x5C, //0x7
 197                                                      0x31,0x3B,0xED,0x00,0x00,0x00,0x00,0x00, 
 198                                     };
 199          
 200          //unsigned short usParamNum = 30;   /* 主板的配置参数个数，最大为30个 */
 201          
 202          xdata int gsKeyVal = 0;    /* 按键值 */
 203          xdata char gcKeyType = 0;  /* 按键类型: 0短按, 1长按下，2长按抬起 */
 204          
 205          //xdata char gcKeyLongUpFlag = 0;    /* 长按抬起标志:0未抬起，1抬起 */
 206          //xdata char gcKeyLongDownFlag = 0;  /* 长按按下标志:0未按下，1按下 */
 207          
 208          xdata _U_BIT_PARAM unKey;
 209           
 210          
 211          xdata char speed_mode = 1;   //速度模式: 1高速， 0低速
 212          
 213          xdata char qz_wait = 0;      //等待切纸确认: 0未等待，1等待
 214          
 215          //add by yq
 216          xdata char Menu0_Number;
 217          xdata unsigned int g_iFlashOldTime = 0;
 218          xdata unsigned int g_iInterfaceChangOldTime=0;
 219          xdata char* g_pcStatus = 0;                                                
 220          void ClearLCDScreen(int c);                                                
 221          /*++++++++++++++++++++++++++++++++++++++++++++++++
 222          功能：显示字符串。
 223          
 224          参数：buff:欲发送的数据缓冲区；x:坐标
 225          
 226          返回值：无。
 227          
 228          说明：
 229          ++++++++++++++++++++++++++++++++++++++++++++++++*/
 230          void  LEDShowFlashString(const char  * buff,char x) 
 231          {
 232   1              do
 233   1              {
 234   2                      disp_buf[x++] = LED_ASCII[*buff++];
 235   2              }while(x<6 && *buff!=0);
 236   1      }
 237          
 238          void  LEDShowCaption(char num) 
 239          {
C51 COMPILER V9.00   LED_DISPLAY                                                           05/12/2016 11:15:08 PAGE 5   

 240   1      char *buff,x = 0;
 241   1      switch(num)
 242   1              {
 243   2                      case 0:
 244   2                              buff = "1-";
 245   2                      break;
 246   2                      case 1:
 247   2                              buff = "2-";
 248   2                      break;          
 249   2                      case 2:
 250   2                              buff = "3-";
 251   2                      break;  
 252   2                      case 3:
 253   2                              buff = "4-";
 254   2                      break;          
 255   2                      case 4:
 256   2                              buff = "5-";
 257   2                      break;          
 258   2                      case 5:
 259   2                              buff = "6-";
 260   2                      break;          
 261   2                      case 6:
 262   2                              buff = "7-";
 263   2                      break;          
 264   2                      case 7:
 265   2                              buff = "8-";
 266   2                      break;          
 267   2                      case 8:
 268   2                              buff = "9-";
 269   2                      break;          
 270   2                      case 9:
 271   2                              buff = "10";
 272   2                      break;          
 273   2                      case 10:
 274   2                              buff = "11";
 275   2                      break;          
 276   2                      case 11:
 277   2                              buff = "12";
 278   2                      break;          
 279   2                      case 12:
 280   2                              buff = "13";
 281   2                      break;  
 282   2                      case 13:
 283   2                              buff = "14";
 284   2                      break;  
 285   2                      case 14:
 286   2                              buff = "15";
 287   2                      break;  
 288   2                      case 15:
 289   2                              buff = "16";
 290   2                      break;  
 291   2                      case 16:
 292   2                              buff = "17";
 293   2                      break;
 294   2                      case 17:
 295   2                              buff = "18";
 296   2                      break;  
 297   2                      case 18:
 298   2                              buff = "19";
 299   2                      break;  
 300   2                      case 19:
 301   2                              buff = "20";
C51 COMPILER V9.00   LED_DISPLAY                                                           05/12/2016 11:15:08 PAGE 6   

 302   2                      break;                  
 303   2                      case 20:
 304   2                              buff = "21";
 305   2                      break;          
 306   2                      case 21:
 307   2                              buff = "22";
 308   2                      break;          
 309   2                      case 22:
 310   2                              buff = "23";
 311   2                      break;  
 312   2                      case 23:
 313   2                              buff = "24";
 314   2                      break;  
 315   2                      case 24:
 316   2                              buff = "25";
 317   2                      break;  
 318   2                      case 25:
 319   2                              buff = "26";
 320   2                      break;  
 321   2                      case 26:
 322   2                              buff = "27";
 323   2                      break;
 324   2                      case 27:
 325   2                              buff = "28";
 326   2                      break;  
 327   2                      case 28:
 328   2                              buff = "29";
 329   2                      break;  
 330   2                      case 29:
 331   2                              buff = "30";
 332   2                      break;  
 333   2                      case 80:
 334   2                              buff = "   A1";
 335   2                      break;
 336   2                      case 81:
 337   2                              buff = "   A2";
 338   2                      break;
 339   2                      case 82:
 340   2                              buff = "   A3";
 341   2                      break;
 342   2                      case 83:
 343   2                              buff = "   A4";
 344   2                      break;
 345   2                      case 84:
 346   2                              buff = "   A5";
 347   2                      break;
 348   2                      case 85:
 349   2                              buff = "   A6";
 350   2                      break;
 351   2                      case 86:
 352   2                              buff = "   A7";
 353   2                      break;
 354   2                      case 87:
 355   2                              buff = "   A8";
 356   2                      break;
 357   2                      case 88:
 358   2                              buff = "   A9";
 359   2                      break;
 360   2                      case 89:
 361   2                              buff = "  A10";
 362   2                      break;
 363   2              }
C51 COMPILER V9.00   LED_DISPLAY                                                           05/12/2016 11:15:08 PAGE 7   

 364   1              do
 365   1              {
 366   2                      disp_buf[x++] = LED_ASCII[*buff++];
 367   2              }while(x<6 && *buff!=0);
 368   1      }
 369          
 370          /*++++++++++++++++++++++++++++++++++++++++++++++++
 371          功能：显示字符串。
 372          
 373          参数：buff:欲发送的数据缓冲区；x:坐标
 374          
 375          返回值：无。
 376          
 377          说明：
 378          ++++++++++++++++++++++++++++++++++++++++++++++++*/
 379          /*void  LEDShowString(char  * buff,char x) 
 380          {
 381                  do
 382                  {
 383                          disp_buf[x++] = LED_ASCII[*buff++];
 384                  
 385                  }while(x<6 && *buff!=0);
 386          }*/
 387          
 388          /*void  LED_ShowData(char * buff,char x,char nPoint)
 389          {
 390              do
 391                  {
 392                  if(nPoint !=0 && (8-nPoint)==x)
 393                          disp_buf[x++] = LED_ASCII[*buff++] | 0x80;              ///<【位7置1】
 394                          else
 395                                  disp_buf[x++] = LED_ASCII[*buff++];
 396                  }while(x<6 && *buff!=0);
 397          }*/
 398          
 399          /*++++++++++++++++++++++++++++++++++++++++++++++++
 400          功能：清除指定行号列号的字符。
 401          
 402          参数：x:坐标1-8。
 403          
 404          返回值：无。
 405          
 406          说明： 无。
 407          ++++++++++++++++++++++++++++++++++++++++++++++++*/
 408          void  LEDClearChar(char x,char n)
 409          {
 410   1              char i;
 411   1              for(i = x; i< (x+n); i++ )
 412   1                      {
 413   2                              disp_buf[i] = 0;                
 414   2                      }
 415   1      }
 416          
 417          
 418          /*++++++++++++++++++++++++++++++++++++++++++++++++
 419          功能：显示数字。
 420          参数：buff:欲发送的数据缓冲区；x:坐标
 421          返回值：无。
 422          说明：
 423          ++++++++++++++++++++++++++++++++++++++++++++++++*/
 424          void  LED_ShowNumber(char * buff,char x) 
 425          {
C51 COMPILER V9.00   LED_DISPLAY                                                           05/12/2016 11:15:08 PAGE 8   

 426   1              char TempFlag=0;
 427   1              do
 428   1              {
 429   2                      if(*(buff+1)!='.' || TempFlag==1)
 430   2                      {
 431   3                              disp_buf[x++] = LED_ASCII[*buff++];
 432   3                              //SendLed(x++,LED_ASCII[*buff++]);
 433   3                      }
 434   2                      else
 435   2                      {
 436   3                              disp_buf[x++] = LED_ASCII[*buff++] | 0x80;
 437   3                              //SendLed(x++,(LED_ASCII[*buff++] | 0x80));
 438   3                              TempFlag=1;
 439   3                              buff++;
 440   3                      }
 441   2              }while(x<6);
 442   1              
 443   1      }
 444          
 445          //菜单数据指向
 446          void menu_cfg(void)
 447          {
 448   1              char i;
 449   1              for(i = 0; i < MENU_ID_00000_MAX_ITEM ; i++)
 450   1                      {
 451   2                              Menu00000[i].m_data_vale = &public_val.Disp_Dz_00000[i];
 452   2                      }
 453   1      
 454   1              for(i = 0; i < MENU_ID_10101_MAX_ITEM ; i++)
 455   1                      {
 456   2                              Menu10101[i].m_data_vale = &public_val.Disp_Dz_10101[i];
 457   2                      }
 458   1      
 459   1              for(i = 0; i < MENU_ID_10102_MAX_ITEM ; i++)
 460   1                      {
 461   2                              Menu10102[i].m_data_vale = &public_val.Disp_Dz_10102[i];
 462   2                      }
 463   1              
 464   1              for(i = 0; i < MENU_ID_10103_MAX_ITEM ; i++)
 465   1                      {
 466   2                              Menu10103[i].m_data_vale = &public_val.Disp_Dz_10103[i];
 467   2                      }
 468   1      
 469   1              for(i = 0; i < MENU_ID_10104_MAX_ITEM ; i++)
 470   1                      {
 471   2                              Menu10104[i].m_data_vale = &public_val.Disp_Dz_10104[i];
 472   2                      }
 473   1      
 474   1              for(i = 0; i < MENU_ID_20101_MAX_ITEM ; i++)
 475   1                      {
 476   2                              Menu20101[i].m_data_vale = &public_val.Disp_Dz_20101[i];
 477   2                      }
 478   1      }
 479          
 480          /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 481          名称:   read_menu_data(char menu_id)
 482          功能：  读取菜单配置数据 和 菜单数据
 483          参数：  无
 484          返回值：无
 485          ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
 486          
 487          
C51 COMPILER V9.00   LED_DISPLAY                                                           05/12/2016 11:15:08 PAGE 9   

 488          void read_menu_data(char menu_id)
 489          {
 490   1              unsigned char *progbyte,read_byte;
 491   1              unsigned int progadd;
 492   1      
 493   1              int i;
 494   1      
 495   1              progadd = MenuItem[menu_id].eeprom_cfg_add;
 496   1              read_byte = IapReadByte(progadd++);
 497   1              
 498   1              for(i = 0; i < MenuItem[menu_id].MenuItem_Max; i++)
 499   1                      {
 500   2                              if(menu_id == MENU_ID_10104)
 501   2                                      MenuItem[menu_id].m_pcfg[i].m_max = 450;
 502   2                              else
 503   2                                      MenuItem[menu_id].m_pcfg[i].m_max = 999;
 504   2                              MenuItem[menu_id].m_pcfg[i].m_min = 0;
 505   2                              MenuItem[menu_id].m_pcfg[i].ext_property = 0; //read_byte;
 506   2                      }
 507   1              MenuItem[MENU_ID_10104].m_pcfg[PASS_LOCK_COUNT - 1].m_max = 500;
 508   1              
 509   1              switch(menu_id)
 510   1                      {
 511   2                              case MENU_ID_00000:
 512   2                                      progbyte = (unsigned char *)&public_val.Disp_Dz_00000[0];
 513   2                              break;                  
 514   2                              case MENU_ID_10101:
 515   2                                      progbyte = (unsigned char *)&public_val.Disp_Dz_10101[0];
 516   2                              break;
 517   2                              case MENU_ID_10102:
 518   2                                      progbyte = (unsigned char *)&public_val.Disp_Dz_10102[0];
 519   2                              break;
 520   2                              case MENU_ID_10103:
 521   2                                      progbyte = (unsigned char *)&public_val.Disp_Dz_10103[0];
 522   2                              break;
 523   2                              case MENU_ID_10104:
 524   2                                      progbyte = (unsigned char *)&public_val.Disp_Dz_10104[0];
 525   2                              break;
 526   2                              case MENU_ID_20101:
 527   2                                      progbyte = (unsigned char *)&public_val.Disp_Dz_20101[0];
 528   2                              break;
 529   2                      }
 530   1              progadd = MenuItem[menu_id].eeprom_add;
 531   1              for(i = 0; i < MenuItem[menu_id].MenuItem_Max + 1; i++)
 532   1                      {
 533   2                              *progbyte = IapReadByte(progadd++);
 534   2                              progbyte++;
 535   2                              *progbyte = IapReadByte(progadd++);
 536   2                              progbyte++;
 537   2                      }
 538   1                      
 539   1              
 540   1      }
 541          
 542          //将菜单值更新到通讯菜单值，合并两个菜单。
 543          void update_menu_to_com(void)
 544          {
 545   1              char TempB;
 546   1              for(TempB = 0; TempB < MENU_ID_00000_MAX_ITEM; TempB++)
 547   1                      {
 548   2                              public_val.menu_parm[TempB] = public_val.Disp_Dz_00000[TempB];
 549   2                      }
C51 COMPILER V9.00   LED_DISPLAY                                                           05/12/2016 11:15:08 PAGE 10  

 550   1      
 551   1              for(TempB = 0; TempB < MENU_ID_10101_MAX_ITEM; TempB++)
 552   1                      {
 553   2                              public_val.menu_parm[TempB + MENU_ID_00000_MAX_ITEM] = public_val.Disp_Dz_10101[TempB];
 554   2                      }       
 555   1      }
 556          
 557          //读取MCU的ID号 值举例:0D 00 00 2C 02 4B E5
 558          //                                         0D 00 00 30 03 64 E4(开发板载MCU)
 559          void read_id()
 560          {
 561   1          char code *cptr;
 562   1              char i,read_byte[7];
 563   1          cptr = ID_ADDR_ROM;         //从程序区读取ID号
 564   1          for(i=0; i<7; i++)         //读7个字节
 565   1                  {
 566   2                      read_byte[i] = *cptr++; // 0xff; // 
 567   2                  }
 568   1              public_val.password_index_disp = (int)read_byte[5];
 569   1              public_val.password_index_disp <<= 8;
 570   1              public_val.password_index_disp |= (int)read_byte[6] & 0xff;
 571   1              public_val.password_index = public_val.password_index_disp % 2000;
 572   1      
 573   1              cptr = EEPROM_PASSWORD;
 574   1              read_byte[0] = IapReadByte(EEPROM_PASSWORD + (public_val.password_index<<1));
 575   1              read_byte[1] = IapReadByte(EEPROM_PASSWORD + (public_val.password_index<<1)+1);
 576   1              public_val.password_val[0] = (int)read_byte[0] & 0xff;
 577   1              public_val.password_val[1] = (int)read_byte[1] & 0xff;
 578   1      }       
 579          
 580          /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 581          名称:   void InitLEDDisplay(void)
 582          
 583          功能：  显示初始化程序
 584          
 585          参数：  无
 586                
 587          返回值：无
 588          ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
 589          void InitLEDDisplay(void)
 590          {
 591   1          char TempB;
 592   1          //unsigned int temp_int;
 593   1                      
 594   1              BELL = 0;
 595   1      
 596   1              //LEDShowFlashString("Lt-2 ",0);
 597   1              LEDShowFlashString("60409",0);    /* 显示操作板版本号 */
 598   1              
 599   1      //      TM1637_Write();
 600   1      
 601   1              ///【统计主界面需要显示的项数】
 602   1              pMain = main_menu_cfg[0].m_main;
 603   1              for( TempB = 0; pMain[TempB].m_str; TempB++ ) ///<【空串不为0，即不为假】
 604   1                      {
 605   2                              ;
 606   2                      }                       
 607   1              DisplayMainTotal = TempB;
 608   1      
 609   1              ///【统计下级子菜单数量】
 610   1              pItem = main_menu_cfg[0].m_menu;
 611   1              pMenu = pItem[0].m_pcfg;
C51 COMPILER V9.00   LED_DISPLAY                                                           05/12/2016 11:15:08 PAGE 11  

 612   1              for(TempB = 0; TempB == pItem[TempB].MenuID; TempB++) 
 613   1                      {
 614   2                              read_menu_data(TempB); //读取菜单数据值;
 615   2                      }
 616   1              MenuTotals = TempB;
 617   1              update_menu_to_com();
 618   1      
 619   1              menu_cfg();
 620   1              
 621   1              
 622   1              CycShowCount = 0;
 623   1              DisplayItemNum = 0;
 624   1              DisplayState = ST_MAIN;                                                                 //进入主画面
 625   1              l_stop_poll = 0;                                                                                //默认定格显示
 626   1              
 627   1              //标志位初始化
 628   1              public_val.Work_Pause_Flag = 0; 
 629   1              public_val.Err_Flag = 0;
 630   1              public_val.Bell_Flag = 0;
 631   1      
 632   1              public_val.cnt_after_powered = 0;
 633   1              public_val.Lock_Flag = 0;
 634   1      
 635   1              //加密相关变量初始化
 636   1              read_id();
 637   1      
 638   1              public_val.Disp_Dz_10103[12] = public_val.password_val[0];
 639   1              public_val.Disp_Dz_10103[13] = public_val.password_val[1];
 640   1              
 641   1              public_val.input_pass_mask = 0;
 642   1              for(TempB = 0; TempB < PASS_LOCK_COUNT; TempB++)
 643   1                      {
 644   2                              if( (public_val.Disp_Dz_10103[TempB * 2] == 0)
 645   2                                      && (public_val.Disp_Dz_10103[TempB * 2 + 1] == 0)
 646   2                                      )
 647   2                                      {
 648   3                                              public_val.input_pass_mask |= 1 << TempB;
 649   3                                      }
 650   2                              public_val.Disp_Dz_10102[TempB * 2] = 0;
 651   2                              public_val.Disp_Dz_10102[TempB * 2 + 1] = 0;
 652   2                      }
 653   1              
 654   1              read_loack_count();
 655   1              read_user_count();
 656   1              public_val.Disp_Dz_20101[0] = public_val.work_count / LOCK_UNIT; //已生产根数赋值
 657   1              /* added by james */
 658   1          public_val.ms_timer = 0;
 659   1              public_val.io_read = 0;
 660   1      
 661   1              unKey.all = 0xFFFF;
 662   1      
 663   1      }
 664          
 665          
 666          //完成对菜单数据的存储
 667          void func_menu_update(int menu_id)
 668          {
 669   1              unsigned char *progbyte,i,readbyte;
 670   1              unsigned int progadd;
 671   1              
 672   1              eeprom_en = 0xaa;
 673   1              IapEraseSector(MenuItem[menu_id].eeprom_add);
C51 COMPILER V9.00   LED_DISPLAY                                                           05/12/2016 11:15:08 PAGE 12  

 674   1              eeprom_en = 0;
 675   1              switch(menu_id)
 676   1                      {
 677   2                              case MENU_ID_00000:
 678   2                                      progbyte = (unsigned char *)&public_val.Disp_Dz_00000[0];
 679   2                              break;                  
 680   2                              case MENU_ID_10101:
 681   2                                      progbyte = (unsigned char *)&public_val.Disp_Dz_10101[0];
 682   2                              break;
 683   2                              case MENU_ID_10102:
 684   2                                      progbyte = (unsigned char *)&public_val.Disp_Dz_10102[0];
 685   2                              break;
 686   2                              case MENU_ID_10103:
 687   2                                      progbyte = (unsigned char *)&public_val.Disp_Dz_10103[0];
 688   2                              break;
 689   2                              case MENU_ID_10104:
 690   2                                      progbyte = (unsigned char *)&public_val.Disp_Dz_10104[0];
 691   2                              break;
 692   2                              case MENU_ID_20101:
 693   2                                      progbyte = (unsigned char *)&public_val.Disp_Dz_20101[0];
 694   2                              break;
 695   2                              break;                  
 696   2                      }
 697   1              progadd = MenuItem[menu_id].eeprom_add;
 698   1              for(i = 0; i < MenuItem[menu_id].MenuItem_Max + 1; i++)
 699   1                      {
 700   2                              //SendData(*(progbyte));
 701   2                              eeprom_en = 0xaa;
 702   2                              IapProgramByte(progadd,*(progbyte));
 703   2                              readbyte = IapReadByte(progadd);
 704   2                              if(readbyte != *progbyte)
 705   2                                      public_val.Err_Flag |= ERR_NUM_EEP_ERR; //写EERPOM错误
 706   2                              progbyte++;
 707   2                              progadd++;
 708   2                              //SendData(*(progbyte));
 709   2                              IapProgramByte(progadd,*(progbyte));
 710   2                              readbyte = IapReadByte(progadd);
 711   2                              if(readbyte != *progbyte)
 712   2                                      public_val.Err_Flag |= ERR_NUM_EEP_ERR;
 713   2                              progbyte++;
 714   2                              progadd++;
 715   2                              eeprom_en = 0;
 716   2                      }
 717   1              update_menu_to_com();
 718   1              write_param_flag = 1;    // 更新下位机参数
 719   1                              
 720   1      }
 721          
 722          #if 0
              //完成对版本号的存储
              void func_ver_update(void)
              {
                      char progbyte;
                      eeprom_en = 0xaa;
                      IapEraseSector(EEPROM_DRIVE_TYPE);
                      eeprom_en = 0;
                      progbyte = (unsigned char)(public_val.drive_type >> 8);
                      eeprom_en = 0xaa;
                      IapProgramByte(EEPROM_DRIVE_TYPE,progbyte);
                      progbyte = (unsigned char)(public_val.drive_type & 0xff);
                      IapProgramByte(EEPROM_DRIVE_TYPE + 1,progbyte);
                      progbyte = public_val.drive_indx;
C51 COMPILER V9.00   LED_DISPLAY                                                           05/12/2016 11:15:08 PAGE 13  

                      
                      IapProgramByte(EEPROM_DRIVE_INDX,progbyte);
                      eeprom_en = 0;
              }
              
              //完成对菜单配置的存储
              void func_cfg_update(int menu_id)
              {
              unsigned char i,progbyte;
              unsigned int progadd;
                      eeprom_en = 0xaa;
                      IapEraseSector(MenuItem[menu_id].eeprom_cfg_add);
                      progadd = MenuItem[menu_id].eeprom_cfg_add;
                      progbyte = (unsigned char)(*(MenuItem[menu_id].com_max_item));
                      IapProgramByte(progadd++,progbyte);
                      
                      for(i = 0; i < MenuItem[menu_id].MenuItem_Max; i++)
                              {
                                      progbyte = (unsigned char)(MenuItem[menu_id].m_pcfg[i].m_max >> 8);
                                      IapProgramByte(progadd++,progbyte);
                                      progbyte = (unsigned char)(MenuItem[menu_id].m_pcfg[i].m_max & 0xff);
                                      IapProgramByte(progadd++,progbyte);
                                      progbyte = (unsigned char)(MenuItem[menu_id].m_pcfg[i].m_min >> 8);
                                      IapProgramByte(progadd++,progbyte);
                                      progbyte = (unsigned char)(MenuItem[menu_id].m_pcfg[i].m_min & 0xff);
                                      IapProgramByte(progadd++,progbyte);
                                      progbyte = (unsigned char)(MenuItem[menu_id].m_pcfg[i].ext_property);
                                      IapProgramByte(progadd++,progbyte);
                              }
                      eeprom_en = 0;
              }
              
              #endif
 769          
 770          /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 771          名称:   void LEDDisplay(char Key,char UpdateState)
 772          功能：  显示运行程序
 773          参数：  无
 774          返回值：无
 775          ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
 776          
 777          
 778          /* 测试模式内容显示 */
 779          void test_set_display(char test_mode)
 780          {
 781   1              switch (test_mode)
 782   1              {
 783   2                      case 0:
 784   2                              LEDShowFlashString(" F--0",0);                  
 785   2                              break;
 786   2                      case 1:
 787   2                              LEDShowFlashString(" F--1",0);
 788   2                              break;
 789   2                      case 2:
 790   2                              LEDShowFlashString(" F--2",0);
 791   2                              break;                  
 792   2                      case 3:
 793   2                              LEDShowFlashString(" F--3",0);
 794   2                              break;  
 795   2                      case 4:
 796   2                              LEDShowFlashString(" F--4",0);
 797   2                              break;                          
C51 COMPILER V9.00   LED_DISPLAY                                                           05/12/2016 11:15:08 PAGE 14  

 798   2                      case 5:
 799   2                              LEDShowFlashString(" F--5",0);
 800   2                              break;                          
 801   2                      default:
 802   2                              break;
 803   2              }       
 804   1      }
 805          
 806          
 807          
 808          void LEDDisplay(void)
 809          {
 810   1          char TempCountB,TempDataB,TempValue,i,TempB;
 811   1          static xdata char Bell_flag = 0,zc_key_flag = 0;
 812   1          static xdata unsigned int UpdateCountB,TempCount,flash_flag = 0;    
 813   1              static xdata long DisplayValueTemp;
 814   1              
 815   1              //static xdata char Key_Val = 0,Pr_Key_Val = 0;
 816   1              //static xdata char old_key = 0;
 817   1              static xdata int Key_Val = 0,Pr_Key_Val = 0, old_key = 0;
 818   1      
 819   1              static xdata char UpdateState = 0;
 820   1      
 821   1              static xdata int Read_key_dely = 0,Read_key_dely_2 = 0,long_count = 0,long_input_flag = 0;
 822   1              static xdata int Read_key_dely_3 = 0,No_key_delay = 0;
 823   1              static xdata int Main_adj_key_delay = 0,Main_disp_other = 0;
 824   1              static xdata int edit_menu_id = 0;
 825   1              static xdata int bell_delay;
 826   1              static xdata int long_key_count = 0,long_key_step = 1,pr_long_input_flag;
 827   1              static xdata char war_bell_step = 0;
 828   1              static xdata int war_bell_delay = 0;
 829   1      
 830   1              static xdata char test_key_cnt = 0;   /* 主界面下选择键连按计数 added by james for v19407 */
 831   1              //static xdata char learn_key_cnt = 0; 
 832   1      
 833   1              int temp_max;   
 834   1              int iBellOnTime, iBellOffTime;
 835   1      
 836   1              static xdata unsigned int dj_key_dely = 0,dj_key_step = 0;
 837   1              //ADD by yq
 838   1              xdata char lcd_disp_buf[50*2] = {0};
 839   1              xdata unsigned char  cMenuSn;
 840   1              xdata int iLen=0,iCount=0,iTatol;
 841   1              MENU_SHOW *pLCDDataValue;
 842   1              xdata unsigned char  cLcd_data_buf[6]={0},cLcd_len_data_buf[6]={0},cLcd_count_data_buf[6]={0};
 843   1              
 844   1              
 845   1              unKey.u_bit.K1 = P24;
 846   1              unKey.u_bit.K2 = P23;
 847   1              unKey.u_bit.K3 = P22;
 848   1              unKey.u_bit.K4 = P21;
 849   1              
 850   1              unKey.u_bit.IO1 = P20;
 851   1              unKey.u_bit.IO2 = P35;
 852   1              unKey.u_bit.IO3 = P33;
 853   1              unKey.u_bit.IO4 = P32;
 854   1              unKey.u_bit.IO5 = P26;
 855   1              unKey.u_bit.IO6 = P27;
 856   1              unKey.u_bit.IO7 = P12;
 857   1              unKey.u_bit.IO8 = P13;
 858   1              unKey.u_bit.IO9 = P16;
 859   1      
C51 COMPILER V9.00   LED_DISPLAY                                                           05/12/2016 11:15:08 PAGE 15  

 860   1              unKey.u_bit.RED = P17;
 861   1              unKey.u_bit.GREEN = P54;
 862   1              unKey.u_bit.BLUE = P55; 
 863   1      
 864   1              Key_Val = (int)unKey.all; 
 865   1              
 866   1              //Key_Val = (P2 >> 1) & 0x0f;
 867   1              //Key_Val |= 0xf0;
 868   1              if(Key_Val != old_key) //有按键
 869   1              {
 870   2                      No_key_delay = public_val.ms_timer;
 871   2                      
 872   2                      if(!long_input_flag)
 873   2                      {
 874   3                              bell_delay = public_val.ms_timer;
 875   3                              Bell_flag |= 0x01;
 876   3                      }
 877   2                      else
 878   2                      {
 879   3                              Bell_flag &= 0xfe;
 880   3                      }
 881   2                      
 882   2                      if( (public_val.ms_timer - Read_key_dely_2) > KEY_DOU_DELY)
 883   2                      {
 884   3                              old_key = Key_Val;
 885   3                              Read_key_dely = public_val.ms_timer;
 886   3                              long_count = 0;
 887   3                              long_input_flag = 0;
 888   3                              long_key_step = 1;
 889   3                      }
 890   2                      else
 891   2                      {
 892   3                              Key_Val = 0;
 893   3                      }
 894   2                      
 895   2              }
 896   1              else
 897   1              {
 898   2                      if( (public_val.ms_timer - bell_delay) > BELL_ON_DELY)
 899   2                      {
 900   3                              Bell_flag &= 0xfe;
 901   3                      }
 902   2      
 903   2                      if( (public_val.ms_timer - No_key_delay) > NO_KEY_RETURN_MAIN)
 904   2                      {
 905   3                              No_key_delay = public_val.ms_timer;
 906   3                              
 907   3                              //if(edit_menu_id == MENU_ID_00000)
 908   3                              if ((edit_menu_id == MENU_ID_00000) && (DisplayState != ST_LEARN))
 909   3                              {
 910   4                                      DisplayState = ST_MAIN;
 911   4                                      Main_disp_other = 0;    /* added by james for v19407 */
 912   4                              }
 913   3                      }
 914   2                      
 915   2                      if( (public_val.ms_timer - Read_key_dely) > KEY_DOU_DELY)
 916   2                      {
 917   3                              Read_key_dely_2 = public_val.ms_timer;
 918   3                              
 919   3                              //if( ( (Key_Val&0xff) != 0xff) && (!long_input_flag) )
 920   3                              if( ( (Key_Val&0xffff) != 0xffff) && (!long_input_flag) )
 921   3                              {
C51 COMPILER V9.00   LED_DISPLAY                                                           05/12/2016 11:15:08 PAGE 16  

 922   4                                      long_count++;
 923   4                                      
 924   4                                      //if(long_count > 10)
 925   4                                      if(long_count > 100)   
 926   4                                      {                                                       
 927   5                                              long_input_flag = 1;
 928   5                                              long_key_step = 1;
 929   5                                              long_key_count = 0;
 930   5                                              Read_key_dely_3 = public_val.ms_timer; 
 931   5                                              long_count = 10;
 932   5                                      }
 933   4                              }                                       
 934   3                      }
 935   2                      else
 936   2                      {
 937   3                              Key_Val = 0;
 938   3      
 939   3                      }
 940   2              }
 941   1              
 942   1              if(long_input_flag)  /* 长按 */
 943   1              {
 944   2                      if(public_val.ms_timer - Read_key_dely_3 > KEY_LONG_DELY)
 945   2                      {
 946   3                              long_key_count ++;
 947   3                              if(long_key_count > LONG_KEY_STEP_SWITCH)
 948   3                              {
 949   4                                      long_key_step = 10;
 950   4                              }
 951   3                              if(long_key_count)
 952   3                                      Read_key_dely_3 = public_val.ms_timer;
 953   3                              Pr_Key_Val = 0xFF;
 954   3                      }
 955   2              }
 956   1              
 957   1              if(Key_Val)
 958   1              {
 959   2                      if(Key_Val != Pr_Key_Val)
 960   2                      {
 961   3                              Pr_Key_Val = Key_Val;
 962   3                      }
 963   2                      else
 964   2                      {
 965   3                              Key_Val = 0;
 966   3                      }
 967   2              }
 968   1      
 969   1      
 970   1              /* 有按键则下发按键值和按键类型 */
 971   1                      
 972   1              if ((Key_Val == KEY_IO6) || (Key_Val == KEY_IO7) 
 973   1                      || (Key_Val == KEY_IO8))
 974   1              {
 975   2                      if(public_val.Lock_Flag && (Key_Val == KEY_IO7))
 976   2                              {
 977   3                                      public_val.Err_Flag = ERR_LOCK_SYS_ERR + public_val.Lock_Flag;  //锁机错误20
 978   3                              }
 979   2                      else
 980   2                              {
 981   3                                      write_key_flag = 1;   /* 有按键，需要写按键到主板 */
 982   3                                      
 983   3                                      gsKeyVal = Key_Val;
C51 COMPILER V9.00   LED_DISPLAY                                                           05/12/2016 11:15:08 PAGE 17  

 984   3                                      gcKeyType = KEY_SHORT_UP_FLAG;                          
 985   3                              }
 986   2      
 987   2              }
 988   1      
 989   1              //打胶按键单独处理。
 990   1              switch(dj_key_step)
 991   1                      {
 992   2                              case 0:
 993   2                                      if(!P14)
 994   2                                      {
 995   3                                              dj_key_step = 10;
 996   3                                              dj_key_dely = public_val.ms_timer;
 997   3                                      }
 998   2                              break;
 999   2                              case 10:
1000   2                                      if(!P14)
1001   2                                              {
1002   3                                                      if(public_val.ms_timer - dj_key_dely > 100)
1003   3                                                              {
1004   4                                                                      dj_key_step = 20;
1005   4                                                              }
1006   3                                              }
1007   2                                      else
1008   2                                              {
1009   3                                                      dj_key_step = 0;
1010   3                                              }
1011   2                              break;
1012   2                              case 20:
1013   2                                      if(P14)
1014   2                                              {
1015   3                                                      write_key_flag = 1;   /* 有按键，需要写按键到主板 */
1016   3                                                      gsKeyVal = KEY_DJ;
1017   3                                                      gcKeyType = KEY_SHORT_UP_FLAG;
1018   3                                                      dj_key_step = 0;
1019   3                                              }
1020   2                              break;
1021   2                      }
1022   1          switch(DisplayState)
1023   1              {
1024   2                  case ST_MAIN:   /* 主界面 */
1025   2                  {
1026   3                      switch(Key_Val)
1027   3                          {
1028   4                              case KEY_SEL:
1029   4      
1030   4                                              test_key_cnt = 0;
1031   4                                              //learn_key_cnt = 0;
1032   4      
1033   4                                              if(Main_disp_other == 0)
1034   4                                              {
1035   5                                          PasswordBuff[0] = '0';
1036   5                                          PasswordBuff[1] = '0';
1037   5                                          PasswordBuff[2] = '0';
1038   5                                          PasswordBuff[3] = '0';  
1039   5                                          PasswordBuff[4] = '0';  
1040   5                                          DisplayBitNum = 4;
1041   5      
1042   5                                                      LEDShowFlashString(&PasswordBuff[0],0);
1043   5                                          DisplayState = ST_PASSWORD;
1044   5      
1045   5                                                      return;
C51 COMPILER V9.00   LED_DISPLAY                                                           05/12/2016 11:15:08 PAGE 18  

1046   5                                              }
1047   4                                              else
1048   4                                              {
1049   5                                                      if (qz_wait == 1)
1050   5                                                      {
1051   6                                                              qz_wait = 0;   // 清等待状态
1052   6      
1053   6                                                              war_bell_step = 0;  // 清除蜂鸣器响声
1054   6                                                              cPauseBell = 0;                                                 
1055   6                                                      }
1056   5                                                      
1057   5                                                      Main_disp_other = 0;
1058   5                                              }
1059   4                                                                                      
1060   4                                              
1061   4                                  break;      
1062   4                                              
1063   4                              case KEY_REDUCE:         //减号
1064   4                              
1065   4                                              test_key_cnt = 0;
1066   4                                              //learn_key_cnt = 0;
1067   4                                              
1068   4                                              if (long_input_flag && (Main_disp_other == 0))
1069   4                                              {
1070   5                                                      if(public_val.work_count_user != public_val.work_count)
1071   5                                                              {
1072   6                                                                      public_val.work_count_user = public_val.work_count;
1073   6                                                                      write_clear_cnt_flag = 1;    /* 发送命令至主板清除开机后计数 */
1074   6                                                                      save_user_count();
1075   6                                                              }
1076   5                                              }                                       
1077   4      
1078   4                                              if (speed_mode == 1)  //高速
1079   4                                              {
1080   5                                                      write_speed_mode_flag = 1;  
1081   5                                                      speed_mode = 0;   //切到低速
1082   5                                              }
1083   4                                      
1084   4                                              break;  
1085   4                                              
1086   4                              case KEY_INCREASE:       //加号
1087   4      
1088   4                                              test_key_cnt = 0;
1089   4                                              
1090   4                                              Main_adj_key_delay = public_val.ms_timer;                                       
1091   4                                              Main_disp_other = 5;
1092   4                                              if (speed_mode == 0)  //低速
1093   4                                              {
1094   5                                                      write_speed_mode_flag = 1;  
1095   5                                                      speed_mode = 1;  //切到高速
1096   5                                              }
1097   4      #if 0
                                                      if (Main_disp_other == 0)
                                                      {
                                                              /* 进入参数菜单 */
                                                          pMenu = pItem[0].m_pcfg;    // 指向数据                             
                                                              now_menu.menu_id = 0;
                                                              now_menu.par_id = 0;
                                                              now_menu.event_flag = 1;
                                              DisplayItemNum  = 0;
              
                                                              //DisplayMenuTotal = Menu_Number[0];
C51 COMPILER V9.00   LED_DISPLAY                                                           05/12/2016 11:15:08 PAGE 19  

                                                              DisplayMenuTotal = Menu0_Number;
                                                              if(DisplayMenuTotal > 0)
                                                      DisplayState=ST_MENU;                                                           //进入相应菜单  
                                          return;
                                                      }
              #endif                                          
1114   4                                                                                      
1115   4                                              break;  
1116   4      
1117   4                              case KEY_GREEN:          //纸长
1118   4      
1119   4                                              test_key_cnt = 0;
1120   4                                              
1121   4                                              if (Main_disp_other == 0)
1122   4                                              {
1123   5                                                      /* 进入参数菜单 */
1124   5                                                  pMenu = pItem[0].m_pcfg;    // 指向数据     
1125   5                                                      now_menu.menu_id = 0;
1126   5                                                      now_menu.par_id = 0;
1127   5                                                      now_menu.event_flag = 1;
1128   5                                      DisplayItemNum  = 0;
1129   5                                                      zc_key_flag = 1;
1130   5                                                      //DisplayMenuTotal = Menu_Number[0];
1131   5                                                  edit_menu_id = 0;
1132   5                                                      DisplayMenuTotal = pItem[edit_menu_id].MenuItem_Max;;
1133   5                                                      if(DisplayMenuTotal > 0)
1134   5                                              DisplayState=ST_MENU;                                                           //进入相应菜单                                                  
1135   5                                  return;
1136   5                                              }
1137   4                                                                                      
1138   4                                              break;  
1139   4      
1140   4                              case KEY_BLUE:           //捆数
1141   4      
1142   4                                              test_key_cnt = 0;
1143   4                                              
1144   4                                              if (Main_disp_other == 0)
1145   4                                              {
1146   5                                                      /* 进入参数菜单 */
1147   5                                                  pMenu = pItem[0].m_pcfg;    // 指向数据                             
1148   5                                                      now_menu.menu_id = 0;
1149   5                                                      now_menu.par_id = 1;
1150   5                                                      now_menu.event_flag = 1;
1151   5                                      DisplayItemNum  = 1;                    
1152   5                                                      zc_key_flag = 1;
1153   5                                                      //DisplayMenuTotal = Menu_Number[0];
1154   5                                                  edit_menu_id = 0;
1155   5                                                      DisplayMenuTotal = pItem[edit_menu_id].MenuItem_Max;;
1156   5                                                      if(DisplayMenuTotal > 0)
1157   5                                              DisplayState=ST_MENU;                                                           //进入相应菜单  
1158   5                                                      
1159   5                                  return;
1160   5                                              }
1161   4                                                                                      
1162   4                                              break;  
1163   4      
1164   4                                              
1165   4                              case KEY_ENT:   //查看程序版本
1166   4      
1167   4                                              if (qz_wait == 0)  //不是切纸等待状态
1168   4                                              {
1169   5                                                      //learn_key_cnt = 0;
C51 COMPILER V9.00   LED_DISPLAY                                                           05/12/2016 11:15:08 PAGE 20  

1170   5      
1171   5                                                      if (long_input_flag)
1172   5                                                      {                                               
1173   6                                                              if (test_key_cnt < TEST_MODE_CNT)
1174   6                                                              {
1175   7                                                                      test_key_cnt++;
1176   7                                                              }
1177   6                                                      }
1178   5                                                      else
1179   5                                                      {
1180   6                                                              test_key_cnt = 0;
1181   6                                                      }
1182   5                                                      
1183   5                                                      Main_adj_key_delay = public_val.ms_timer;
1184   5                                                      Main_disp_other = 2;
1185   5                                              } 
1186   4                                              else   // 切纸等待状态
1187   4                                              {
1188   5                                                      write_key_flag = 1;   /* 有按键，需要写按键到主板 */
1189   5      
1190   5                                                      // 下发切纸命令
1191   5                                                      gsKeyVal = KEY_IO3;
1192   5                                                      gcKeyType = KEY_SHORT_UP_FLAG; 
1193   5                                                      
1194   5                                                      Main_disp_other = 0;  // 返回显示筒数
1195   5                                                      qz_wait = 0;   // 清等待状态
1196   5      
1197   5                                                      war_bell_step = 0;  // 清除蜂鸣器响声
1198   5                                                      cPauseBell = 0;
1199   5                                                      
1200   5                                              }
1201   4                                              //add by yq;
1202   4                                              
1203   4                                              
1204   4                                              break;          
1205   4      
1206   4                                      case KEY_IO3:   // 切纸
1207   4      
1208   4                                              if (qz_wait == 0)  //未等待切纸
1209   4                                              {
1210   5                                                      write_warning_flag = 1;   // 下发报警消息
1211   5                                                      
1212   5                                                      //进入切纸等待
1213   5                                                      Main_disp_other = 4;
1214   5                                                      qz_wait = 1;                                            
1215   5                                              }
1216   4                                              
1217   4                                              break;
1218   4                                              
1219   4                          }
1220   3              
1221   3                              if(Main_disp_other == 0)  /* 返回主界面 */
1222   3                              {
1223   4                                      TempCount = main_menu_cfg[0].m_rate;  
1224   4                                      TempDataB = DisplayItemNum;
1225   4                              
1226   4                                      if(!public_val.Err_Flag)                                //无报错
1227   4                                      {
1228   5                                              if(!public_val.Work_Pause_Flag)     /* 无暂停，刷新显示当前已洗饼数 */
1229   5                                              {
1230   6                                                      if(public_val.Bell_Flag == YES)   /* 蜂鸣器长暂停响 added for v19416 */
1231   6                                                      {
C51 COMPILER V9.00   LED_DISPLAY                                                           05/12/2016 11:15:08 PAGE 21  

1232   7                                                              cPauseBell = 1;
1233   7                                                              if(!war_bell_step) war_bell_step = 1;
1234   7                                                      }
1235   6                                                      else
1236   6                                                      {
1237   7                                                              Bell_flag &= 0xfd;
1238   7                                                      }
1239   6                                                      public_val.main_disp_val = public_val.work_count - public_val.work_count_user;
1240   6                                                      DisplayValueTemp = (long)public_val.main_disp_val; 
1241   6                                                      TempValue=DataToStr(&DisplayValueTemp,
1242   6                                                                          INT32_SIZE,
1243   6                                                                                              5,
1244   6                                                                                              0,
1245   6                                                                                              DisplayBuff,0,TY_D );           
1246   6                                                      LED_ShowNumber(&DisplayBuff[0],0);
1247   6                                                      
1248   6                                                      //Bell_flag &= 0xfd;   
1249   6      
1250   6                                                      
1251   6                                              }
1252   5                                              else
1253   5                                              {
1254   6                                                      LEDShowFlashString("P--",0);                                            //显示项目名称内容
1255   6                                                      DisplayValueTemp = public_val.Work_Pause_Flag & 0x7F;
1256   6                                                      if(public_val.Work_Pause_Flag & 0x80)
1257   6                                                              {
1258   7                                                                      if(!war_bell_step) war_bell_step = 1;
1259   7                                                              }
1260   6                                                      TempValue=DataToStr(&DisplayValueTemp,
1261   6                                                                          INT32_SIZE,
1262   6                                                                                              5,
1263   6                                                                                              0,
1264   6                                                                                              DisplayBuff,0,TY_D );           
1265   6                                                      LED_ShowNumber(&DisplayBuff[3],3);      
1266   6      
1267   6                                                      cPauseBell = 1;
1268   6      
1269   6                                              }
1270   5                                      }
1271   4                                      else
1272   4                                      {
1273   5                              
1274   5                                              if ((public_val.Err_Flag == P_FINISH_LEARN1)
1275   5                                                      || (public_val.Err_Flag == P_FINISH_LEARN2)) 
1276   5                                              {
1277   6                                                      //学习完成也显示送纸计数
1278   6                                                      if(public_val.Bell_Flag == YES)   /* 蜂鸣器长暂停响 added for v19416 */
1279   6                                                      {
1280   7                                                              cPauseBell = 1;
1281   7                                                              if(!war_bell_step) war_bell_step = 1;
1282   7                                                      }
1283   6                                                      else
1284   6                                                      {
1285   7                                                              Bell_flag &= 0xfd;
1286   7                                                      }
1287   6                                                      
1288   6                                                      DisplayValueTemp = (long)public_val.main_disp_val; 
1289   6                                                      TempValue=DataToStr(&DisplayValueTemp,
1290   6                                                                          INT32_SIZE,
1291   6                                                                                              5,
1292   6                                                                                              0,
1293   6                                                                                              DisplayBuff,0,TY_D );           
C51 COMPILER V9.00   LED_DISPLAY                                                           05/12/2016 11:15:08 PAGE 22  

1294   6                                                      LED_ShowNumber(&DisplayBuff[0],0);
1295   6      
1296   6                                                      
1297   6                                              }
1298   5                                              else             // 正常报错                    
1299   5                                              {
1300   6                                                      LEDShowFlashString("E--",0);            /* modified by james at 2014-4-12 */
1301   6                                                      
1302   6                                                      if(!war_bell_step) 
1303   6                                                              war_bell_step = 1;
1304   6                                                      
1305   6                                                      DisplayValueTemp = public_val.Err_Flag;
1306   6                                                      TempValue=DataToStr(&DisplayValueTemp,
1307   6                                                                          INT32_SIZE,
1308   6                                                                                              5,
1309   6                                                                                              0,
1310   6                                                                                              DisplayBuff,0,TY_D );           
1311   6                                                      LED_ShowNumber(&DisplayBuff[3],3);              
1312   6      
1313   6                                                      cPauseBell = 0;
1314   6                                              }
1315   5                                      }
1316   4      
1317   4                                      if(l_stop_poll)                                                                                         //循环显示
1318   4                                      if(++CycShowCount > main_menu_cfg[0].m_time)                            //---------------周期计数器判断     
1319   4                                      {
1320   5                                          CycShowCount=0;
1321   5                                              DisplayItemNum++;
1322   5                                              TempCount = 0; 
1323   5                                      }
1324   4                              }
1325   3                              else if(Main_disp_other == 2)    /* 显示版本号 */
1326   3                              {
1327   4                                      DisplayValueTemp = public_val.version;
1328   4                                      //DisplayValueTemp = public_val.input_pass_mask;
1329   4                                      TempValue=DataToStr(&DisplayValueTemp,
1330   4                                                          INT32_SIZE,
1331   4                                                                              5,
1332   4                                                                              0,
1333   4                                                                              DisplayBuff,0,TY_D );           
1334   4                                      LED_ShowNumber(&DisplayBuff[0],0);      
1335   4                                      if( (public_val.ms_timer - Main_adj_key_delay) > MAIN_ADJ_DELAY)
1336   4                                      {
1337   5                                              Main_disp_other = 3;
1338   5                                      }
1339   4                              }
1340   3                              else if(Main_disp_other == 3)    /* 显示传感器等输入IO值 */
1341   3                              {
1342   4                                      DisplayValueTemp = (long)public_val.io_read;
1343   4                                      //DisplayValueTemp &= 0xff;
1344   4                                      DisplayValueTemp &= 0xffff;
1345   4                                      TempValue=DataToStr(&DisplayValueTemp,
1346   4                                                          INT32_SIZE,
1347   4                                                                              5,
1348   4                                                                              0,
1349   4                                                                              DisplayBuff,0,TY_D );           
1350   4                                      LED_ShowNumber(&DisplayBuff[0],0);      
1351   4                              }
1352   3                              else if (Main_disp_other == 4)    /* 切纸等待 */
1353   3                              {
1354   4                                      LEDShowFlashString("Q2---",0);
1355   4      
C51 COMPILER V9.00   LED_DISPLAY                                                           05/12/2016 11:15:08 PAGE 23  

1356   4                                      if(!war_bell_step) 
1357   4                                              war_bell_step = 1;                                              
1358   4      
1359   4                                      cPauseBell = 1;         
1360   4                              }
1361   3                              else if(Main_disp_other == 5)    /* 显示传感器等输入IO值 */
1362   3                              {
1363   4                                      DisplayValueTemp = (long)public_val.password_index_disp;
1364   4                                      //DisplayValueTemp = (long)(public_val.password_val[0] << 8) + public_val.password_val[1];
1365   4                                      //DisplayValueTemp &= 0xff;
1366   4                                      DisplayValueTemp &= 0xffff;
1367   4                                      TempValue=DataToStr(&DisplayValueTemp,
1368   4                                                          INT32_SIZE,
1369   4                                                                              5,
1370   4                                                                              0,
1371   4                                                                              DisplayBuff,0,TY_D );           
1372   4                                      LED_ShowNumber(&DisplayBuff[0],0);      
1373   4                              }
1374   3                  }
1375   2      
1376   2                      if (test_key_cnt == TEST_MODE_CNT)  /* 长按计数后进入测试参数设置界面 added by james for v19407 */
1377   2                      {
1378   3                              test_key_cnt = 0;
1379   3                              DisplayState = ST_TEST;
1380   3                              Main_disp_other = 4;
1381   3                              
1382   3                              test_set_display(test_mode);
1383   3                      }               
1384   2      
1385   2              #if 0
                              if (learn_key_cnt == LEARN_MODE_CNT)  /* 长按计数后进入测试参数设置界面 added by james for v19407 */
                              {
                                      learn_key_cnt = 0;
                                      DisplayState = ST_LEARN;
                                      Main_disp_other = 0;    
                                      
                                      LEDShowFlashString("P-- 0",0);
              
                                      public_val.Err_Flag = 0;   
              
                                      write_learn_mode_flag = 1;  
                              }       
                      #endif
1399   2                      
1400   2                  break;
1401   2      
1402   2      
1403   2                      case ST_PASSWORD://---------------------------------------------密码输入界面
1404   2      
1405   2                      switch(Key_Val)
1406   2                          {
1407   3                              case KEY_SEL:
1408   3                                  DisplayItemNum = 0;                 
1409   3                                              //DisplayItemNum0 = 0;
1410   3                                              //DisplayItemNum1 = 0;
1411   3                                  DisplayState = ST_MAIN;
1412   3                                  return;  
1413   3                                  break;      
1414   3                              case KEY_REDUCE:
1415   3                                      if(--DisplayBitNum < 0)
1416   3                                          DisplayBitNum=4;            
1417   3                                  break;      
C51 COMPILER V9.00   LED_DISPLAY                                                           05/12/2016 11:15:08 PAGE 24  

1418   3                              case KEY_INCREASE:
1419   3                                      if( ++PasswordBuff[DisplayBitNum] > '9')
1420   3                                          PasswordBuff[DisplayBitNum]='0';                    
1421   3                                  break;      
1422   3                              case KEY_ENT:
1423   3                                  for(TempCountB=1;TempCountB<MenuTotals;TempCountB++)
1424   3                                  {
1425   4                                      if(PasswordBuff[0]==pItem[TempCountB].m_pass[0])//
1426   4                                      if(PasswordBuff[1]==pItem[TempCountB].m_pass[1])//
1427   4                                      if(PasswordBuff[2]==pItem[TempCountB].m_pass[2])//
1428   4                                      if(PasswordBuff[3]==pItem[TempCountB].m_pass[3])//
1429   4                                      if(PasswordBuff[4]==pItem[TempCountB].m_pass[4])//密码符合要求
1430   4                                      {
1431   5                                              if(TempCountB == MENU_ID_10104)
1432   5                                                      {
1433   6                                                              if(  ((public_val.Disp_Dz_10103[10] == 0)     //密码6为空或者校验成功，允许进入10104
1434   6                                                                                      &&(public_val.Disp_Dz_10103[11] == 0))
1435   6                                                                                      ||(public_val.input_pass_mask & 0x20)
1436   6                                                                                      ||(public_val.Disp_Dz_10104[PASS_LOCK_COUNT - 1] == 0)
1437   6                                                                                 )
1438   6                                                                      {
1439   7                                                                              ;
1440   7                                                                      }
1441   6                                                                              else
1442   6                                                                                      return;
1443   6                                                      }
1444   5                                                              edit_menu_id = TempCountB; 
1445   5                                                          pMenu = pItem[TempCountB].m_pcfg;                                   
1446   5                                                              now_menu.menu_id = edit_menu_id;
1447   5                                                              now_menu.par_id = 0;
1448   5                                                              now_menu.event_flag = 1;
1449   5                                          DisplayItemNum  = 0;                                        
1450   5                                                              DisplayMenuTotal = pItem[edit_menu_id].MenuItem_Max;
1451   5                                                              if(DisplayMenuTotal > 0)
1452   5                                              DisplayState=ST_MENU;                                                           //进入相应菜单
1453   5                                                              //add by yq
1454   5                                                              if(DisplayMenuTotal > 20)
1455   5                                                                      DisplayMenuTotal = 20;
1456   5                                                              cMenuSn = 10;
1457   5                                          return;
1458   5                                      }                
1459   4                                  }
1460   3                                              return;
1461   3                                  break;      
1462   3                          }
1463   2                      if( flash_flag  && !long_input_flag  )                                                                                          //闪烁功能
1464   2                      {       
1465   3                          LEDClearChar(DisplayBitNum, 1);
1466   3                      }
1467   2                      else
1468   2                      {
1469   3                          LEDShowFlashString(&PasswordBuff[0], 0);            
1470   3                      }               
1471   2                  
1472   2                              break;
1473   2      
1474   2                      case ST_LEARN:
1475   2      
1476   2                              switch(Key_Val) 
1477   2                          {
1478   3                              case KEY_SEL:  // 选择键返回
1479   3                                      Main_disp_other = 0;
C51 COMPILER V9.00   LED_DISPLAY                                                           05/12/2016 11:15:08 PAGE 25  

1480   3                                              DisplayBitNum = 4;
1481   3                                              CycShowCount  = 0;
1482   3                                              now_menu.menu_id = 888;
1483   3                                              now_menu.event_flag = 1;
1484   3                                  DisplayItemNum = 0; 
1485   3                                  DisplayState   = ST_MAIN;                                                                                   //返回主界面
1486   3                                  
1487   3                                              war_bell_step = 0;  // 清除蜂鸣器响声
1488   3                                              cPauseBell = 0;
1489   3      
1490   3                                              return;
1491   3                                              
1492   3                                              break;  
1493   3                                              
1494   3                                      default:
1495   3                                              break;
1496   3                              }
1497   2      
1498   2                              if ((public_val.Err_Flag == P_FINISH_LEARN1)
1499   2                                      || (public_val.Err_Flag == P_FINISH_LEARN2))
1500   2                              {
1501   3                                      if (public_val.Err_Flag == P_FINISH_LEARN1)    // 学习完成
1502   3                                      {
1503   4                                              LEDShowFlashString("P-- 1",0);
1504   4      
1505   4                                              if(!war_bell_step) 
1506   4                                                      war_bell_step = 1;                                              
1507   4      
1508   4                                              cPauseBell = 1;                                         
1509   4                                      }
1510   3                                      else if (public_val.Err_Flag == P_FINISH_LEARN2)    // 学习完成
1511   3                                      {
1512   4                                              LEDShowFlashString("P-- 2",0);
1513   4      
1514   4                                              if(!war_bell_step) 
1515   4                                                      war_bell_step = 1;                                              
1516   4      
1517   4                                              cPauseBell = 1;                                         
1518   4                                      }
1519   3                              }       
1520   2                              else
1521   2                              {
1522   3                                      LEDShowFlashString("P-- 0",0);
1523   3                                      war_bell_step = 0;
1524   3                                      cPauseBell = 0; 
1525   3                              }
1526   2      
1527   2                              break;
1528   2      
1529   2                      case ST_TEST:        /* 测试参数设置界面响应 added by james for v19407 */
1530   2                              switch(Key_Val)
1531   2                          {
1532   3                              case KEY_SEL:
1533   3                                      Main_disp_other = 0;
1534   3                                              DisplayBitNum = 4;
1535   3                                              CycShowCount  = 0;
1536   3                                              now_menu.menu_id = 888;
1537   3                                              now_menu.event_flag = 1;
1538   3                                  DisplayItemNum = 0; 
1539   3                                  DisplayState   = ST_MAIN;                                                                                   //返回主界面
1540   3                                  break;      
1541   3      
C51 COMPILER V9.00   LED_DISPLAY                                                           05/12/2016 11:15:08 PAGE 26  

1542   3                                      case KEY_INCREASE:
1543   3                                              if (test_mode < 1)
1544   3                                              {
1545   4                                                      test_mode++;
1546   4      
1547   4                                                      write_test_mode_flag = 1;  /* 写测试模式到主板 */
1548   4                                              }
1549   3                                              test_set_display(test_mode);
1550   3                                              
1551   3                                              if (test_mode > 0)  /* 测试模式 */
1552   3                                              {
1553   4                                                      //ResetDoorForTest();
1554   4                                              }                                       
1555   3                                              break;
1556   3      
1557   3                                      case KEY_REDUCE:
1558   3                                              if (test_mode > 0)
1559   3                                              {
1560   4                                                      test_mode--;
1561   4      
1562   4                                                      write_test_mode_flag = 1;  /* 写测试模式到主板 */                                               
1563   4                                              }
1564   3                                              test_set_display(test_mode);                                    
1565   3                                              break;
1566   3      
1567   3                                      case KEY_IO7:  // 启动
1568   3                                              LEDShowFlashString("   11",0);
1569   3                                              break;
1570   3      
1571   3                                      case KEY_IO8:  // 停止
1572   3                                              LEDShowFlashString("   12",0);
1573   3                                              break;
1574   3      
1575   3                                      case KEY_RED:  // 收纸
1576   3                                              LEDShowFlashString("   13",0);
1577   3                                              break;
1578   3      
1579   3                                      case KEY_IO9:  // 发纸
1580   3                                              LEDShowFlashString("   14",0);
1581   3                                              break;
1582   3      
1583   3                                      case KEY_IO2:  // 退纸
1584   3                                              LEDShowFlashString("   15",0);
1585   3                                              break;
1586   3      
1587   3                                      case KEY_IO1:  // 进纸
1588   3                                              LEDShowFlashString("   16",0);
1589   3                                              break;
1590   3      
1591   3                                      case KEY_IO4:  // 下料
1592   3                                              LEDShowFlashString("   17",0);
1593   3                                              break;
1594   3      
1595   3                                      case KEY_IO5:  // 搓条
1596   3                                              LEDShowFlashString("   18",0);
1597   3                                              break;
1598   3      
1599   3                                      case KEY_IO6:  // 停止送纸
1600   3                                              LEDShowFlashString("   19",0);
1601   3                                              break;
1602   3      
1603   3                                      case KEY_IO3:  // 切纸
C51 COMPILER V9.00   LED_DISPLAY                                                           05/12/2016 11:15:08 PAGE 27  

1604   3                                              LEDShowFlashString("   20",0);
1605   3                                              break;
1606   3                                              
1607   3                                      case KEY_GREEN:  // 纸长
1608   3                                              LEDShowFlashString("   21",0);
1609   3                                              break;
1610   3      
1611   3                                      case KEY_BLUE:  // 捆数
1612   3                                              LEDShowFlashString("   22",0);
1613   3                                              break;
1614   3                                              
1615   3                                      default:
1616   3                                              break;
1617   3                              }
1618   2      
1619   2      
1620   2                      break;
1621   2      
1622   2                  case ST_MENU:                       /* 菜单数据查看 */
1623   2                  { 
1624   3                      switch(Key_Val)
1625   3                          {
1626   4                              case KEY_SEL:
1627   4                                      Main_disp_other = 0;
1628   4                                              DisplayBitNum = 4;
1629   4                                              CycShowCount  = 0;
1630   4                                              now_menu.menu_id = 888;
1631   4                                              now_menu.event_flag = 1;
1632   4                                  DisplayItemNum = 0; 
1633   4                                  DisplayState   = ST_MAIN;                                                                                   //返回主界面
1634   4                                              //DIS_OPTIONING=0;
1635   4                                  break;      
1636   4                              case KEY_REDUCE:
1637   4                                  if (DisplayItemNum-- == 0)
1638   4                                      DisplayItemNum = DisplayMenuTotal-1;    
1639   4                                              now_menu.par_id = DisplayItemNum;
1640   4                                              
1641   4                                              now_menu.par_id = DisplayItemNum;
1642   4                                              now_menu.event_flag = 1;
1643   4                                              //add by yq
1644   4                                              if (cMenuSn-- <= 10)
1645   4                                                      cMenuSn = 29;
1646   4                                  break;      
1647   4                              case KEY_INCREASE:
1648   4      
1649   4                                  if (++DisplayItemNum >= DisplayMenuTotal) 
1650   4                                      DisplayItemNum = 0;     
1651   4      
1652   4                                              now_menu.par_id = DisplayItemNum;
1653   4                                              now_menu.event_flag = 1;
1654   4                                              //add by yq
1655   4                                              if (cMenuSn++ >= 29)
1656   4                                                      cMenuSn = 10;
1657   4                                  break;      
1658   4                              case KEY_ENT:   
1659   4                                              if(
1660   4                                                      (now_menu.menu_id == MENU_ID_10104)  //设定数校验是否有权限修改
1661   4                                                      )
1662   4                                                      {
1663   5                                                              if(public_val.input_pass_mask & (1<<DisplayItemNum))
1664   5                                                                      {
1665   6                                                                              zc_key_flag = 5;
C51 COMPILER V9.00   LED_DISPLAY                                                           05/12/2016 11:15:08 PAGE 28  

1666   6                                                                      }
1667   5                                                      }
1668   4                                              else if(now_menu.menu_id == MENU_ID_10103)
1669   4                                                      {
1670   5                                                              if(public_val.input_pass_mask & (1<<(DisplayItemNum>>1)))
1671   5                                                                      {
1672   6                                                                              zc_key_flag = 5;
1673   6                                                                      }
1674   5                                                      }
1675   4                                              else
1676   4                                                      {
1677   5                                                              zc_key_flag = 5;
1678   5                                                      }
1679   4                                  break;                      
1680   4                          }        
1681   3      
1682   3                              //纸长按键特殊处理
1683   3                              //////////////////////////////////////////////////////////////////////////////////////
1684   3                              if (now_menu.menu_id == 0 && zc_key_flag)
1685   3                                      {
1686   4                                              zc_key_flag ++;
1687   4                                      }
1688   3      
1689   3                              if(zc_key_flag == 5)
1690   3                                      {
1691   4                                              zc_key_flag = 0;
1692   4                                          TempDataB = DisplayItemNum;
1693   4                                              if (TY_D == TY_B  || 
1694   4                                                      TY_D == TY_D  ||  
1695   4                                                      TY_D == TY_H)                                                                   //数值类
1696   4                                              {
1697   5                                                      DisplayBitNum = 4;
1698   5                                                      DataType=TY_D;
1699   5      
1700   5                                                      //锁机相关操作特殊处理
1701   5                                                      if( (now_menu.menu_id == MENU_ID_10103)                 //未解锁不显示密码
1702   5                                                          && (!(public_val.input_pass_mask & (1<<(DisplayItemNum>>1)))) //锁定状态下锁机参数全部显示为0
1703   5                                                              )
1704   5                                                              TempInputData = 0;
1705   5                                                  else
1706   5                                                      TempInputData = *(int *)pDataValue->m_data_vale;                        
1707   5      
1708   5                                                      DisplayState=ST_DATA_INPUT;                                                                             //进入参数输入界面
1709   5      
1710   5                                                      pDataValue=&pMenu[TempDataB];
1711   5                                                      DataType=TY_D;
1712   5                                                      TempValue=DataToStr(pDataValue->m_data_vale,
1713   5                                                                      INT16_SIZE,
1714   5                                                                                          DEFAUT_POSE,
1715   5                                                                                          DEFAUT_POT,
1716   5                                                                                          DisplayBuff,0,DataType);                            
1717   5                                                      
1718   5                                                      InputDataLen = DEFAUT_POSE+DEFAUT_POT;
1719   5                                                      //DisplayBitNum = InputDataLen - 1; 
1720   5                                                      PasswordBuff[0] = '0';
1721   5                                                      PasswordBuff[1] = '0';
1722   5                                                      switch(InputDataLen)
1723   5                                                      {       /*用于复制显示缓冲区数据*/                                  
1724   6                                                      case 3:
1725   6                                                              PasswordBuff[2]=DisplayBuff[TempValue];
1726   6                                                              if(PasswordBuff[2] == ' ') PasswordBuff[2] = '0';
1727   6                                                              PasswordBuff[3]=DisplayBuff[TempValue+1];
C51 COMPILER V9.00   LED_DISPLAY                                                           05/12/2016 11:15:08 PAGE 29  

1728   6                                                              if(PasswordBuff[3] == ' ') PasswordBuff[3] = '0';
1729   6                                                              PasswordBuff[4]=DisplayBuff[TempValue+2];                               
1730   6                                                          break;                      
1731   6                                                      case 2:
1732   6                                                              PasswordBuff[2]=' ';
1733   6                                                              PasswordBuff[3]=DisplayBuff[TempValue+1];
1734   6                                                              if(PasswordBuff[3] == ' ') PasswordBuff[3] = '0';
1735   6                                                              PasswordBuff[4]=DisplayBuff[TempValue+2];                               
1736   6                                                          break;              
1737   6                                                      case 1:
1738   6                                                              PasswordBuff[2]=' ';
1739   6                                                              PasswordBuff[3]=' ';
1740   6                                                              PasswordBuff[4]=DisplayBuff[TempValue+2];
1741   6                                                              break;                          
1742   6                                                      }
1743   5                                                      pr_long_input_flag = 0;
1744   5                                                      //pDataValue.m_max = 999;
1745   5                                                      //pDataValue.m_min = 0;
1746   5                                                      DisplayState=ST_DATA_INPUT;                                                                             //进入参数输入界面
1747   5                                              }       
1748   4                                      }
1749   3                              //////////////////////////////////////////////////////////////////////////////////////
1750   3                                      
1751   3                              if(TempCount > 0)           
1752   3                              {       
1753   4                                      TempCount-- ;
1754   4                                      break;          
1755   4                              }
1756   3                              TempCount = main_menu_cfg[0].m_rate;  
1757   3      
1758   3                          pDataValue=&pMenu[DisplayItemNum];  
1759   3      //密码校验成功，进入菜单显示内容，以及翻动参数显示内容
1760   3      #if MENU_PASS_ON
1761   3                              //锁机相关操作特殊处理
1762   3                              if( (now_menu.menu_id == MENU_ID_10103)                 //未解锁不显示密码
1763   3                                  && (!(public_val.input_pass_mask & (1<<(DisplayItemNum>>1)))) //锁定状态下锁机参数全部显示为0
1764   3                                      )
1765   3                                      TempInputData = 0;
1766   3                          else
1767   3      #endif                          
1768   3                              TempInputData = *(int *)pDataValue->m_data_vale;                        
1769   3      
1770   3                              LEDShowCaption(DisplayItemNum);
1771   3      
1772   3                              TempValue=DataToStr(&TempInputData,   //pDataValue->m_data_vale
1773   3                                                  INT32_SIZE,      //pDataValue->m_size,
1774   3                                                                      DEFAUT_POSE,
1775   3                                                                      DEFAUT_POT,
1776   3                                                                      DisplayBuff,0,TY_D );           
1777   3                              LED_ShowNumber(&DisplayBuff[TempValue],2);
1778   3                  }
1779   2                  break;
1780   2      
1781   2                  case ST_DATA_INPUT: /* 数据输入画面 */
1782   2                  {
1783   3                      switch(Key_Val)
1784   3                          {
1785   4                              case KEY_SEL:   
1786   4                                              if (now_menu.menu_id == 0)
1787   4                                                      {
1788   5                                                      Main_disp_other = 0;
1789   5                                                              DisplayBitNum = 4;
C51 COMPILER V9.00   LED_DISPLAY                                                           05/12/2016 11:15:08 PAGE 30  

1790   5                                                              CycShowCount  = 0;
1791   5                                                              now_menu.menu_id = 888;
1792   5                                                              now_menu.event_flag = 1;
1793   5                                                  DisplayItemNum = 0; 
1794   5                                                  DisplayState   = ST_MAIN;                                                                                   //返回主界面
1795   5                                                      }
1796   4                                              else
1797   4                                              DisplayState = ST_MENU;
1798   4                                  break;      
1799   4                              case KEY_REDUCE: //减少
1800   4                                      if(pMenu[DisplayItemNum].ext_property & 0x01)
1801   4                                              {
1802   5                                                      ;
1803   5                                              }
1804   4                                      else
1805   4                                              {
1806   5                                                              TempInputData-=long_key_step;
1807   5                                                              if(TempInputData<pDataValue->m_min) //
1808   5                                                                      TempInputData = pDataValue->m_min; //pDataValue->m_min;
1809   5                                                      }
1810   4                                  break;      
1811   4                              case KEY_INCREASE: //增加
1812   4                                      if(pMenu[DisplayItemNum].ext_property & 0x01)
1813   4                                              {
1814   5                                                              ;
1815   5                                              }
1816   4                                      else
1817   4                                              {
1818   5                                                              TempInputData+=long_key_step;
1819   5                                                              temp_max = pDataValue->m_max;
1820   5                                                              if(TempInputData>temp_max) // temp_max
1821   5                                                                      TempInputData=temp_max;
1822   5                                                      }
1823   4                                  break;      
1824   4                              case KEY_ENT:
1825   4                                      if(!long_input_flag)
1826   4                                      {                       
1827   5                                                      TempInputData=StrToData(PasswordBuff,5,DataType);
1828   5                                                      if(TempInputData <= pDataValue->m_max && TempInputData >= pDataValue->m_min)
1829   5                                                      {
1830   6                                                      switch(INT16_SIZE)
1831   6                                                          {
1832   7                                                          case INT32_SIZE:
1833   7                                                              *(long *)pDataValue->m_data_vale = TempInputData;
1834   7                                                              break;
1835   7                                                          case INT16_SIZE:
1836   7                                                              *(int *)pDataValue->m_data_vale = (int)TempInputData;
1837   7                                                              break;                  
1838   7                                                          case INT8_SIZE:
1839   7                                                              *(char *)pDataValue->m_data_vale = (char)TempInputData;
1840   7                                                              break;                  
1841   7                                                              }       
1842   6                                                              if(PasswordBuff[2] == '0')
1843   6                                                                      {
1844   7                                                                              PasswordBuff[2] = ' ';
1845   7                                                                              if(PasswordBuff[3] == '0') PasswordBuff[3] = ' ';
1846   7                                                                      }
1847   6                                                              LED_ShowNumber(&PasswordBuff[2],2);
1848   6      
1849   6      #if MENU_PASS_ON
1850   6                                                              //修改操作，校对密码是否与保存的一致
1851   6                                                              if( now_menu.menu_id == MENU_ID_10102)
C51 COMPILER V9.00   LED_DISPLAY                                                           05/12/2016 11:15:08 PAGE 31  

1852   6                                                                      {
1853   7                                                                              TempB = DisplayItemNum / 2;
1854   7                                                                              //for(TempB = 0; TempB < PASS_LOCK_COUNT; TempB++)
1855   7                                                                                      {
1856   8                                                                                              if( (public_val.Disp_Dz_10103[TempB * 2] == public_val.Disp_Dz_10102[TempB * 2])
1857   8                                                                                                      && (public_val.Disp_Dz_10103[TempB * 2 + 1] == public_val.Disp_Dz_10102[TempB * 2 + 1]) 
1858   8                                                                                                      )
1859   8                                                                                                      {
1860   9                                                                                                              public_val.input_pass_mask |= 1 << TempB;
1861   9                                                                                                              public_val.Disp_Dz_10104[TempB] = 0;
1862   9                                                                                                              for(i = 0; i < TempB; i ++)                             //此段以下的都清除
1863   9                                                                                                                      public_val.Disp_Dz_10104[i] = 0;
1864   9                                                                                                              func_menu_update(MENU_ID_10104);
1865   9                                                                                                      }
1866   8                                                                                      }
1867   7                                                                              
1868   7                                                                                      DisplayState = ST_MENU;;                                                                        
1869   7                                                                      }
1870   6                                                              else
1871   6      #endif
1872   6                                                                      func_menu_update(now_menu.menu_id);
1873   6                                                                              
1874   6      
1875   6                                                              /* 如果将倒数第2个参数改为1则全部恢复默认参数 added by james for v19407 */
1876   6                                                              /*if ((DisplayItemNum == PARM_DEFAULT)
1877   6                                                                      && (TempInputData == 1))
1878   6                                                              {
1879   6                                                                      for (i = 0; i < MENU_ID_00000_MAX_ITEM; i++)
1880   6                                                                      {
1881   6                                                                              public_val.menu_parm[i] = iDefaultParm[i];
1882   6                                                                      }
1883   6                                                              }*/
1884   6                                                              
1885   6                                                              
1886   6                                                      }
1887   5                                      }
1888   4      
1889   4                                              if (now_menu.menu_id == 0)
1890   4                                                      {
1891   5                                                      Main_disp_other = 0;
1892   5                                                              DisplayBitNum = 4;
1893   5                                                              CycShowCount  = 0;
1894   5                                                              now_menu.menu_id = 888;
1895   5                                                              now_menu.event_flag = 1;
1896   5                                                  DisplayItemNum = 0; 
1897   5                                                  DisplayState   = ST_MAIN;                                                                                   //返回主界面
1898   5                                                      }
1899   4                                              else
1900   4                                              DisplayState = ST_MENU;
1901   4                                              
1902   4                                  break;                      
1903   4                          }
1904   3      
1905   3                      if( flash_flag && !long_input_flag )  //闪烁功能
1906   3                      {       
1907   4                          LEDClearChar(DisplayBitNum,1);
1908   4                      }
1909   3                      else                    
1910   3                      {
1911   4                                              LEDShowCaption(DisplayItemNum);
1912   4                                      TempValue=DataToStr(&TempInputData,
1913   4                                                      INT32_SIZE,
C51 COMPILER V9.00   LED_DISPLAY                                                           05/12/2016 11:15:08 PAGE 32  

1914   4                                                                      5,
1915   4                                                                      0,
1916   4                                                                      DisplayBuff,0,TY_D );   
1917   4      
1918   4                                      PasswordBuff[2]=DisplayBuff[TempValue];
1919   4                                      if(PasswordBuff[2] == ' ') PasswordBuff[2] = '0';
1920   4                                      PasswordBuff[3]=DisplayBuff[TempValue+1];
1921   4                                      if(PasswordBuff[3] == ' ') PasswordBuff[3] = '0';
1922   4                                      PasswordBuff[4]=DisplayBuff[TempValue+2];                                               
1923   4                                      LED_ShowNumber(&PasswordBuff[2],2);     
1924   4                                      
1925   4                      }
1926   3                  }   
1927   2                  break;      
1928   2                      
1929   2                      case ST_DISP_ERR:
1930   2                      {
1931   3                              if(public_val.ms_timer - now_menu.err_dsip_delay > DISP_ERR_TIMER )
1932   3                              {
1933   4                                      DisplayState = now_menu.chang_next_step;
1934   4                              }
1935   3                              else
1936   3                              {
1937   4                                      LEDShowFlashString("  Err",0);
1938   4                              }
1939   3                      }
1940   2                      break;
1941   2                      
1942   2                      default :
1943   2                      DisplayState = ST_MAIN;
1944   2                              //DIS_OPTIONING=0;
1945   2                  break;                              
1946   2                      
1947   2              }
1948   1              
1949   1          if(LCDDisplayState != DisplayState )//各个界面静态显示
1950   1              {
1951   2                      xdata char* paperLen = "纸长";
1952   2                      xdata char* paperNum = "捆数";
1953   2                      xdata char* paperTatol = "总数";
1954   2                      
1955   2                      
1956   2                      LCDDisplayState = DisplayState;
1957   2                      switch(LCDDisplayState)
1958   2                      {
1959   3                              case ST_MAIN:
1960   3                              {
1961   4                                      ClearLCDScreen(0);
1962   4                                      //GpuSend("SPG(52);\r\n");      
1963   4                                      GpuSend("W8DF(5,3,'111662226633333');\r\n");
1964   4                                      DELAY_US(UART2_DELAY);
1965   4                                      GpuSend("W8MU(0,0,80,80,1,2);\r\n");
1966   4                                      DELAY_US(UART2_DELAY);
1967   4                                      GpuSend("W8UE(1);\r\n");//查看串口发送的数据是正确的，必须两条才能起作用。液晶屏BUG
1968   4                                      GpuSend("W8UE(1);\r\n");
1969   4                                      DELAY_US(UART2_DELAY);
1970   4                                      sprintf(lcd_disp_buf,"DS64(1,2,'%s',15);\r\n",paperLen);
1971   4                                      GpuSend(lcd_disp_buf);
1972   4                                      DELAY_US(UART2_DELAY);
1973   4                                      GpuSend("SXY(0,0)\r\n");
1974   4                                      GpuSend("W8UE(3);\r\n");
1975   4                                      DELAY_US(UART2_DELAY);
C51 COMPILER V9.00   LED_DISPLAY                                                           05/12/2016 11:15:08 PAGE 33  

1976   4                                      sprintf(lcd_disp_buf,"DS64(1,2,'%s',15);\r\n",paperNum);
1977   4                                      GpuSend(lcd_disp_buf);
1978   4                                      GpuSend("SXY(0,0)\r\n");
1979   4                                      DELAY_US(UART2_DELAY);
1980   4                                      GpuSend("W8UE(4);\r\n");
1981   4                                      sprintf(lcd_disp_buf,"DS64(1,1,'%s',15);\r\n",paperTatol);
1982   4                                      GpuSend(lcd_disp_buf);
1983   4                                      GpuSend("SXY(0,0)\r\n");
1984   4                                      DELAY_US(UART2_DELAY);
1985   4                              }       
1986   3                                      break;
1987   3                              case ST_PASSWORD:
1988   3                                      //GpuSend("SPG(53);\r\n");
1989   3      /*                              GpuSend("W8DF(5,3,'111662226633333');\r\n");
1990   3                                      DELAY_US(UART2_DELAY);
1991   3                                      GpuSend("W8MU(0,0,80,80,1,2);\r\n");
1992   3                                      DELAY_US(UART2_DELAY);
1993   3                                      GpuSend("SBC(51);\r\n");
1994   3                                      GpuSend("SBC(51);\r\n");
1995   3                                      DELAY_US(UART2_DELAY);
1996   3                                      GpuSend("DS64(1,7,'纸长',15);\r\n");
1997   3                                      DELAY_US(UART2_DELAY);
1998   3                                      GpuSend("SBC(52);\r\n");
1999   3                                      DELAY_US(UART2_DELAY);
2000   3                                      GpuSend("DS64(1,90,'捆数',15);\r\n");
2001   3                                      GpuSend("SBC(53);\r\n");
2002   3                                      GpuSend("DS64(1,170,'总数',15);\r\n");
2003   3                                      GpuSend("SBC(0);\r\n");
2004   3      */                              
2005   3                                      ClearLCDScreen(0);
2006   3                                      DELAY_US(UART2_DELAY);          
2007   3                                      GpuSend("DS48(1,86,'请输入密码:',15);\r\n");
2008   3                                      DELAY_US(UART2_DELAY);
2009   3                                      
2010   3                                      break;
2011   3                              case ST_MENU ://--参数查看画面
2012   3                                      ClearLCDScreen(0);
2013   3                                      if(now_menu.menu_id == 0 && now_menu.par_id ==0)//纸长
2014   3                                      {
2015   4                                              
2016   4                                              sprintf(lcd_disp_buf,"DS64(1,1,'%s',15);\r\n","1-");
2017   4                                              GpuSend(lcd_disp_buf);
2018   4                                              DELAY_US(UART2_DELAY);
2019   4                                              
2020   4                                              sprintf(lcd_disp_buf,"DS64(1,100,'%s',15);\r\n",paperLen);
2021   4                                              GpuSend(lcd_disp_buf);
2022   4                                      }
2023   3                                      else if(now_menu.menu_id == 0 && now_menu.par_id ==1)//捆数
2024   3                                      {
2025   4                                              sprintf(lcd_disp_buf,"DS64(1,1,'%s',15);\r\n","2-");
2026   4                                              GpuSend(lcd_disp_buf);
2027   4                              
2028   4                                              sprintf(lcd_disp_buf,"DS64(1,100,'%s',15);\r\n",paperNum);
2029   4                                              GpuSend(lcd_disp_buf);
2030   4                                      }
2031   3                                      else
2032   3                                      {
2033   4                                              GpuSend("CLS(0);\r\n");
2034   4                                              MenuEditLook(now_menu.par_id + 10);                             
2035   4                                              pLCDDataValue=&pMenu[now_menu.par_id];
2036   4                                              TempInputData = *(int *)pLCDDataValue->m_data_vale;
2037   4                                              iCount = TempInputData;
C51 COMPILER V9.00   LED_DISPLAY                                                           05/12/2016 11:15:08 PAGE 34  

2038   4                                              //sprintf(cLcd_data_buf,"%d ,%d ,%d,%d",iCount,(int)DisplayMenuTotal,(int)now_menu.par_id,(int)Displa
             -yItemNum);
2039   4                                              sprintf(cLcd_data_buf,"%d",(int)TempInputData);
2040   4                                              sprintf(lcd_disp_buf,"DS48(30,190,'%s',1);\r\n",cLcd_data_buf);
2041   4                                              GpuSend(lcd_disp_buf);
2042   4                                              
2043   4                                      }
2044   3                                      
2045   3                                      break;
2046   3                              case ST_DATA_INPUT://--数据输入画面
2047   3                                      
2048   3                                      break;
2049   3                              case ST_CODE_INPUT://--代码输入画面
2050   3                                      GpuSend("CLS(0);\r\n");
2051   3                                      DELAY_US(UART2_DELAY);
2052   3                                      sprintf(lcd_disp_buf,"DS64(200,100,'%s',15);\r\n","代码输入画面");
2053   3                                      GpuSend(lcd_disp_buf);
2054   3                                      DELAY_US(UART2_DELAY);
2055   3                                      break;
2056   3                              case ST_Show_Err://--错误提示画面
2057   3                                      GpuSend("CLS(0);\r\n");
2058   3                                      DELAY_US(UART2_DELAY);
2059   3                                      sprintf(lcd_disp_buf,"DS64(200,100,'%s',15);\r\n","错误提示");
2060   3                                      GpuSend(lcd_disp_buf);
2061   3                                      break;
2062   3                              case ST_ADJ://--直接调参数画面
2063   3                                      GpuSend("CLS(0);\r\n");
2064   3                                      DELAY_US(UART2_DELAY);
2065   3                                      sprintf(lcd_disp_buf,"DS64(200,100,'%s',15);\r\n","直接调参数");
2066   3                                      GpuSend(lcd_disp_buf);
2067   3                              
2068   3                                      break;
2069   3                              case ST_WAIT_VER://--等待返校结果
2070   3                                      GpuSend("CLS(0);\r\n");
2071   3                                      DELAY_US(UART2_DELAY);
2072   3                                      sprintf(lcd_disp_buf,"DS64(200,100,'%s',15);\r\n","等待返校结果");
2073   3                                      GpuSend(lcd_disp_buf);
2074   3                                      break;
2075   3                              case ST_DISP_ERR://延时显示修改出错
2076   3                                      GpuSend("CLS(0);\r\n");
2077   3                                      DELAY_US(UART2_DELAY);
2078   3                                      sprintf(lcd_disp_buf,"DS64(200,100,'%s',15);\r\n","延时显示修改出错");
2079   3                                      GpuSend(lcd_disp_buf);
2080   3                                      break;
2081   3                              case ST_TEST://--测试参数设置  added by james for v19407
2082   3                                      GpuSend("CLS(0);\r\n");
2083   3                                      DELAY_US(UART2_DELAY);
2084   3                                      sprintf(lcd_disp_buf,"DS64(200,100,'%s',15);\r\n","测试参数设置");
2085   3                                      GpuSend(lcd_disp_buf);
2086   3                                      break;
2087   3                              case ST_LEARN://--学习模式
2088   3                                      GpuSend("CLS(0);\r\n");
2089   3                                      DELAY_US(UART2_DELAY);
2090   3                                      sprintf(lcd_disp_buf,"DS64(200,100,'%s',15);\r\n","学习模式");
2091   3                                      GpuSend(lcd_disp_buf);
2092   3                                      break;
2093   3                              case 0:
2094   3                              
2095   3                              break;
2096   3                      }
2097   2              }
2098   1              
C51 COMPILER V9.00   LED_DISPLAY                                                           05/12/2016 11:15:08 PAGE 35  

2099   1      
2100   1              //错误标志 低4位:主控板错误号 高4位:操作板错误
2101   1              if(public_val.Err_Flag)
2102   1              {
2103   2                      
2104   2                      if(public_val.ms_timer -  g_iFlashOldTime> 500)
2105   2                      {
2106   3                              static xdata errFlashFlag=0;
2107   3                              if(g_pcStatus)
2108   3                              {
2109   4                                      LCDChildDisplayState =0;
2110   4                                      LCDDisplayState = 0x00;
2111   4                                      g_pcStatus = 0;
2112   4                              }
2113   3                              GpuSend("W8UE(2);\r\n");
2114   3                              if(public_val.Err_Flag > 0xf)
2115   3                              {       
2116   4                                      sprintf(lcd_disp_buf,"DS24(3,20,'%s',15);\r\n","主控板错误：");
2117   4                                      GpuSend(lcd_disp_buf);
2118   4                              }
2119   3                              else
2120   3                              {
2121   4                                      sprintf(lcd_disp_buf,"DS24(3,20,'%s',15);\r\n","操作板错误：");
2122   4                                      GpuSend(lcd_disp_buf);
2123   4                              }
2124   3                              if(errFlashFlag)
2125   3                              {       
2126   4                                      sprintf(lcd_disp_buf,"DS48(5,80,'E--%d',1);\r\n",public_val.Err_Flag);
2127   4                                      GpuSend(lcd_disp_buf);
2128   4                              }
2129   3                              else
2130   3                              {
2131   4                                      sprintf(lcd_disp_buf,"DS48(5,80,'E--%d',15);\r\n",public_val.Err_Flag);
2132   4                                      GpuSend(lcd_disp_buf);
2133   4                              }
2134   3                              GpuSend("SXY(0);\r\n");
2135   3                              errFlashFlag = !errFlashFlag;
2136   3                      }
2137   2                      
2138   2                      
2139   2              }
2140   1              else if(g_pcStatus && LCDChildDisplayState == 0 && DisplayState == ST_MAIN)
2141   1              {
2142   2                      
2143   2                      if(public_val.ms_timer -  g_iFlashOldTime> 500)
2144   2                      {
2145   3                              static xdata staFlashFlag=0;
2146   3                              g_iFlashOldTime = public_val.ms_timer;
2147   3                              GpuSend("W8UE(2);\r\n");
2148   3                              if(staFlashFlag)
2149   3                              {       
2150   4                                      sprintf(lcd_disp_buf,"DS48(20,60,'%s',15);\r\n",g_pcStatus);
2151   4                                      GpuSend(lcd_disp_buf);                  
2152   4                              }
2153   3                              else
2154   3                              {
2155   4                                      sprintf(lcd_disp_buf,"DS48(20,60,'%s',1);\r\n",g_pcStatus);
2156   4                                      GpuSend(lcd_disp_buf);
2157   4                              }
2158   3                              GpuSend("SXY(0);\r\n");
2159   3                              staFlashFlag = !staFlashFlag;
2160   3                      }
C51 COMPILER V9.00   LED_DISPLAY                                                           05/12/2016 11:15:08 PAGE 36  

2161   2                      
2162   2                      
2163   2              }
2164   1              //按键状态显示
2165   1              if(LCDChildDisplayState != 8)
2166   1              switch(Key_Val)
2167   1              {
2168   2                      case 0xFFFF://无按键
2169   2                              break;
2170   2                      case KEY_K1: //选择
2171   2                              if(LCDChildDisplayState == 2  ||  LCDChildDisplayState == 3)
2172   2                                      LCDChildDisplayState = 0;
2173   2                              break;
2174   2                      case KEY_K4:           /* 确认 */
2175   2                              if(LCDChildDisplayState == 2 || LCDChildDisplayState == 3)//如果处于主界面的子界面有按键就返回
2176   2                              {                       
2177   3                                      LCDChildDisplayState =0;
2178   3                                      LCDDisplayState = 0x00;
2179   3                              }
2180   2                              else if(LCDChildDisplayState == 0 && DisplayState == ST_MAIN)
2181   2                                      LCDChildDisplayState = 1;
2182   2                                      
2183   2                              break;
2184   2                      case KEY_IO1:          /* 进纸 */
2185   2                              g_pcStatus = "进纸";
2186   2                              break;
2187   2                      case KEY_IO2:              /* 退纸 */
2188   2                              g_pcStatus = "退纸";
2189   2                              break;
2190   2                      case KEY_IO3:          /* 切纸 */
2191   2                              //g_pcStatus = "切纸";
2192   2                              LCDChildDisplayState =8;
2193   2                              break;
2194   2                      case KEY_IO4:              /* 下料 */
2195   2                              g_pcStatus = "下料";
2196   2                              break;
2197   2                      case KEY_IO5:          /* 搓条 */
2198   2                              g_pcStatus = "搓条";
2199   2                              break;
2200   2                      case KEY_IO6:          /* 停止送纸 */
2201   2                              g_pcStatus = "停纸";    
2202   2                              break;
2203   2                      case KEY_IO7:          /* 启动 */
2204   2                              g_pcStatus = "启动";
2205   2                              break;
2206   2                      case KEY_IO8:          /* 停止 */
2207   2                              g_pcStatus = "停止";
2208   2                              break;
2209   2                      case KEY_IO9:          /* 发纸 */
2210   2                              g_pcStatus = "发纸";
2211   2                              break;
2212   2                      case KEY_RED:          /* 收纸 */
2213   2                              g_pcStatus = "收纸";
2214   2                              break;
2215   2                      case KEY_GREEN:            /* 纸长 */
2216   2                              break;
2217   2                      case KEY_BLUE:         /* 捆数 */
2218   2                              break;
2219   2                      case KEY_DJ:        /* 打胶 */
2220   2                              g_pcStatus= "打胶";
2221   2                              break;
2222   2                      default:
C51 COMPILER V9.00   LED_DISPLAY                                                           05/12/2016 11:15:08 PAGE 37  

2223   2                              
2224   2                              break;
2225   2              }
2226   1              switch(DisplayState)//数据更新以及显示
2227   1              {
2228   2                      case ST_MAIN:
2229   2                              switch(LCDChildDisplayState)
2230   2                              {
2231   3                                      case 0:
2232   3                                              if(public_val.ms_timer - g_iInterfaceChangOldTime  > 500)
2233   3                                              //if(now_menu.menu_id == 0 && now_menu.par_id ==1)//纸长
2234   3                                              {
2235   4                                                      g_iInterfaceChangOldTime = public_val.ms_timer;
2236   4                                                      pLCDDataValue=pItem[0].m_pcfg;
2237   4                                                      iLen = *(int *)pLCDDataValue->m_data_vale;
2238   4                                                      sprintf(cLcd_len_data_buf,"%d",iLen);
2239   4                                              
2240   4                                                      //else if(now_menu.menu_id == 0 && now_menu.par_id ==0)//捆数
2241   4                                                                                              
2242   4                                                      pLCDDataValue=pItem[0].m_pcfg + 1;
2243   4                                                      iCount= *(int *)pLCDDataValue->m_data_vale;
2244   4                                                      sprintf(cLcd_count_data_buf,"%d",iCount);
2245   4                                                      GpuSend("W8UE(1);\r\n");
2246   4                                                      sprintf(lcd_disp_buf,"DS64(130,2,'%s',15);\r\n",cLcd_len_data_buf);
2247   4                                                      GpuSend(lcd_disp_buf);
2248   4                                                      GpuSend("W8UE(3);\r\n");
2249   4                                                      sprintf(lcd_disp_buf,"DS64(130,1,'%s',15);\r\n",cLcd_count_data_buf);
2250   4                                                      GpuSend(lcd_disp_buf);
2251   4                                                      GpuSend("W8UE(4);\r\n");
2252   4                                                      sprintf(lcd_disp_buf,"DS64(130,1,'%d',15);\r\n",public_val.main_disp_val);
2253   4                                                      GpuSend(lcd_disp_buf);
2254   4                                                      GpuSend("SXY(0,0)\r\n");
2255   4                                              }
2256   3                                              break;
2257   3                                      case 1:
2258   3                                              ClearLCDScreen(0);
2259   3                                              GpuSend("SPG(57);\r\n");
2260   3                                              DELAY_US(10000);
2261   3                                              GpuSend("W8UE(1);\r\n");
2262   3                                              sprintf(cLcd_count_data_buf,"%s","16-5-12");
2263   3                                              sprintf(lcd_disp_buf,"DS64(130,2,'%s',15);\r\n",cLcd_count_data_buf);
2264   3                                              GpuSend(lcd_disp_buf);
2265   3                                              GpuSend("W8UE(2);\r\n");
2266   3                                              sprintf(cLcd_count_data_buf,"%d",public_val.version);
2267   3                                              sprintf(lcd_disp_buf,"DS64(130,1,'%s',15);\r\n",cLcd_count_data_buf);
2268   3                                              GpuSend(lcd_disp_buf);
2269   3                                              GpuSend("W8UE(3);\r\n");
2270   3                                              sprintf(lcd_disp_buf,"DS64(130,1,'%d',15);\r\n",public_val.main_disp_val);
2271   3                                              GpuSend(lcd_disp_buf);
2272   3                                              GpuSend("SXY(0,0)\r\n");
2273   3                                              g_iInterfaceChangOldTime = public_val.ms_timer;
2274   3                                              LCDChildDisplayState++;
2275   3                                              break;
2276   3                                      case 2:
2277   3                                              if(public_val.ms_timer - g_iInterfaceChangOldTime  > 2000)
2278   3                                              {
2279   4                                                      ClearLCDScreen(0);
2280   4                                                      GpuSend("SPG(60);\r\n");
2281   4                                                      g_iInterfaceChangOldTime  = public_val.ms_timer;
2282   4                                                      LCDChildDisplayState++;                                         
2283   4                                              }
2284   3                                              break;
C51 COMPILER V9.00   LED_DISPLAY                                                           05/12/2016 11:15:08 PAGE 38  

2285   3                                      case 3:
2286   3                                              if(public_val.ms_timer - g_iInterfaceChangOldTime  > 5000)
2287   3                                              {
2288   4                                                      g_iInterfaceChangOldTime  = 0;
2289   4                                                      LCDChildDisplayState = 0;
2290   4                                                      LCDDisplayState = 0x00;//无画面显示，形成与DispplayState不同的状态，刷新界面。                                  
2291   4                                              }
2292   3                                              break;
2293   3                                      
2294   3                                      case 8://切纸询问界面
2295   3                                              if(public_val.ms_timer -  g_iFlashOldTime> 500)
2296   3                                              {
2297   4                                                      static xdata int icutFlashFlag =0;
2298   4                                                      g_iFlashOldTime = public_val.ms_timer;
2299   4                                                      ClearLCDScreen(0);
2300   4                                                      if(icutFlashFlag)
2301   4                                                      {
2302   5                                                              GpuSend("SPG(62);\r\n");
2303   5                                                      }
2304   4                                                      else
2305   4                                                      {
2306   5                                                              GpuSend("SPG(63);\r\n");
2307   5                                                      }
2308   4                                                      icutFlashFlag = !icutFlashFlag;
2309   4                                              }
2310   3                                              
2311   3                                              switch(Key_Val)
2312   3                                              {
2313   4                                                      case 0xFFFF:
2314   4                                                      case 0x0000:
2315   4                                                              break;
2316   4                                                      case KEY_IO3://切纸                                                     
2317   4                                                              break;
2318   4                                                      case KEY_K4://确认
2319   4                                                      //清除显示
2320   4                                                              g_pcStatus = 0;
2321   4                                                              LCDChildDisplayState =0;
2322   4                                                              LCDDisplayState = 0x00;
2323   4                                                              break;
2324   4                                                      case KEY_K1://选择
2325   4                                                              //sprintf(lcd_disp_buf,"DS64(130,1,'%X',15);\r\n",Key_Val);
2326   4                                                              //GpuSend(lcd_disp_buf);
2327   4                                                              LCDChildDisplayState =0;
2328   4                                                              LCDDisplayState = 0x00;
2329   4                                                              break;
2330   4                                                      default:
2331   4                                                      break;
2332   4                                              }
2333   3                                              
2334   3                                              break;
2335   3                              }
2336   2                              
2337   2                              
2338   2                              break;
2339   2                      case ST_PASSWORD:
2340   2                              for(i=0 ;i < 5; i++)
2341   2                                      cLcd_data_buf[i] = PasswordBuff[i];
2342   2                              break;
2343   2                      case ST_MENU:
2344   2                              if(Key_Val == KEY_REDUCE || Key_Val == KEY_INCREASE)
2345   2                              {
2346   3                                      LCDDisplayState = 0x00;
C51 COMPILER V9.00   LED_DISPLAY                                                           05/12/2016 11:15:08 PAGE 39  

2347   3                              }
2348   2                              break;
2349   2                              //now_menu.par_id
2350   2                      case ST_DATA_INPUT:
2351   2                              if(now_menu.menu_id == 0 && now_menu.par_id ==0)//纸长
2352   2                              {
2353   3                                      pLCDDataValue=&pMenu[0];
2354   3                                      iLen = *(int *)pLCDDataValue->m_data_vale;
2355   3                              //      sprintf(cLcd_data_buf,"%d",iLen);
2356   3                              }
2357   2                              else if(now_menu.menu_id == 0 && now_menu.par_id ==1)//捆数
2358   2                              {                                       
2359   3                                      pLCDDataValue=&pMenu[1];
2360   3                                      iCount= *(int *)pLCDDataValue->m_data_vale;
2361   3                              //      sprintf(cLcd_data_buf,"%d",iCount);
2362   3                              }
2363   2                              iCount = TempInputData;
2364   2                              sprintf(cLcd_data_buf,"%d",iCount);
2365   2                              break;
2366   2              }
2367   1              
2368   1              
2369   1              if(DisplayState ==ST_PASSWORD  || DisplayState == ST_DATA_INPUT)
2370   1              {
2371   2                      xdata char lcd_disp_buf[50*2] = {0};
2372   2                      xdata char old_disp;
2373   2                      if(public_val.ms_timer -  g_iFlashOldTime> 300)//闪烁频率
2374   2                      {
2375   3                              static xdata int flash = 0;
2376   3                              static xdata int oldDataLen =0;
2377   3      
2378   3                              g_iFlashOldTime = public_val.ms_timer;
2379   3                              
2380   3                              if(flash)
2381   3                              {
2382   4                                      if(strlen(cLcd_data_buf) >= oldDataLen )//当cLcd_data_buf中变成另一个参数时，会导致判断不准确。
2383   4                                      {
2384   5                                              sprintf(lcd_disp_buf,"DS48(30,190,'%s',1);\r\n",cLcd_data_buf);
2385   5                                              GpuSend(lcd_disp_buf);
2386   5                                      }
2387   4                                      else
2388   4                                      {
2389   5                                              sprintf(lcd_disp_buf,"DS48(30,190,'%s  ',1);\r\n",cLcd_data_buf);
2390   5                                              GpuSend(lcd_disp_buf);
2391   5                                      }
2392   4                              }
2393   3                              else
2394   3                              {
2395   4                                      if(  DisplayState ==ST_PASSWORD )
2396   4                                      {
2397   5                                              old_disp = cLcd_data_buf[DisplayBitNum];
2398   5                                              cLcd_data_buf[DisplayBitNum] = '_';
2399   5                                      }
2400   4                                      else
2401   4                                      {
2402   5                                              i=0;
2403   5                                              while(cLcd_data_buf[i] != '\0')
2404   5                                                      i++;
2405   5                                              i--;
2406   5                                              old_disp = cLcd_data_buf[i];
2407   5                                              cLcd_data_buf[i]='_';
2408   5                                      }
C51 COMPILER V9.00   LED_DISPLAY                                                           05/12/2016 11:15:08 PAGE 40  

2409   4                                      sprintf(lcd_disp_buf,"DS48(30,190,'%s  ',1);\r\n",cLcd_data_buf);//不分情况直接多输出两个空格，
2410   4                                      GpuSend(lcd_disp_buf);
2411   4                                      if(  DisplayState ==ST_PASSWORD )
2412   4                                      {
2413   5                                              cLcd_data_buf[DisplayBitNum] = old_disp;
2414   5                                      }
2415   4                                      else
2416   4                                      {
2417   5                                              cLcd_data_buf[i]=old_disp;
2418   5                                      }
2419   4                              }
2420   3                              flash = !flash;
2421   3                      }
2422   2              }
2423   1      
2424   1      
2425   1                      
2426   1      
2427   1              if(!UpdateState)
2428   1              {
2429   2                      UpdateState = 1;
2430   2                      UpdateCountB = public_val.ms_timer;
2431   2              }
2432   1              else
2433   1              {
2434   2                      if(public_val.ms_timer - UpdateCountB > 100)
2435   2                      {
2436   3                              flash_flag = !flash_flag;
2437   3                              UpdateState = 0;
2438   3                      }               
2439   2              }
2440   1      
2441   1      
2442   1              switch(war_bell_step)  /* 蜂鸣器报警处理 */
2443   1              {
2444   2                      case 1:
2445   2                              war_bell_delay = public_val.ms_timer;
2446   2                              Bell_flag |= 0x02;
2447   2                              war_bell_step = 10;
2448   2                      break;
2449   2                      case 10:
2450   2                              iBellOnTime = (cPauseBell == 0) ? 500 : 50;
2451   2                              //iBellOnTime = (cPauseBell == 0) ? 2000 : 50;
2452   2                              if(public_val.ms_timer - war_bell_delay > iBellOnTime) //响的时间
2453   2                                      {
2454   3                                              war_bell_delay = public_val.ms_timer;
2455   3                                              Bell_flag &= 0xfd;
2456   3                                              war_bell_step = 20;
2457   3                                      }
2458   2                      break;
2459   2                      case 20:
2460   2                              iBellOffTime = (cPauseBell == 0) ? 2000 : 2000;                 
2461   2                              //iBellOffTime = (cPauseBell == 0) ? 200 : 2000;                        
2462   2                              if(public_val.ms_timer - war_bell_delay > iBellOffTime) //不响的时间
2463   2                                      {
2464   3                                              war_bell_delay = public_val.ms_timer;
2465   3                                              war_bell_step = 30;
2466   3                                      }                       
2467   2                      break;
2468   2                      case 30:
2469   2                              if((!public_val.Err_Flag) 
2470   2                                 && (!(public_val.Work_Pause_Flag & 0x80))
C51 COMPILER V9.00   LED_DISPLAY                                                           05/12/2016 11:15:08 PAGE 41  

2471   2                                 && (!public_val.Bell_Flag))  /* added for v19416 */
2472   2                                      {
2473   3                                              war_bell_step = 0;   /* 无报错 */
2474   3                                      }
2475   2                              else
2476   2                                      {
2477   3                                              war_bell_step = 1;
2478   3                                      }
2479   2                      break;
2480   2              }
2481   1              
2482   1              if(Bell_flag)
2483   1              {
2484   2                      BELL = 1;
2485   2              }
2486   1              else
2487   1              {
2488   2                      BELL = 0;
2489   2              }
2490   1              
2491   1      
2492   1      //      TM1637_Write();
2493   1      
2494   1              
2495   1      }
*** WARNING C280 IN LINE 840 OF LED_DISPLAY.C: 'iTatol': unreferenced local variable
2496                          
2497          
2498          /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
2499          功能：整形变字符型
2500          
2501          参数：nBit:整数位个数，nPoint:小数位个数  ,nFlag==1整数位前的0以空格补充
2502          
2503          返回值：高位空格数
2504          ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
2505          static char DataToStr(void * const pData,char size,char nBit,char nPoint,char *string,char nFlag,char nTyp
             -e)
2506          {       
2507   1              long DataS32Bit;
2508   1              char spaces;
2509   1              char Temp,module;
2510   1              char SignZero;//负数标志位,  >0: 0,  <0: 1
2511   1              
2512   1              if(size==0 || size>4)//判断size的合理性
2513   1                  return 0;
2514   1              size--;
2515   1      //      if( ( *((char *)(pData)+size) ) & 0x80 )//判断最高位是否为1
2516   1      //          SignZero=1;
2517   1      //      else
2518   1                  SignZero=0; 
2519   1                  
2520   1          DataS32Bit=0;
2521   1              if(size==3)//LONG型数据
2522   1              {                           
2523   2                      if(SignZero)
2524   2                          *((long *)&DataS32Bit) = 0 - *((long *)pData);
2525   2                      else
2526   2                          *((long *)&DataS32Bit) = *((long *)pData);
2527   2              }       
2528   1              else if(size==1)//INT型数据
2529   1              {
2530   2                  if(SignZero)
C51 COMPILER V9.00   LED_DISPLAY                                                           05/12/2016 11:15:08 PAGE 42  

2531   2                          *((int *)&DataS32Bit) = 0 - *((int *)pData);                                                
2532   2                      else
2533   2                          *((int *)&DataS32Bit) = *((int *)pData);    
2534   2              }       
2535   1              else if(size==0)//char型数据
2536   1              {
2537   2                  if(SignZero)
2538   2                          *((char *)&DataS32Bit) = 0 - *((char *)pData);
2539   2                      else
2540   2                          *((char *)&DataS32Bit) = *((char *)pData);
2541   2              }
2542   1              else
2543   1                      return 0;       
2544   1              
2545   1              switch(nType){
2546   2              case TY_B:
2547   2                      module=2;
2548   2                      break;
2549   2              case TY_D:
2550   2              case TY_RD:
2551   2              case TY_D_A:
2552   2              case TY_D_L:
2553   2              module=10;
2554   2                      break;
2555   2              case TY_H:
2556   2              module=16;
2557   2                      break;
2558   2              }
2559   1              
2560   1          spaces = 3-(nPoint+nBit);
2561   1              Temp = nPoint+nBit;
2562   1              if(Temp<3)
2563   1              {
2564   2                  nBit += (3-Temp);
2565   2                      Temp=3;
2566   2              }
2567   1                      
2568   1              do
2569   1          {
2570   2              if(Temp!=nBit || nFlag)
2571   2              {
2572   3                  string[Temp]='0'+(char)(DataS32Bit%(module));
2573   3                  DataS32Bit/=module;
2574   3              }
2575   2              else 
2576   2                      {
2577   3                              if(nPoint!=0)
2578   3                                  string[Temp]='.';
2579   3                              else
2580   3                                  string[Temp]=' ';
2581   3                      }
2582   2              
2583   2          }while( Temp-- >0 );
2584   1              
2585   1              if(nFlag)//nFlag==1整数位前的0以空格补充
2586   1              {
2587   2                  if(SignZero && spaces<3)
2588   2                          string[spaces]='-';
2589   2                      return 0;
2590   2          }
2591   1              
2592   1              Temp=0;
C51 COMPILER V9.00   LED_DISPLAY                                                           05/12/2016 11:15:08 PAGE 43  

2593   1              spaces=0;
2594   1          do
2595   1          {
2596   2             if(string[Temp]=='0' && (Temp+1<nBit)) 
2597   2             {
2598   3                         string[Temp]=' ';
2599   3                         spaces++;
2600   3                 }
2601   2             else
2602   2                 {
2603   3                 break;
2604   3                 }
2605   2             Temp++;
2606   2          }while(1);
2607   1              if(SignZero)
2608   1              {
2609   2                  string[--spaces]='-';
2610   2              }
2611   1              Temp=nPoint+nBit-spaces;
2612   1              if(Temp<3)
2613   1                  spaces -= (3-Temp);
2614   1              return spaces;
2615   1      }
2616          
2617          /*++++++++++++++++++++++++++++++++++++++++++++++++++++
2618          功能：需要一个函数将字符化整形
2619          
2620          参数：len 为字符长度
2621          
2622          返回值：无
2623          ++++++++++++++++++++++++++++++++++++++++++++++++++++*/
2624          static long StrToData(char *string,char len,char nType)
2625          {       
2626   1          unsigned long x,bi;     
2627   1          char i,module;
2628   1      
2629   1          switch(nType){
2630   2              case TY_B:
2631   2                      module=2;
2632   2                      break;
2633   2              case TY_D:
2634   2              module=10;
2635   2                      break;
2636   2              case TY_H:
2637   2              module=16;
2638   2                      break;
2639   2              }
2640   1              x=0;
2641   1              bi=1;
2642   1              for(i=len;i>0;)
2643   1          {
2644   2              i--;
2645   2                      if(string[i] >= '0' && string[i]<=0x3F)
2646   2                      {
2647   3                         x+=(string[i] - '0')*bi;
2648   3                         bi*=module;
2649   3              }
2650   2              }
2651   1              if(string[0]=='-' || string[1]=='-' || string[2]=='-' )//负数
2652   1                  return (0-x);
2653   1              else
2654   1                  return x;
C51 COMPILER V9.00   LED_DISPLAY                                                           05/12/2016 11:15:08 PAGE 44  

2655   1      
2656   1      }
2657          void MenuEditLook(unsigned char cDisplayItemNum)
2658          {
2659   1              
2660   1              //unsigned char DisplayItemNum;
2661   1              switch(cDisplayItemNum)
2662   1              {
2663   2                      case 10:
2664   2                              GpuSend("SPG(31);\r\n");                
2665   2                      break;
2666   2              
2667   2                      case 11:
2668   2                              GpuSend("SPG(32);\r\n");                
2669   2                      break;
2670   2                      
2671   2                      case 12:
2672   2                              GpuSend("SPG(33);\r\n");                
2673   2                      break;
2674   2                      
2675   2                      case 13:
2676   2                              GpuSend("SPG(34);\r\n");                
2677   2                      break;
2678   2                      
2679   2                      case 14:
2680   2                              GpuSend("SPG(35);\r\n");                
2681   2                      break;
2682   2                      
2683   2                      case 15:
2684   2                              GpuSend("SPG(36);\r\n");                
2685   2                      break;
2686   2                      
2687   2                      case 16:
2688   2                              GpuSend("SPG(37);\r\n");                
2689   2                      break;
2690   2                      
2691   2                      case 17:
2692   2                              GpuSend("SPG(38);\r\n");                
2693   2                      break;
2694   2                      
2695   2                      case 18:
2696   2                              GpuSend("SPG(39);\r\n");                
2697   2                      break;
2698   2                      
2699   2                      case 19:
2700   2                              GpuSend("SPG(40);\r\n");                
2701   2                      break;
2702   2                      
2703   2                      
2704   2                      case 20:
2705   2                              GpuSend("SPG(41);\r\n");                
2706   2                      break;
2707   2                      
2708   2                      
2709   2                      case 21:
2710   2                              GpuSend("SPG(42);\r\n");                
2711   2                      break;
2712   2                      
2713   2                      case 22:
2714   2                              GpuSend("SPG(43);\r\n");                
2715   2                      break;
2716   2                      
C51 COMPILER V9.00   LED_DISPLAY                                                           05/12/2016 11:15:08 PAGE 45  

2717   2                      case 23:
2718   2                              GpuSend("SPG(44);\r\n");                
2719   2                      break;
2720   2                      
2721   2                      case 24:
2722   2                              GpuSend("SPG(45);\r\n");                
2723   2                      break;
2724   2                      
2725   2                      case 25:
2726   2                              GpuSend("SPG(46);\r\n");                
2727   2                      break;
2728   2                      
2729   2                      case 26:
2730   2                              GpuSend("SPG(47);\r\n");                
2731   2                      break;
2732   2                      
2733   2                      case 27:
2734   2                              GpuSend("SPG(48);\r\n");                
2735   2                      break;
2736   2                      
2737   2                      case 28:
2738   2                              GpuSend("SPG(49);\r\n");                
2739   2                      break;
2740   2                      
2741   2                      case 29:
2742   2                              GpuSend("SPG(50);\r\n");                
2743   2                      break;
2744   2                      default:
2745   2                              GpuSend("SPG(31);\r\n");
2746   2                              break;
2747   2              
2748   2              }
2749   1              
2750   1              DELAY_US(UART1s_DELAY);
2751   1      }
2752          
2753          void ClearLCDScreen(int c)
2754          {
2755   1              xdata char buf[20];
2756   1              DELAY_US(1000);
2757   1              sprintf(buf,"CLS(%d);\r\n",c);
2758   1              GpuSend(buf);
2759   1              DELAY_US(1000);
2760   1              
2761   1      }
2762          
2763          void TextOut(char *text)
2764          {
2765   1      //      xdata char lcd_disp_buf[50*2] = {0};
2766   1      //      sprintf(lcd_disp_buf,"DS%d(%d,%d,'%s',%d);\r\n",fontsize,x,y,text,colour);
2767   1      //      GpuSend(lcd_disp_buf);
2768   1      }
*** WARNING C280 IN LINE 2763 OF LED_DISPLAY.C: 'text': unreferenced local variable
2769          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  15130    ----
   CONSTANT SIZE    =   1780    ----
   XDATA SIZE       =   1067     334
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
C51 COMPILER V9.00   LED_DISPLAY                                                           05/12/2016 11:15:08 PAGE 46  

   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
