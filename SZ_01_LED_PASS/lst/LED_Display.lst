C51 COMPILER V9.00   LED_DISPLAY                                                           05/05/2016 16:23:17 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE LED_DISPLAY
OBJECT MODULE PLACED IN .\out\LED_Display.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE LED_Display.c BROWSE DEBUG OBJECTEXTEND PRINT(.\lst\LED_Display.lst) OBJECT
                    -(.\out\LED_Display.obj)

line level    source

   1          /**
   2           * Copyright (c) 2012, 长沙晗光电子科技有限公司
   3           * All rights reserved.
   4           *
   5           * FILE:   LED_Display.c
   6           * LED显示程序
   7           *
   8           * @file LED_Display.h led_driver.h
   9           * 头文件.
  10           *
  11           * @author JWD
  12           * @date 2012-12-21
  13           *
  14           */
  15          #include "eeprom.h"
  16          #include "LED_Display.h"
  17          #include "I2c.h"
  18          #include "reg51.h"
  19          #include "save_cnt.h"
  20          #include "global.h"
  21          #include "sys.h"
  22          
  23          #include "uart.h"
  24          
  25          #ifdef DISP_C
  26          
  27          #define BELL P25
  28          
  29          #define MAIN_ADJ_DELAY 2000
  30          #define KEY_DOU_DELY 50
  31          #define KEY_LONG_DELY 100
  32          #define BELL_ON_DELY 50
  33          #define LONG_KEY_STEP_SWITCH 50
  34          #define DISP_ERR_TIMER 1000 //延时数据修改失败时间 和 错误显示时间
  35          
  36          //#define NO_KEY_RETURN_MAIN 15000 //00000菜单无按键返回主页面延时
  37          #define NO_KEY_RETURN_MAIN 30000 //00000菜单无按键返回主页面延时
  38          
  39          #define TEST_MODE_CNT    40
  40          //#define LEARN_MODE_CNT   20
  41          #define LEARN_MODE_CNT   30
  42          
  43          
  44          extern char eeprom_en;
  45          extern xdata unsigned int disp_buf[5];
  46          
  47          /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  48           |                                函数声明                                    |
  49          ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
  50          //void InitLEDDrivers(void);
  51          void LEDShowFlashString(const char  * buff,char x);
  52          //void LEDShowString(char  * buff,char x);
  53          void LEDShowCharS(const char * buff,char num,char x);
  54          void LEDClearChar(char x,char n);
C51 COMPILER V9.00   LED_DISPLAY                                                           05/05/2016 16:23:17 PAGE 2   

  55          void LEDClearCharS(char num,char x);
  56          void LED_ShowNumber(char * buff,char x);
  57          //void LED_ShowData(char * buff,char x,char nPoint);
  58          
  59          static char DataToStr(void * const pData,char size,char nBit,char nPoint,char *string,char nFlag,char nTyp
             -e);
  60          static long StrToData(char *string,char len,char nType);
  61          
  62          //extern void ResetDoorForTest();
  63          
  64          
  65          //sbit P17 = P1^7;
  66          //sbit P37 = P3^7;
  67          sbit P25 = P2^5;
  68          //sbit P21 = P2^1;
  69          //sbit P22 = P2^2;
  70          //sbit P14 = P1^4;
  71          
  72          //#define RED P17
  73          //#define YELLOW P54
  74          //#define BLUE P55
  75          
  76          
  77          
  78          
  79          //char xdata DIS_OPTIONING;                                                                                     ///<【不允许插引工作标志。0：允许插引；1：不允许插引】
  80          char xdata DIS_ERR_FLGA = 0;
  81          
  82          //内部变量定义
  83          //static xdata unsigned int  l_state;                                                           //显示画面状态
  84          
  85          //static xdata unsigned long  l_input_value;                                            //参数修改画面输入值
  86          static xdata char  l_stop_poll;                                                                 //停止循环显示
  87          
  88          //static xdata char DisplayStateOld;                                                            //记忆画面状态
  89          
  90          static xdata char  DisplayMainID;                                                                       //主画面序号
  91          static xdata char  DisplayMenuID;                                                                       //菜单画面序号
  92          
  93          static xdata char  DisplayMainTotal;                                                            //主画面总数
  94          static xdata char  MenuTotals;                                                                  //主菜单画面总数
  95          
  96          
  97          static xdata char  DisplayMenuTotal;                                                            //菜单画面总数
  98          
  99          static xdata char  DisplayItemNum;                                                              //显示项目序号
 100          static xdata char  DisplayBitNum;                                                                       //显示位号
 101          
 102          //static xdata char  MenuUpdateState;                                                           //菜单显示更新状态
 103          static xdata char  PasswordBuff[5];                                                             //密码数据缓冲区
 104          static xdata char  DisplayBuff[10];
 105          
 106          int  DisplayState;                                                                                      //画面状态
 107          int  LCDDisplayState;
 108          
 109          static xdata const MAIN_SHOW * pMain;                                                           //主画面数据指针
 110          static xdata const MENU_SHOW * pMenu;                                                           //菜单指针
 111          static xdata const MENU_ITEM * pItem;                                                           //菜单项目指针
 112          
 113          //static xdata const MENU_SHOW * pCode;
 114          static xdata const MENU_SHOW * pDataValue;
 115          
C51 COMPILER V9.00   LED_DISPLAY                                                           05/05/2016 16:23:17 PAGE 3   

 116          //static xdata const TYPE_CODE * disp_code;
 117          
 118          //static xdata char  UpdateDataCount;
 119          static xdata char  CycShowCount;
 120          static xdata char  InputDataLen;
 121          static xdata long  TempInputData;
 122          static xdata char  DataType;
 123          
 124          
 125          xdata public_stru public_val;
 126          xdata MENU_CHANG now_menu;
 127          
 128          xdata char cPauseBell = 0; 
 129          
 130          xdata char test_mode = 0;   /* 测试模式标志: 0正常工作模式，1测试模式 */
 131          
 132          
 133          xdata char uart_send_buf[100];
 134          
 135          
 136          //菜单配置界面
 137          //参数组定义
 138          //#define DEBUG_MENU_GS_VAL 30
 139          //#define USE_MENU_NUM 16
 140          
 141          static xdata MENU_SHOW Menu00000[MENU_ID_00000_MAX_ITEM];
 142          static xdata MENU_SHOW Menu10101[MENU_ID_10101_MAX_ITEM];
 143          static xdata MENU_SHOW Menu10102[MENU_ID_10102_MAX_ITEM];
 144          static xdata MENU_SHOW Menu10103[MENU_ID_10103_MAX_ITEM];
 145          static xdata MENU_SHOW Menu10104[MENU_ID_10104_MAX_ITEM];
 146          static xdata MENU_SHOW Menu20101[MENU_ID_20101_MAX_ITEM];
 147          
 148          xdata char Menu_Number[MENU_NUM] = {MENU_ID_00000_MAX_ITEM,
 149                                                                                  MENU_ID_10101_MAX_ITEM,
 150                                                                                  MENU_ID_10102_MAX_ITEM,
 151                                                                                  MENU_ID_10104_MAX_ITEM,
 152                                                                                  MENU_ID_20101_MAX_ITEM
 153                  };
 154          //xdata char Menu0_Number = 10, Menu1_Number = 20;
 155          
 156          /*--------------菜单设置画面 数据配置-------------*/
 157          code MENU_ITEM MenuItem[]={
 158            //菜单序号,菜单地址,密码 数据存储首地址 最大数据个数
 159                  {MENU_ID_00000,Menu00000,"00000",EEPROM_MENU_1,MENU_ID_00000_MAX_ITEM,0,&Menu_Number[0]}, 
 160                  {MENU_ID_10101,Menu10101,"10101",EEPROM_MENU_2,MENU_ID_10101_MAX_ITEM,0,&Menu_Number[2]}, 
 161                  {MENU_ID_10102,Menu10102,"10102",EEPROM_MENU_3,MENU_ID_10102_MAX_ITEM,0,&Menu_Number[3]}, 
 162                  {MENU_ID_10103,Menu10103,"10103",EEPROM_MENU_4,MENU_ID_10103_MAX_ITEM,0,&Menu_Number[4]}, 
 163                  {MENU_ID_10104,Menu10104,"10104",EEPROM_MENU_5,MENU_ID_10104_MAX_ITEM,0,&Menu_Number[5]}, 
 164                  {MENU_ID_20101,Menu20101,"20101",EEPROM_MENU_6,MENU_ID_20101_MAX_ITEM,0,&Menu_Number[6]}, 
 165                  {0,0,0}
 166          };
 167          
 168          code MAIN_SHOW MainItem[]={
 169              //显示的字符串,数据显示类型,数据地址,函数名
 170              {"",TY_D_A,0,&(public_val.main_disp_val),INT32_SIZE,5,0,99999,0},           
 171              {0,0,0}
 172          };
 173          
 174          /*-------------------------主画面数据配置,全局变量----------------------------*/
 175          xdata const MAIN_PIC main_menu_cfg[]={
 176              {4,2,MainItem,MenuItem},
 177          };
C51 COMPILER V9.00   LED_DISPLAY                                                           05/05/2016 16:23:17 PAGE 4   

 178          
 179          static code const char LED_ASCII[128]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //0x0
 180                                                      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
 181                                                      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, //0x1
 182                                                      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
 183                                                      0x00,0xFE,0xB0,0xED,0xF9,0xB3,0xDB,0xDF, //0x2
 184                                                      0xF0,0xFF,0xFB,0x00,0x00,0x40,0x80,0x00, 
 185                                                      0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07, // 起始48:0-7
 186                                                      0x7f,0x6F,0x77,0x1F,0x4E,0x3D,0x4F,0x47, //     56
 187                                                      0xFB,0x77,0x1F,0x4E,0x3D,0x79,0x71,0xFB, //     64
 188                                                      0x37,0x06,0x0E,0x07,0x38,0x6A,0x76,0x1D, //     72
 189                                                      0x73,0x67,0x05,0x5B,0x31,0x3E,0x1C,0x5C, //     80
 190                                                      0x31,0x3B,0xED,0x00,0x00,0x00,0x62,0x08,
 191                                                      0x00,0x77,0x1F,0x4E,0x3D,0x4F,0x47,0xFB, //0x6
 192                                                      0x37,0x06,0x38,0x07,0x0E,0x6A,0x15,0x1D, 
 193                                                      0x67,0x73,0x50,0x5B,0x78,0x3E,0x1C,0x5C, //0x7
 194                                                      0x31,0x3B,0xED,0x00,0x00,0x00,0x00,0x00, 
 195                                     };
 196          
 197          //unsigned short usParamNum = 30;   /* 主板的配置参数个数，最大为30个 */
 198          
 199          xdata int gsKeyVal = 0;    /* 按键值 */
 200          xdata char gcKeyType = 0;  /* 按键类型: 0短按, 1长按下，2长按抬起 */
 201          
 202          //xdata char gcKeyLongUpFlag = 0;    /* 长按抬起标志:0未抬起，1抬起 */
 203          //xdata char gcKeyLongDownFlag = 0;  /* 长按按下标志:0未按下，1按下 */
 204          
 205          xdata _U_BIT_PARAM unKey;
 206           
 207          
 208          xdata char speed_mode = 1;   //速度模式: 1高速， 0低速
 209          
 210          xdata char qz_wait = 0;      //等待切纸确认: 0未等待，1等待
 211          
 212          //add by yq
 213          xdata char Menu0_Number;                                                   
 214                                                             
 215          /*++++++++++++++++++++++++++++++++++++++++++++++++
 216          功能：显示字符串。
 217          
 218          参数：buff:欲发送的数据缓冲区；x:坐标
 219          
 220          返回值：无。
 221          
 222          说明：
 223          ++++++++++++++++++++++++++++++++++++++++++++++++*/
 224          void  LEDShowFlashString(const char  * buff,char x) 
 225          {
 226   1              do
 227   1              {
 228   2                      disp_buf[x++] = LED_ASCII[*buff++];
 229   2              }while(x<6 && *buff!=0);
 230   1      }
 231          
 232          void  LEDShowCaption(char num) 
 233          {
 234   1      char *buff,x = 0;
 235   1      switch(num)
 236   1              {
 237   2                      case 0:
 238   2                              buff = "1-";
 239   2                      break;
C51 COMPILER V9.00   LED_DISPLAY                                                           05/05/2016 16:23:17 PAGE 5   

 240   2                      case 1:
 241   2                              buff = "2-";
 242   2                      break;          
 243   2                      case 2:
 244   2                              buff = "3-";
 245   2                      break;  
 246   2                      case 3:
 247   2                              buff = "4-";
 248   2                      break;          
 249   2                      case 4:
 250   2                              buff = "5-";
 251   2                      break;          
 252   2                      case 5:
 253   2                              buff = "6-";
 254   2                      break;          
 255   2                      case 6:
 256   2                              buff = "7-";
 257   2                      break;          
 258   2                      case 7:
 259   2                              buff = "8-";
 260   2                      break;          
 261   2                      case 8:
 262   2                              buff = "9-";
 263   2                      break;          
 264   2                      case 9:
 265   2                              buff = "10";
 266   2                      break;          
 267   2                      case 10:
 268   2                              buff = "11";
 269   2                      break;          
 270   2                      case 11:
 271   2                              buff = "12";
 272   2                      break;          
 273   2                      case 12:
 274   2                              buff = "13";
 275   2                      break;  
 276   2                      case 13:
 277   2                              buff = "14";
 278   2                      break;  
 279   2                      case 14:
 280   2                              buff = "15";
 281   2                      break;  
 282   2                      case 15:
 283   2                              buff = "16";
 284   2                      break;  
 285   2                      case 16:
 286   2                              buff = "17";
 287   2                      break;
 288   2                      case 17:
 289   2                              buff = "18";
 290   2                      break;  
 291   2                      case 18:
 292   2                              buff = "19";
 293   2                      break;  
 294   2                      case 19:
 295   2                              buff = "20";
 296   2                      break;                  
 297   2                      case 20:
 298   2                              buff = "21";
 299   2                      break;          
 300   2                      case 21:
 301   2                              buff = "22";
C51 COMPILER V9.00   LED_DISPLAY                                                           05/05/2016 16:23:17 PAGE 6   

 302   2                      break;          
 303   2                      case 22:
 304   2                              buff = "23";
 305   2                      break;  
 306   2                      case 23:
 307   2                              buff = "24";
 308   2                      break;  
 309   2                      case 24:
 310   2                              buff = "25";
 311   2                      break;  
 312   2                      case 25:
 313   2                              buff = "26";
 314   2                      break;  
 315   2                      case 26:
 316   2                              buff = "27";
 317   2                      break;
 318   2                      case 27:
 319   2                              buff = "28";
 320   2                      break;  
 321   2                      case 28:
 322   2                              buff = "29";
 323   2                      break;  
 324   2                      case 29:
 325   2                              buff = "30";
 326   2                      break;  
 327   2                      case 80:
 328   2                              buff = "   A1";
 329   2                      break;
 330   2                      case 81:
 331   2                              buff = "   A2";
 332   2                      break;
 333   2                      case 82:
 334   2                              buff = "   A3";
 335   2                      break;
 336   2                      case 83:
 337   2                              buff = "   A4";
 338   2                      break;
 339   2                      case 84:
 340   2                              buff = "   A5";
 341   2                      break;
 342   2                      case 85:
 343   2                              buff = "   A6";
 344   2                      break;
 345   2                      case 86:
 346   2                              buff = "   A7";
 347   2                      break;
 348   2                      case 87:
 349   2                              buff = "   A8";
 350   2                      break;
 351   2                      case 88:
 352   2                              buff = "   A9";
 353   2                      break;
 354   2                      case 89:
 355   2                              buff = "  A10";
 356   2                      break;
 357   2              }
 358   1              do
 359   1              {
 360   2                      disp_buf[x++] = LED_ASCII[*buff++];
 361   2              }while(x<6 && *buff!=0);
 362   1      }
 363          
C51 COMPILER V9.00   LED_DISPLAY                                                           05/05/2016 16:23:17 PAGE 7   

 364          /*++++++++++++++++++++++++++++++++++++++++++++++++
 365          功能：显示字符串。
 366          
 367          参数：buff:欲发送的数据缓冲区；x:坐标
 368          
 369          返回值：无。
 370          
 371          说明：
 372          ++++++++++++++++++++++++++++++++++++++++++++++++*/
 373          /*void  LEDShowString(char  * buff,char x) 
 374          {
 375                  do
 376                  {
 377                          disp_buf[x++] = LED_ASCII[*buff++];
 378                  
 379                  }while(x<6 && *buff!=0);
 380          }*/
 381          
 382          /*void  LED_ShowData(char * buff,char x,char nPoint)
 383          {
 384              do
 385                  {
 386                  if(nPoint !=0 && (8-nPoint)==x)
 387                          disp_buf[x++] = LED_ASCII[*buff++] | 0x80;              ///<【位7置1】
 388                          else
 389                                  disp_buf[x++] = LED_ASCII[*buff++];
 390                  }while(x<6 && *buff!=0);
 391          }*/
 392          
 393          /*++++++++++++++++++++++++++++++++++++++++++++++++
 394          功能：清除指定行号列号的字符。
 395          
 396          参数：x:坐标1-8。
 397          
 398          返回值：无。
 399          
 400          说明： 无。
 401          ++++++++++++++++++++++++++++++++++++++++++++++++*/
 402          void  LEDClearChar(char x,char n)
 403          {
 404   1              char i;
 405   1              for(i = x; i< (x+n); i++ )
 406   1                      {
 407   2                              disp_buf[i] = 0;                
 408   2                      }
 409   1      }
 410          
 411          
 412          /*++++++++++++++++++++++++++++++++++++++++++++++++
 413          功能：显示数字。
 414          参数：buff:欲发送的数据缓冲区；x:坐标
 415          返回值：无。
 416          说明：
 417          ++++++++++++++++++++++++++++++++++++++++++++++++*/
 418          void  LED_ShowNumber(char * buff,char x) 
 419          {
 420   1              char TempFlag=0;
 421   1              do
 422   1              {
 423   2                      if(*(buff+1)!='.' || TempFlag==1)
 424   2                      {
 425   3                              disp_buf[x++] = LED_ASCII[*buff++];
C51 COMPILER V9.00   LED_DISPLAY                                                           05/05/2016 16:23:17 PAGE 8   

 426   3                              //SendLed(x++,LED_ASCII[*buff++]);
 427   3                      }
 428   2                      else
 429   2                      {
 430   3                              disp_buf[x++] = LED_ASCII[*buff++] | 0x80;
 431   3                              //SendLed(x++,(LED_ASCII[*buff++] | 0x80));
 432   3                              TempFlag=1;
 433   3                              buff++;
 434   3                      }
 435   2              }while(x<6);
 436   1              
 437   1      }
 438          
 439          //菜单数据指向
 440          void menu_cfg(void)
 441          {
 442   1              char i;
 443   1              for(i = 0; i < MENU_ID_00000_MAX_ITEM ; i++)
 444   1                      {
 445   2                              Menu00000[i].m_data_vale = &public_val.Disp_Dz_00000[i];
 446   2                      }
 447   1      
 448   1              for(i = 0; i < MENU_ID_10101_MAX_ITEM ; i++)
 449   1                      {
 450   2                              Menu10101[i].m_data_vale = &public_val.Disp_Dz_10101[i];
 451   2                      }
 452   1      
 453   1              for(i = 0; i < MENU_ID_10102_MAX_ITEM ; i++)
 454   1                      {
 455   2                              Menu10102[i].m_data_vale = &public_val.Disp_Dz_10102[i];
 456   2                      }
 457   1              
 458   1              for(i = 0; i < MENU_ID_10103_MAX_ITEM ; i++)
 459   1                      {
 460   2                              Menu10103[i].m_data_vale = &public_val.Disp_Dz_10103[i];
 461   2                      }
 462   1      
 463   1              for(i = 0; i < MENU_ID_10104_MAX_ITEM ; i++)
 464   1                      {
 465   2                              Menu10104[i].m_data_vale = &public_val.Disp_Dz_10104[i];
 466   2                      }
 467   1      
 468   1              for(i = 0; i < MENU_ID_20101_MAX_ITEM ; i++)
 469   1                      {
 470   2                              Menu20101[i].m_data_vale = &public_val.Disp_Dz_20101[i];
 471   2                      }
 472   1      }
 473          
 474          /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 475          名称:   read_menu_data(char menu_id)
 476          功能：  读取菜单配置数据 和 菜单数据
 477          参数：  无
 478          返回值：无
 479          ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
 480          
 481          
 482          void read_menu_data(char menu_id)
 483          {
 484   1              unsigned char *progbyte,read_byte;
 485   1              unsigned int progadd;
 486   1      
 487   1              int i;
C51 COMPILER V9.00   LED_DISPLAY                                                           05/05/2016 16:23:17 PAGE 9   

 488   1      
 489   1              progadd = MenuItem[menu_id].eeprom_cfg_add;
 490   1              read_byte = IapReadByte(progadd++);
 491   1              
 492   1              for(i = 0; i < MenuItem[menu_id].MenuItem_Max; i++)
 493   1                      {
 494   2                              if(menu_id == MENU_ID_10104)
 495   2                                      MenuItem[menu_id].m_pcfg[i].m_max = 450;
 496   2                              else
 497   2                                      MenuItem[menu_id].m_pcfg[i].m_max = 999;
 498   2                              MenuItem[menu_id].m_pcfg[i].m_min = 0;
 499   2                              MenuItem[menu_id].m_pcfg[i].ext_property = 0; //read_byte;
 500   2                      }
 501   1              MenuItem[MENU_ID_10104].m_pcfg[PASS_LOCK_COUNT - 1].m_max = 500;
 502   1              
 503   1              switch(menu_id)
 504   1                      {
 505   2                              case MENU_ID_00000:
 506   2                                      progbyte = (unsigned char *)&public_val.Disp_Dz_00000[0];
 507   2                              break;                  
 508   2                              case MENU_ID_10101:
 509   2                                      progbyte = (unsigned char *)&public_val.Disp_Dz_10101[0];
 510   2                              break;
 511   2                              case MENU_ID_10102:
 512   2                                      progbyte = (unsigned char *)&public_val.Disp_Dz_10102[0];
 513   2                              break;
 514   2                              case MENU_ID_10103:
 515   2                                      progbyte = (unsigned char *)&public_val.Disp_Dz_10103[0];
 516   2                              break;
 517   2                              case MENU_ID_10104:
 518   2                                      progbyte = (unsigned char *)&public_val.Disp_Dz_10104[0];
 519   2                              break;
 520   2                              case MENU_ID_20101:
 521   2                                      progbyte = (unsigned char *)&public_val.Disp_Dz_20101[0];
 522   2                              break;
 523   2                      }
 524   1              progadd = MenuItem[menu_id].eeprom_add;
 525   1              for(i = 0; i < MenuItem[menu_id].MenuItem_Max + 1; i++)
 526   1                      {
 527   2                              *progbyte = IapReadByte(progadd++);
 528   2                              progbyte++;
 529   2                              *progbyte = IapReadByte(progadd++);
 530   2                              progbyte++;
 531   2                      }
 532   1                      
 533   1              
 534   1      }
 535          
 536          //将菜单值更新到通讯菜单值，合并两个菜单。
 537          void update_menu_to_com(void)
 538          {
 539   1              char TempB;
 540   1              for(TempB = 0; TempB < MENU_ID_00000_MAX_ITEM; TempB++)
 541   1                      {
 542   2                              public_val.menu_parm[TempB] = public_val.Disp_Dz_00000[TempB];
 543   2                      }
 544   1      
 545   1              for(TempB = 0; TempB < MENU_ID_10101_MAX_ITEM; TempB++)
 546   1                      {
 547   2                              public_val.menu_parm[TempB + MENU_ID_00000_MAX_ITEM] = public_val.Disp_Dz_10101[TempB];
 548   2                      }       
 549   1      }
C51 COMPILER V9.00   LED_DISPLAY                                                           05/05/2016 16:23:17 PAGE 10  

 550          
 551          //读取MCU的ID号 值举例:0D 00 00 2C 02 4B E5
 552          //                                         0D 00 00 30 03 64 E4(开发板载MCU)
 553          void read_id()
 554          {
 555   1          char code *cptr;
 556   1              char i,read_byte[7];
 557   1          cptr = ID_ADDR_ROM;         //从程序区读取ID号
 558   1          for(i=0; i<7; i++)         //读7个字节
 559   1                  {
 560   2                      read_byte[i] = *cptr++; // 0xff; // 
 561   2                  }
 562   1              public_val.password_index_disp = (int)read_byte[5];
 563   1              public_val.password_index_disp <<= 8;
 564   1              public_val.password_index_disp |= (int)read_byte[6] & 0xff;
 565   1              public_val.password_index = public_val.password_index_disp % 2000;
 566   1      
 567   1              cptr = EEPROM_PASSWORD;
 568   1              read_byte[0] = IapReadByte(EEPROM_PASSWORD + (public_val.password_index<<1));
 569   1              read_byte[1] = IapReadByte(EEPROM_PASSWORD + (public_val.password_index<<1)+1);
 570   1              public_val.password_val[0] = (int)read_byte[0] & 0xff;
 571   1              public_val.password_val[1] = (int)read_byte[1] & 0xff;
 572   1      }       
 573          
 574          /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 575          名称:   void InitLEDDisplay(void)
 576          
 577          功能：  显示初始化程序
 578          
 579          参数：  无
 580                
 581          返回值：无
 582          ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
 583          void InitLEDDisplay(void)
 584          {
 585   1          char TempB;
 586   1          //unsigned int temp_int;
 587   1                      
 588   1              BELL = 0;
 589   1      
 590   1              //LEDShowFlashString("Lt-2 ",0);
 591   1              LEDShowFlashString("60409",0);    /* 显示操作板版本号 */
 592   1              
 593   1              TM1637_Write();
 594   1      
 595   1              ///【统计主界面需要显示的项数】
 596   1              pMain = main_menu_cfg[0].m_main;
 597   1              for( TempB = 0; pMain[TempB].m_str; TempB++ ) ///<【空串不为0，即不为假】
 598   1                      {
 599   2                              ;
 600   2                      }                       
 601   1              DisplayMainTotal = TempB;
 602   1      
 603   1              ///【统计下级子菜单数量】
 604   1              pItem = main_menu_cfg[0].m_menu;
 605   1              pMenu = pItem[0].m_pcfg;
 606   1              for(TempB = 0; TempB == pItem[TempB].MenuID; TempB++) 
 607   1                      {
 608   2                              read_menu_data(TempB); //读取菜单数据值;
 609   2                      }
 610   1              MenuTotals = TempB;
 611   1              update_menu_to_com();
C51 COMPILER V9.00   LED_DISPLAY                                                           05/05/2016 16:23:17 PAGE 11  

 612   1      
 613   1              menu_cfg();
 614   1              
 615   1              
 616   1              CycShowCount = 0;
 617   1              DisplayItemNum = 0;
 618   1              DisplayState = ST_MAIN;                                                                 //进入主画面
 619   1              l_stop_poll = 0;                                                                                //默认定格显示
 620   1              
 621   1              //标志位初始化
 622   1              public_val.Work_Pause_Flag = 0; 
 623   1              public_val.Err_Flag = 0;
 624   1              public_val.Bell_Flag = 0;
 625   1      
 626   1              public_val.cnt_after_powered = 0;
 627   1              public_val.Lock_Flag = 0;
 628   1      
 629   1              //加密相关变量初始化
 630   1              read_id();
 631   1      
 632   1              public_val.Disp_Dz_10103[12] = public_val.password_val[0];
 633   1              public_val.Disp_Dz_10103[13] = public_val.password_val[1];
 634   1              
 635   1              public_val.input_pass_mask = 0;
 636   1              for(TempB = 0; TempB < PASS_LOCK_COUNT; TempB++)
 637   1                      {
 638   2                              if( (public_val.Disp_Dz_10103[TempB * 2] == 0)
 639   2                                      && (public_val.Disp_Dz_10103[TempB * 2 + 1] == 0)
 640   2                                      )
 641   2                                      {
 642   3                                              public_val.input_pass_mask |= 1 << TempB;
 643   3                                      }
 644   2                              public_val.Disp_Dz_10102[TempB * 2] = 0;
 645   2                              public_val.Disp_Dz_10102[TempB * 2 + 1] = 0;
 646   2                      }
 647   1              
 648   1              read_loack_count();
 649   1              read_user_count();
 650   1              public_val.Disp_Dz_20101[0] = public_val.work_count / LOCK_UNIT; //已生产根数赋值
 651   1              /* added by james */
 652   1          public_val.ms_timer = 0;
 653   1              public_val.io_read = 0;
 654   1      
 655   1              unKey.all = 0xFFFF;
 656   1      
 657   1      }
 658          
 659          
 660          //完成对菜单数据的存储
 661          void func_menu_update(int menu_id)
 662          {
 663   1              unsigned char *progbyte,i,readbyte;
 664   1              unsigned int progadd;
 665   1              
 666   1              eeprom_en = 0xaa;
 667   1              IapEraseSector(MenuItem[menu_id].eeprom_add);
 668   1              eeprom_en = 0;
 669   1              switch(menu_id)
 670   1                      {
 671   2                              case MENU_ID_00000:
 672   2                                      progbyte = (unsigned char *)&public_val.Disp_Dz_00000[0];
 673   2                              break;                  
C51 COMPILER V9.00   LED_DISPLAY                                                           05/05/2016 16:23:17 PAGE 12  

 674   2                              case MENU_ID_10101:
 675   2                                      progbyte = (unsigned char *)&public_val.Disp_Dz_10101[0];
 676   2                              break;
 677   2                              case MENU_ID_10102:
 678   2                                      progbyte = (unsigned char *)&public_val.Disp_Dz_10102[0];
 679   2                              break;
 680   2                              case MENU_ID_10103:
 681   2                                      progbyte = (unsigned char *)&public_val.Disp_Dz_10103[0];
 682   2                              break;
 683   2                              case MENU_ID_10104:
 684   2                                      progbyte = (unsigned char *)&public_val.Disp_Dz_10104[0];
 685   2                              break;
 686   2                              case MENU_ID_20101:
 687   2                                      progbyte = (unsigned char *)&public_val.Disp_Dz_20101[0];
 688   2                              break;
 689   2                              break;                  
 690   2                      }
 691   1              progadd = MenuItem[menu_id].eeprom_add;
 692   1              for(i = 0; i < MenuItem[menu_id].MenuItem_Max + 1; i++)
 693   1                      {
 694   2                              //SendData(*(progbyte));
 695   2                              eeprom_en = 0xaa;
 696   2                              IapProgramByte(progadd,*(progbyte));
 697   2                              readbyte = IapReadByte(progadd);
 698   2                              if(readbyte != *progbyte)
 699   2                                      public_val.Err_Flag |= ERR_NUM_EEP_ERR; //写EERPOM错误
 700   2                              progbyte++;
 701   2                              progadd++;
 702   2                              //SendData(*(progbyte));
 703   2                              IapProgramByte(progadd,*(progbyte));
 704   2                              readbyte = IapReadByte(progadd);
 705   2                              if(readbyte != *progbyte)
 706   2                                      public_val.Err_Flag |= ERR_NUM_EEP_ERR;
 707   2                              progbyte++;
 708   2                              progadd++;
 709   2                              eeprom_en = 0;
 710   2                      }
 711   1              update_menu_to_com();
 712   1              write_param_flag = 1;    // 更新下位机参数
 713   1                              
 714   1      }
 715          
 716          #if 0
              //完成对版本号的存储
              void func_ver_update(void)
              {
                      char progbyte;
                      eeprom_en = 0xaa;
                      IapEraseSector(EEPROM_DRIVE_TYPE);
                      eeprom_en = 0;
                      progbyte = (unsigned char)(public_val.drive_type >> 8);
                      eeprom_en = 0xaa;
                      IapProgramByte(EEPROM_DRIVE_TYPE,progbyte);
                      progbyte = (unsigned char)(public_val.drive_type & 0xff);
                      IapProgramByte(EEPROM_DRIVE_TYPE + 1,progbyte);
                      progbyte = public_val.drive_indx;
                      
                      IapProgramByte(EEPROM_DRIVE_INDX,progbyte);
                      eeprom_en = 0;
              }
              
              //完成对菜单配置的存储
C51 COMPILER V9.00   LED_DISPLAY                                                           05/05/2016 16:23:17 PAGE 13  

              void func_cfg_update(int menu_id)
              {
              unsigned char i,progbyte;
              unsigned int progadd;
                      eeprom_en = 0xaa;
                      IapEraseSector(MenuItem[menu_id].eeprom_cfg_add);
                      progadd = MenuItem[menu_id].eeprom_cfg_add;
                      progbyte = (unsigned char)(*(MenuItem[menu_id].com_max_item));
                      IapProgramByte(progadd++,progbyte);
                      
                      for(i = 0; i < MenuItem[menu_id].MenuItem_Max; i++)
                              {
                                      progbyte = (unsigned char)(MenuItem[menu_id].m_pcfg[i].m_max >> 8);
                                      IapProgramByte(progadd++,progbyte);
                                      progbyte = (unsigned char)(MenuItem[menu_id].m_pcfg[i].m_max & 0xff);
                                      IapProgramByte(progadd++,progbyte);
                                      progbyte = (unsigned char)(MenuItem[menu_id].m_pcfg[i].m_min >> 8);
                                      IapProgramByte(progadd++,progbyte);
                                      progbyte = (unsigned char)(MenuItem[menu_id].m_pcfg[i].m_min & 0xff);
                                      IapProgramByte(progadd++,progbyte);
                                      progbyte = (unsigned char)(MenuItem[menu_id].m_pcfg[i].ext_property);
                                      IapProgramByte(progadd++,progbyte);
                              }
                      eeprom_en = 0;
              }
              
              #endif
 763          
 764          /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 765          名称:   void LEDDisplay(char Key,char UpdateState)
 766          功能：  显示运行程序
 767          参数：  无
 768          返回值：无
 769          ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
 770          
 771          
 772          /* 测试模式内容显示 */
 773          void test_set_display(char test_mode)
 774          {
 775   1              switch (test_mode)
 776   1              {
 777   2                      case 0:
 778   2                              LEDShowFlashString(" F--0",0);                  
 779   2                              break;
 780   2                      case 1:
 781   2                              LEDShowFlashString(" F--1",0);
 782   2                              break;
 783   2                      case 2:
 784   2                              LEDShowFlashString(" F--2",0);
 785   2                              break;                  
 786   2                      case 3:
 787   2                              LEDShowFlashString(" F--3",0);
 788   2                              break;  
 789   2                      case 4:
 790   2                              LEDShowFlashString(" F--4",0);
 791   2                              break;                          
 792   2                      case 5:
 793   2                              LEDShowFlashString(" F--5",0);
 794   2                              break;                          
 795   2                      default:
 796   2                              break;
 797   2              }       
C51 COMPILER V9.00   LED_DISPLAY                                                           05/05/2016 16:23:17 PAGE 14  

 798   1      }
 799          
 800          
 801          
 802          void LEDDisplay(void)
 803          {
 804   1          char TempCountB,TempDataB,TempValue,i,TempB;
 805   1          static xdata char Bell_flag = 0,zc_key_flag = 0;
 806   1          static xdata unsigned int UpdateCountB,TempCount,flash_flag = 0;    
 807   1              static xdata long DisplayValueTemp;
 808   1              
 809   1              //static xdata char Key_Val = 0,Pr_Key_Val = 0;
 810   1              //static xdata char old_key = 0;
 811   1              static xdata int Key_Val = 0,Pr_Key_Val = 0, old_key = 0;
 812   1      
 813   1              static xdata char UpdateState = 0;
 814   1      
 815   1              static xdata int Read_key_dely = 0,Read_key_dely_2 = 0,long_count = 0,long_input_flag = 0;
 816   1              static xdata int Read_key_dely_3 = 0,No_key_delay = 0;
 817   1              static xdata int Main_adj_key_delay = 0,Main_disp_other = 0;
 818   1              static xdata int edit_menu_id = 0;
 819   1              static xdata int bell_delay;
 820   1              static xdata int long_key_count = 0,long_key_step = 1,pr_long_input_flag;
 821   1              static xdata char war_bell_step = 0;
 822   1              static xdata int war_bell_delay = 0;
 823   1      
 824   1              static xdata char test_key_cnt = 0;   /* 主界面下选择键连按计数 added by james for v19407 */
 825   1              //static xdata char learn_key_cnt = 0; 
 826   1      
 827   1              int temp_max;   
 828   1              int iBellOnTime, iBellOffTime;
 829   1      
 830   1              static xdata unsigned int dj_key_dely = 0,dj_key_step = 0;
 831   1              //ADD by yq
 832   1              xdata unsigned char  cMenuSn;
 833   1              
 834   1              unKey.u_bit.K1 = P24;
 835   1              unKey.u_bit.K2 = P23;
 836   1              unKey.u_bit.K3 = P22;
 837   1              unKey.u_bit.K4 = P21;
 838   1              
 839   1              unKey.u_bit.IO1 = P20;
 840   1              unKey.u_bit.IO2 = P35;
 841   1              unKey.u_bit.IO3 = P33;
 842   1              unKey.u_bit.IO4 = P32;
 843   1              unKey.u_bit.IO5 = P26;
 844   1              unKey.u_bit.IO6 = P27;
 845   1              unKey.u_bit.IO7 = P12;
 846   1              unKey.u_bit.IO8 = P13;
 847   1              unKey.u_bit.IO9 = P16;
 848   1      
 849   1              unKey.u_bit.RED = P17;
 850   1              unKey.u_bit.GREEN = P54;
 851   1              unKey.u_bit.BLUE = P55; 
 852   1      
 853   1              Key_Val = (int)unKey.all; 
 854   1              
 855   1              //Key_Val = (P2 >> 1) & 0x0f;
 856   1              //Key_Val |= 0xf0;
 857   1      
 858   1                      
 859   1              if(Key_Val != old_key) //有按键
C51 COMPILER V9.00   LED_DISPLAY                                                           05/05/2016 16:23:17 PAGE 15  

 860   1              {
 861   2                      No_key_delay = public_val.ms_timer;
 862   2                      
 863   2                      if(!long_input_flag)
 864   2                      {
 865   3                              bell_delay = public_val.ms_timer;
 866   3                              Bell_flag |= 0x01;
 867   3                      }
 868   2                      else
 869   2                      {
 870   3                              Bell_flag &= 0xfe;
 871   3                      }
 872   2                      
 873   2                      if( (public_val.ms_timer - Read_key_dely_2) > KEY_DOU_DELY)
 874   2                      {
 875   3                              old_key = Key_Val;
 876   3                              Read_key_dely = public_val.ms_timer;
 877   3                              long_count = 0;
 878   3                              long_input_flag = 0;
 879   3                              long_key_step = 1;
 880   3                      }
 881   2                      else
 882   2                      {
 883   3                              Key_Val = 0;
 884   3                      }
 885   2                      
 886   2              }
 887   1              else
 888   1              {
 889   2                      if( (public_val.ms_timer - bell_delay) > BELL_ON_DELY)
 890   2                      {
 891   3                              Bell_flag &= 0xfe;
 892   3                      }
 893   2      
 894   2                      if( (public_val.ms_timer - No_key_delay) > NO_KEY_RETURN_MAIN)
 895   2                      {
 896   3                              No_key_delay = public_val.ms_timer;
 897   3                              
 898   3                              //if(edit_menu_id == MENU_ID_00000)
 899   3                              if ((edit_menu_id == MENU_ID_00000) && (DisplayState != ST_LEARN))
 900   3                              {
 901   4                                      DisplayState = ST_MAIN;
 902   4                                      Main_disp_other = 0;    /* added by james for v19407 */
 903   4                              }
 904   3                      }
 905   2                      
 906   2                      if( (public_val.ms_timer - Read_key_dely) > KEY_DOU_DELY)
 907   2                      {
 908   3                              Read_key_dely_2 = public_val.ms_timer;
 909   3                              
 910   3                              //if( ( (Key_Val&0xff) != 0xff) && (!long_input_flag) )
 911   3                              if( ( (Key_Val&0xffff) != 0xffff) && (!long_input_flag) )
 912   3                              {
 913   4                                      long_count++;
 914   4                                      
 915   4                                      //if(long_count > 10)
 916   4                                      if(long_count > 100)   
 917   4                                      {                                                       
 918   5                                              long_input_flag = 1;
 919   5                                              long_key_step = 1;
 920   5                                              long_key_count = 0;
 921   5                                              Read_key_dely_3 = public_val.ms_timer; 
C51 COMPILER V9.00   LED_DISPLAY                                                           05/05/2016 16:23:17 PAGE 16  

 922   5                                              long_count = 10;
 923   5                                      }
 924   4                              }                                       
 925   3                      }
 926   2                      else
 927   2                      {
 928   3                              Key_Val = 0;
 929   3      
 930   3                      }
 931   2              }
 932   1              
 933   1              if(long_input_flag)  /* 长按 */
 934   1              {
 935   2                      if(public_val.ms_timer - Read_key_dely_3 > KEY_LONG_DELY)
 936   2                      {
 937   3                              long_key_count ++;
 938   3                              if(long_key_count > LONG_KEY_STEP_SWITCH)
 939   3                              {
 940   4                                      long_key_step = 10;
 941   4                              }
 942   3                              if(long_key_count)
 943   3                                      Read_key_dely_3 = public_val.ms_timer;
 944   3                              Pr_Key_Val = 0xFF;
 945   3                      }
 946   2              }
 947   1              
 948   1              if(Key_Val)
 949   1              {
 950   2                      if(Key_Val != Pr_Key_Val)
 951   2                      {
 952   3                              Pr_Key_Val = Key_Val;
 953   3                      }
 954   2                      else
 955   2                      {
 956   3                              Key_Val = 0;
 957   3                      }
 958   2              }
 959   1      
 960   1      
 961   1              /* 有按键则下发按键值和按键类型 */
 962   1                      
 963   1              if ((Key_Val == KEY_IO6) || (Key_Val == KEY_IO7) 
 964   1                      || (Key_Val == KEY_IO8))
 965   1              {
 966   2                      if(public_val.Lock_Flag && (Key_Val == KEY_IO7))
 967   2                              {
 968   3                                      public_val.Err_Flag = ERR_LOCK_SYS_ERR + public_val.Lock_Flag;  //锁机错误20
 969   3                              }
 970   2                      else
 971   2                              {
 972   3                                      write_key_flag = 1;   /* 有按键，需要写按键到主板 */
 973   3                                      
 974   3                                      gsKeyVal = Key_Val;
 975   3                                      gcKeyType = KEY_SHORT_UP_FLAG;                          
 976   3                              }
 977   2      
 978   2              }
 979   1      
 980   1              //打胶按键单独处理。
 981   1              switch(dj_key_step)
 982   1                      {
 983   2                              case 0:
C51 COMPILER V9.00   LED_DISPLAY                                                           05/05/2016 16:23:17 PAGE 17  

 984   2                                      if(!P14)
 985   2                                      {
 986   3                                              dj_key_step = 10;
 987   3                                              dj_key_dely = public_val.ms_timer;
 988   3                                      }
 989   2                              break;
 990   2                              case 10:
 991   2                                      if(!P14)
 992   2                                              {
 993   3                                                      if(public_val.ms_timer - dj_key_dely > 100)
 994   3                                                              {
 995   4                                                                      dj_key_step = 20;
 996   4                                                              }
 997   3                                              }
 998   2                                      else
 999   2                                              {
1000   3                                                      dj_key_step = 0;
1001   3                                              }
1002   2                              break;
1003   2                              case 20:
1004   2                                      if(P14)
1005   2                                              {
1006   3                                                      write_key_flag = 1;   /* 有按键，需要写按键到主板 */
1007   3                                                      gsKeyVal = KEY_DJ;
1008   3                                                      gcKeyType = KEY_SHORT_UP_FLAG;
1009   3                                                      dj_key_step = 0;
1010   3                                              }
1011   2                              break;
1012   2                      }
1013   1                      
1014   1          switch(DisplayState)
1015   1              {
1016   2                  case ST_MAIN:   /* 主界面 */
1017   2                  {
1018   3                      switch(Key_Val)
1019   3                          {
1020   4                              case KEY_SEL:
1021   4      
1022   4                                              test_key_cnt = 0;
1023   4                                              //learn_key_cnt = 0;
1024   4      
1025   4                                              if(Main_disp_other == 0)
1026   4                                              {
1027   5                                          PasswordBuff[0] = '0';
1028   5                                          PasswordBuff[1] = '0';
1029   5                                          PasswordBuff[2] = '0';
1030   5                                          PasswordBuff[3] = '0';  
1031   5                                          PasswordBuff[4] = '0';  
1032   5                                          DisplayBitNum = 4;
1033   5      
1034   5                                                      LEDShowFlashString(&PasswordBuff[0],0);
1035   5                                          DisplayState = ST_PASSWORD;
1036   5      
1037   5                                                      return;
1038   5                                              }
1039   4                                              else
1040   4                                              {
1041   5                                                      if (qz_wait == 1)
1042   5                                                      {
1043   6                                                              qz_wait = 0;   // 清等待状态
1044   6      
1045   6                                                              war_bell_step = 0;  // 清除蜂鸣器响声
C51 COMPILER V9.00   LED_DISPLAY                                                           05/05/2016 16:23:17 PAGE 18  

1046   6                                                              cPauseBell = 0;                                                 
1047   6                                                      }
1048   5                                                      
1049   5                                                      Main_disp_other = 0;
1050   5                                              }
1051   4                                                                                      
1052   4                                              
1053   4                                  break;      
1054   4                                              
1055   4                              case KEY_REDUCE:         //减号
1056   4                              
1057   4                                              test_key_cnt = 0;
1058   4                                              //learn_key_cnt = 0;
1059   4                                              
1060   4                                              if (long_input_flag && (Main_disp_other == 0))
1061   4                                              {
1062   5                                                      if(public_val.work_count_user != public_val.work_count)
1063   5                                                              {
1064   6                                                                      public_val.work_count_user = public_val.work_count;
1065   6                                                                      write_clear_cnt_flag = 1;    /* 发送命令至主板清除开机后计数 */
1066   6                                                                      save_user_count();
1067   6                                                              }
1068   5                                              }                                       
1069   4      
1070   4                                              if (speed_mode == 1)  //高速
1071   4                                              {
1072   5                                                      write_speed_mode_flag = 1;  
1073   5                                                      speed_mode = 0;   //切到低速
1074   5                                              }
1075   4                                      
1076   4                                              break;  
1077   4                                              
1078   4                              case KEY_INCREASE:       //加号
1079   4      
1080   4                                              test_key_cnt = 0;
1081   4                                              
1082   4                                              Main_adj_key_delay = public_val.ms_timer;                                       
1083   4                                              Main_disp_other = 5;
1084   4                                              if (speed_mode == 0)  //低速
1085   4                                              {
1086   5                                                      write_speed_mode_flag = 1;  
1087   5                                                      speed_mode = 1;  //切到高速
1088   5                                              }
1089   4      #if 0
                                                      if (Main_disp_other == 0)
                                                      {
                                                              /* 进入参数菜单 */
                                                          pMenu = pItem[0].m_pcfg;    // 指向数据                             
                                                              now_menu.menu_id = 0;
                                                              now_menu.par_id = 0;
                                                              now_menu.event_flag = 1;
                                              DisplayItemNum  = 0;
              
                                                              //DisplayMenuTotal = Menu_Number[0];
                                                              DisplayMenuTotal = Menu0_Number;
                                                              if(DisplayMenuTotal > 0)
                                                      DisplayState=ST_MENU;                                                           //进入相应菜单  
                                          return;
                                                      }
              #endif                                          
1106   4                                                                                      
1107   4                                              break;  
C51 COMPILER V9.00   LED_DISPLAY                                                           05/05/2016 16:23:17 PAGE 19  

1108   4      
1109   4                              case KEY_GREEN:          //纸长
1110   4      
1111   4                                              test_key_cnt = 0;
1112   4                                              
1113   4                                              if (Main_disp_other == 0)
1114   4                                              {
1115   5                                                      /* 进入参数菜单 */
1116   5                                                  pMenu = pItem[0].m_pcfg;    // 指向数据     
1117   5                                                      now_menu.menu_id = 0;
1118   5                                                      now_menu.par_id = 0;
1119   5                                                      now_menu.event_flag = 1;
1120   5                                      DisplayItemNum  = 0;
1121   5                                                      zc_key_flag = 1;
1122   5                                                      //DisplayMenuTotal = Menu_Number[0];
1123   5                                                  edit_menu_id = 0;
1124   5                                                      DisplayMenuTotal = pItem[edit_menu_id].MenuItem_Max;;
1125   5                                                      if(DisplayMenuTotal > 0)
1126   5                                              DisplayState=ST_MENU;                                                           //进入相应菜单                                                  
1127   5                                  return;
1128   5                                              }
1129   4                                                                                      
1130   4                                              break;  
1131   4      
1132   4                              case KEY_BLUE:           //捆数
1133   4      
1134   4                                              test_key_cnt = 0;
1135   4                                              
1136   4                                              if (Main_disp_other == 0)
1137   4                                              {
1138   5                                                      /* 进入参数菜单 */
1139   5                                                  pMenu = pItem[0].m_pcfg;    // 指向数据                             
1140   5                                                      now_menu.menu_id = 0;
1141   5                                                      now_menu.par_id = 1;
1142   5                                                      now_menu.event_flag = 1;
1143   5                                      DisplayItemNum  = 1;                    
1144   5                                                      zc_key_flag = 1;
1145   5                                                      //DisplayMenuTotal = Menu_Number[0];
1146   5                                                  edit_menu_id = 0;
1147   5                                                      DisplayMenuTotal = pItem[edit_menu_id].MenuItem_Max;;
1148   5                                                      if(DisplayMenuTotal > 0)
1149   5                                              DisplayState=ST_MENU;                                                           //进入相应菜单  
1150   5                                                      
1151   5                                  return;
1152   5                                              }
1153   4                                                                                      
1154   4                                              break;  
1155   4      
1156   4                                              
1157   4                              case KEY_ENT:   //查看程序版本
1158   4      
1159   4                                              if (qz_wait == 0)  //不是切纸等待状态
1160   4                                              {
1161   5                                                      //learn_key_cnt = 0;
1162   5      
1163   5                                                      if (long_input_flag)
1164   5                                                      {                                               
1165   6                                                              if (test_key_cnt < TEST_MODE_CNT)
1166   6                                                              {
1167   7                                                                      test_key_cnt++;
1168   7                                                              }
1169   6                                                      }
C51 COMPILER V9.00   LED_DISPLAY                                                           05/05/2016 16:23:17 PAGE 20  

1170   5                                                      else
1171   5                                                      {
1172   6                                                              test_key_cnt = 0;
1173   6                                                      }
1174   5                                                      
1175   5                                                      Main_adj_key_delay = public_val.ms_timer;
1176   5                                                      Main_disp_other = 2;
1177   5                                              } 
1178   4                                              else   // 切纸等待状态
1179   4                                              {
1180   5                                                      write_key_flag = 1;   /* 有按键，需要写按键到主板 */
1181   5      
1182   5                                                      // 下发切纸命令
1183   5                                                      gsKeyVal = KEY_IO3;
1184   5                                                      gcKeyType = KEY_SHORT_UP_FLAG; 
1185   5                                                      
1186   5                                                      Main_disp_other = 0;  // 返回显示筒数
1187   5                                                      qz_wait = 0;   // 清等待状态
1188   5      
1189   5                                                      war_bell_step = 0;  // 清除蜂鸣器响声
1190   5                                                      cPauseBell = 0;
1191   5                                                      
1192   5                                              }
1193   4                                              
1194   4                                              break;          
1195   4      
1196   4                                      case KEY_IO3:   // 切纸
1197   4      
1198   4                                              if (qz_wait == 0)  //未等待切纸
1199   4                                              {
1200   5                                                      write_warning_flag = 1;   // 下发报警消息
1201   5                                                      
1202   5                                                      //进入切纸等待
1203   5                                                      Main_disp_other = 4;
1204   5                                                      qz_wait = 1;                                            
1205   5                                              }
1206   4                                              
1207   4                                              break;
1208   4                                              
1209   4                          }
1210   3              
1211   3                              if(Main_disp_other == 0)  /* 返回主界面 */
1212   3                              {
1213   4                                      TempCount = main_menu_cfg[0].m_rate;  
1214   4                                      TempDataB = DisplayItemNum;
1215   4                              
1216   4                                      if(!public_val.Err_Flag)                                //无报错
1217   4                                      {
1218   5                                              if(!public_val.Work_Pause_Flag)     /* 无暂停，刷新显示当前已洗饼数 */
1219   5                                              {
1220   6                                                      if(public_val.Bell_Flag == YES)   /* 蜂鸣器长暂停响 added for v19416 */
1221   6                                                      {
1222   7                                                              cPauseBell = 1;
1223   7                                                              if(!war_bell_step) war_bell_step = 1;
1224   7                                                      }
1225   6                                                      else
1226   6                                                      {
1227   7                                                              Bell_flag &= 0xfd;
1228   7                                                      }
1229   6                                                      public_val.main_disp_val = public_val.work_count - public_val.work_count_user;
1230   6                                                      DisplayValueTemp = (long)public_val.main_disp_val; 
1231   6                                                      TempValue=DataToStr(&DisplayValueTemp,
C51 COMPILER V9.00   LED_DISPLAY                                                           05/05/2016 16:23:17 PAGE 21  

1232   6                                                                          INT32_SIZE,
1233   6                                                                                              5,
1234   6                                                                                              0,
1235   6                                                                                              DisplayBuff,0,TY_D );           
1236   6                                                      LED_ShowNumber(&DisplayBuff[0],0);
1237   6                                                      
1238   6                                                      //Bell_flag &= 0xfd;   
1239   6      
1240   6                                                      
1241   6                                              }
1242   5                                              else
1243   5                                              {
1244   6                                                      LEDShowFlashString("P--",0);                                            //显示项目名称内容
1245   6                                                      DisplayValueTemp = public_val.Work_Pause_Flag & 0x7F;
1246   6                                                      if(public_val.Work_Pause_Flag & 0x80)
1247   6                                                              {
1248   7                                                                      if(!war_bell_step) war_bell_step = 1;
1249   7                                                              }
1250   6                                                      TempValue=DataToStr(&DisplayValueTemp,
1251   6                                                                          INT32_SIZE,
1252   6                                                                                              5,
1253   6                                                                                              0,
1254   6                                                                                              DisplayBuff,0,TY_D );           
1255   6                                                      LED_ShowNumber(&DisplayBuff[3],3);      
1256   6      
1257   6                                                      cPauseBell = 1;
1258   6      
1259   6                                              }
1260   5                                      }
1261   4                                      else
1262   4                                      {
1263   5                              
1264   5                                              if ((public_val.Err_Flag == P_FINISH_LEARN1)
1265   5                                                      || (public_val.Err_Flag == P_FINISH_LEARN2)) 
1266   5                                              {
1267   6                                                      //学习完成也显示送纸计数
1268   6                                                      if(public_val.Bell_Flag == YES)   /* 蜂鸣器长暂停响 added for v19416 */
1269   6                                                      {
1270   7                                                              cPauseBell = 1;
1271   7                                                              if(!war_bell_step) war_bell_step = 1;
1272   7                                                      }
1273   6                                                      else
1274   6                                                      {
1275   7                                                              Bell_flag &= 0xfd;
1276   7                                                      }
1277   6                                                      
1278   6                                                      DisplayValueTemp = (long)public_val.main_disp_val; 
1279   6                                                      TempValue=DataToStr(&DisplayValueTemp,
1280   6                                                                          INT32_SIZE,
1281   6                                                                                              5,
1282   6                                                                                              0,
1283   6                                                                                              DisplayBuff,0,TY_D );           
1284   6                                                      LED_ShowNumber(&DisplayBuff[0],0);
1285   6      
1286   6                                                      
1287   6                                              }
1288   5                                              else             // 正常报错                    
1289   5                                              {
1290   6                                                      LEDShowFlashString("E--",0);            /* modified by james at 2014-4-12 */
1291   6                                                      
1292   6                                                      if(!war_bell_step) 
1293   6                                                              war_bell_step = 1;
C51 COMPILER V9.00   LED_DISPLAY                                                           05/05/2016 16:23:17 PAGE 22  

1294   6                                                      
1295   6                                                      DisplayValueTemp = public_val.Err_Flag;
1296   6                                                      TempValue=DataToStr(&DisplayValueTemp,
1297   6                                                                          INT32_SIZE,
1298   6                                                                                              5,
1299   6                                                                                              0,
1300   6                                                                                              DisplayBuff,0,TY_D );           
1301   6                                                      LED_ShowNumber(&DisplayBuff[3],3);              
1302   6      
1303   6                                                      cPauseBell = 0;
1304   6                                              }
1305   5                                      }
1306   4      
1307   4                                      if(l_stop_poll)                                                                                         //循环显示
1308   4                                      if(++CycShowCount > main_menu_cfg[0].m_time)                            //---------------周期计数器判断     
1309   4                                      {
1310   5                                          CycShowCount=0;
1311   5                                              DisplayItemNum++;
1312   5                                              TempCount = 0; 
1313   5                                      }
1314   4                              }
1315   3                              else if(Main_disp_other == 2)    /* 显示版本号 */
1316   3                              {
1317   4                                      DisplayValueTemp = public_val.version;
1318   4                                      //DisplayValueTemp = public_val.input_pass_mask;
1319   4                                      TempValue=DataToStr(&DisplayValueTemp,
1320   4                                                          INT32_SIZE,
1321   4                                                                              5,
1322   4                                                                              0,
1323   4                                                                              DisplayBuff,0,TY_D );           
1324   4                                      LED_ShowNumber(&DisplayBuff[0],0);      
1325   4                                      if( (public_val.ms_timer - Main_adj_key_delay) > MAIN_ADJ_DELAY)
1326   4                                      {
1327   5                                              Main_disp_other = 3;
1328   5                                      }
1329   4                              }
1330   3                              else if(Main_disp_other == 3)    /* 显示传感器等输入IO值 */
1331   3                              {
1332   4                                      DisplayValueTemp = (long)public_val.io_read;
1333   4                                      //DisplayValueTemp &= 0xff;
1334   4                                      DisplayValueTemp &= 0xffff;
1335   4                                      TempValue=DataToStr(&DisplayValueTemp,
1336   4                                                          INT32_SIZE,
1337   4                                                                              5,
1338   4                                                                              0,
1339   4                                                                              DisplayBuff,0,TY_D );           
1340   4                                      LED_ShowNumber(&DisplayBuff[0],0);      
1341   4                              }
1342   3                              else if (Main_disp_other == 4)    /* 切纸等待 */
1343   3                              {
1344   4                                      LEDShowFlashString("Q2---",0);
1345   4      
1346   4                                      if(!war_bell_step) 
1347   4                                              war_bell_step = 1;                                              
1348   4      
1349   4                                      cPauseBell = 1;         
1350   4                              }
1351   3                              else if(Main_disp_other == 5)    /* 显示传感器等输入IO值 */
1352   3                              {
1353   4                                      DisplayValueTemp = (long)public_val.password_index_disp;
1354   4                                      //DisplayValueTemp = (long)(public_val.password_val[0] << 8) + public_val.password_val[1];
1355   4                                      //DisplayValueTemp &= 0xff;
C51 COMPILER V9.00   LED_DISPLAY                                                           05/05/2016 16:23:17 PAGE 23  

1356   4                                      DisplayValueTemp &= 0xffff;
1357   4                                      TempValue=DataToStr(&DisplayValueTemp,
1358   4                                                          INT32_SIZE,
1359   4                                                                              5,
1360   4                                                                              0,
1361   4                                                                              DisplayBuff,0,TY_D );           
1362   4                                      LED_ShowNumber(&DisplayBuff[0],0);      
1363   4                              }
1364   3                  }
1365   2      
1366   2                      if (test_key_cnt == TEST_MODE_CNT)  /* 长按计数后进入测试参数设置界面 added by james for v19407 */
1367   2                      {
1368   3                              test_key_cnt = 0;
1369   3                              DisplayState = ST_TEST;
1370   3                              Main_disp_other = 4;
1371   3                              
1372   3                              test_set_display(test_mode);
1373   3                      }               
1374   2      
1375   2              #if 0
                              if (learn_key_cnt == LEARN_MODE_CNT)  /* 长按计数后进入测试参数设置界面 added by james for v19407 */
                              {
                                      learn_key_cnt = 0;
                                      DisplayState = ST_LEARN;
                                      Main_disp_other = 0;    
                                      
                                      LEDShowFlashString("P-- 0",0);
              
                                      public_val.Err_Flag = 0;   
              
                                      write_learn_mode_flag = 1;  
                              }       
                      #endif
1389   2                      
1390   2                  break;
1391   2      
1392   2      
1393   2                      case ST_PASSWORD://---------------------------------------------密码输入界面
1394   2      
1395   2                      switch(Key_Val)
1396   2                          {
1397   3                              case KEY_SEL:
1398   3                                  DisplayItemNum = 0;                 
1399   3                                              //DisplayItemNum0 = 0;
1400   3                                              //DisplayItemNum1 = 0;
1401   3                                  DisplayState = ST_MAIN;
1402   3                                  return;  
1403   3                                  break;      
1404   3                              case KEY_REDUCE:
1405   3                                      if(--DisplayBitNum < 0)
1406   3                                          DisplayBitNum=4;            
1407   3                                  break;      
1408   3                              case KEY_INCREASE:
1409   3                                      if( ++PasswordBuff[DisplayBitNum] > '9')
1410   3                                          PasswordBuff[DisplayBitNum]='0';                    
1411   3                                  break;      
1412   3                              case KEY_ENT:
1413   3                                  for(TempCountB=1;TempCountB<MenuTotals;TempCountB++)
1414   3                                  {
1415   4                                      if(PasswordBuff[0]==pItem[TempCountB].m_pass[0])//
1416   4                                      if(PasswordBuff[1]==pItem[TempCountB].m_pass[1])//
1417   4                                      if(PasswordBuff[2]==pItem[TempCountB].m_pass[2])//
C51 COMPILER V9.00   LED_DISPLAY                                                           05/05/2016 16:23:17 PAGE 24  

1418   4                                      if(PasswordBuff[3]==pItem[TempCountB].m_pass[3])//
1419   4                                      if(PasswordBuff[4]==pItem[TempCountB].m_pass[4])//密码符合要求
1420   4                                      {
1421   5                                              if(TempCountB == MENU_ID_10104)
1422   5                                                      {
1423   6                                                              if(  ((public_val.Disp_Dz_10103[10] == 0)     //密码6为空或者校验成功，允许进入10104
1424   6                                                                                      &&(public_val.Disp_Dz_10103[11] == 0))
1425   6                                                                                      ||(public_val.input_pass_mask & 0x20)
1426   6                                                                                      ||(public_val.Disp_Dz_10104[PASS_LOCK_COUNT - 1] == 0)
1427   6                                                                                 )
1428   6                                                                      {
1429   7                                                                              ;
1430   7                                                                      }
1431   6                                                                              else
1432   6                                                                                      return;
1433   6                                                      }
1434   5                                                              edit_menu_id = TempCountB; 
1435   5                                                          pMenu = pItem[TempCountB].m_pcfg;                                   
1436   5                                                              now_menu.menu_id = edit_menu_id;
1437   5                                                              now_menu.par_id = 0;
1438   5                                                              now_menu.event_flag = 1;
1439   5                                          DisplayItemNum  = 0;                                        
1440   5                                                              DisplayMenuTotal = pItem[edit_menu_id].MenuItem_Max;
1441   5                                                              if(DisplayMenuTotal > 0)
1442   5                                              DisplayState=ST_MENU;                                                           //进入相应菜单                    
1443   5                                          return;
1444   5                                      }                
1445   4                                  }                                                                                                           
1446   3                                              return;
1447   3                                  break;                      
1448   3                          }
1449   2                      if( flash_flag  && !long_input_flag  )                                                                                          //闪烁功能
1450   2                      {       
1451   3                          LEDClearChar(DisplayBitNum, 1);
1452   3                      }
1453   2                      else
1454   2                      {
1455   3                          LEDShowFlashString(&PasswordBuff[0], 0);            
1456   3                      }               
1457   2                  
1458   2                              break;
1459   2      
1460   2                      case ST_LEARN:
1461   2      
1462   2                              switch(Key_Val) 
1463   2                          {
1464   3                              case KEY_SEL:  // 选择键返回
1465   3                                      Main_disp_other = 0;
1466   3                                              DisplayBitNum = 4;
1467   3                                              CycShowCount  = 0;
1468   3                                              now_menu.menu_id = 888;
1469   3                                              now_menu.event_flag = 1;
1470   3                                  DisplayItemNum = 0; 
1471   3                                  DisplayState   = ST_MAIN;                                                                                   //返回主界面
1472   3                                  
1473   3                                              war_bell_step = 0;  // 清除蜂鸣器响声
1474   3                                              cPauseBell = 0;
1475   3      
1476   3                                              return;
1477   3                                              
1478   3                                              break;  
1479   3                                              
C51 COMPILER V9.00   LED_DISPLAY                                                           05/05/2016 16:23:17 PAGE 25  

1480   3                                      default:
1481   3                                              break;
1482   3                              }
1483   2      
1484   2                              if ((public_val.Err_Flag == P_FINISH_LEARN1)
1485   2                                      || (public_val.Err_Flag == P_FINISH_LEARN2))
1486   2                              {
1487   3                                      if (public_val.Err_Flag == P_FINISH_LEARN1)    // 学习完成
1488   3                                      {
1489   4                                              LEDShowFlashString("P-- 1",0);
1490   4      
1491   4                                              if(!war_bell_step) 
1492   4                                                      war_bell_step = 1;                                              
1493   4      
1494   4                                              cPauseBell = 1;                                         
1495   4                                      }
1496   3                                      else if (public_val.Err_Flag == P_FINISH_LEARN2)    // 学习完成
1497   3                                      {
1498   4                                              LEDShowFlashString("P-- 2",0);
1499   4      
1500   4                                              if(!war_bell_step) 
1501   4                                                      war_bell_step = 1;                                              
1502   4      
1503   4                                              cPauseBell = 1;                                         
1504   4                                      }
1505   3                              }       
1506   2                              else
1507   2                              {
1508   3                                      LEDShowFlashString("P-- 0",0);
1509   3                                      war_bell_step = 0;
1510   3                                      cPauseBell = 0; 
1511   3                              }
1512   2      
1513   2                              break;
1514   2      
1515   2                      case ST_TEST:        /* 测试参数设置界面响应 added by james for v19407 */
1516   2                              switch(Key_Val)
1517   2                          {
1518   3                              case KEY_SEL:
1519   3                                      Main_disp_other = 0;
1520   3                                              DisplayBitNum = 4;
1521   3                                              CycShowCount  = 0;
1522   3                                              now_menu.menu_id = 888;
1523   3                                              now_menu.event_flag = 1;
1524   3                                  DisplayItemNum = 0; 
1525   3                                  DisplayState   = ST_MAIN;                                                                                   //返回主界面
1526   3                                  break;      
1527   3      
1528   3                                      case KEY_INCREASE:
1529   3                                              if (test_mode < 1)
1530   3                                              {
1531   4                                                      test_mode++;
1532   4      
1533   4                                                      write_test_mode_flag = 1;  /* 写测试模式到主板 */
1534   4                                              }
1535   3                                              test_set_display(test_mode);
1536   3                                              
1537   3                                              if (test_mode > 0)  /* 测试模式 */
1538   3                                              {
1539   4                                                      //ResetDoorForTest();
1540   4                                              }                                       
1541   3                                              break;
C51 COMPILER V9.00   LED_DISPLAY                                                           05/05/2016 16:23:17 PAGE 26  

1542   3      
1543   3                                      case KEY_REDUCE:
1544   3                                              if (test_mode > 0)
1545   3                                              {
1546   4                                                      test_mode--;
1547   4      
1548   4                                                      write_test_mode_flag = 1;  /* 写测试模式到主板 */                                               
1549   4                                              }
1550   3                                              test_set_display(test_mode);                                    
1551   3                                              break;
1552   3      
1553   3                                      case KEY_IO7:  // 启动
1554   3                                              LEDShowFlashString("   11",0);
1555   3                                              break;
1556   3      
1557   3                                      case KEY_IO8:  // 停止
1558   3                                              LEDShowFlashString("   12",0);
1559   3                                              break;
1560   3      
1561   3                                      case KEY_RED:  // 收纸
1562   3                                              LEDShowFlashString("   13",0);
1563   3                                              break;
1564   3      
1565   3                                      case KEY_IO9:  // 发纸
1566   3                                              LEDShowFlashString("   14",0);
1567   3                                              break;
1568   3      
1569   3                                      case KEY_IO2:  // 退纸
1570   3                                              LEDShowFlashString("   15",0);
1571   3                                              break;
1572   3      
1573   3                                      case KEY_IO1:  // 进纸
1574   3                                              LEDShowFlashString("   16",0);
1575   3                                              break;
1576   3      
1577   3                                      case KEY_IO4:  // 下料
1578   3                                              LEDShowFlashString("   17",0);
1579   3                                              break;
1580   3      
1581   3                                      case KEY_IO5:  // 搓条
1582   3                                              LEDShowFlashString("   18",0);
1583   3                                              break;
1584   3      
1585   3                                      case KEY_IO6:  // 停止送纸
1586   3                                              LEDShowFlashString("   19",0);
1587   3                                              break;
1588   3      
1589   3                                      case KEY_IO3:  // 切纸
1590   3                                              LEDShowFlashString("   20",0);
1591   3                                              break;
1592   3                                              
1593   3                                      case KEY_GREEN:  // 纸长
1594   3                                              LEDShowFlashString("   21",0);
1595   3                                              break;
1596   3      
1597   3                                      case KEY_BLUE:  // 捆数
1598   3                                              LEDShowFlashString("   22",0);
1599   3                                              break;
1600   3                                              
1601   3                                      default:
1602   3                                              break;
1603   3                              }
C51 COMPILER V9.00   LED_DISPLAY                                                           05/05/2016 16:23:17 PAGE 27  

1604   2      
1605   2      
1606   2                      break;
1607   2      
1608   2                  case ST_MENU:                       /* 菜单数据查看 */
1609   2                  { 
1610   3                      switch(Key_Val)
1611   3                          {
1612   4                              case KEY_SEL:
1613   4                                      Main_disp_other = 0;
1614   4                                              DisplayBitNum = 4;
1615   4                                              CycShowCount  = 0;
1616   4                                              now_menu.menu_id = 888;
1617   4                                              now_menu.event_flag = 1;
1618   4                                  DisplayItemNum = 0; 
1619   4                                  DisplayState   = ST_MAIN;                                                                                   //返回主界面
1620   4                                              //DIS_OPTIONING=0;
1621   4                                  break;      
1622   4                              case KEY_REDUCE:
1623   4                                  if (DisplayItemNum-- == 0)
1624   4                                      DisplayItemNum = DisplayMenuTotal-1;    
1625   4                                              now_menu.par_id = DisplayItemNum;
1626   4                                              
1627   4                                              now_menu.par_id = DisplayItemNum;
1628   4                                              now_menu.event_flag = 1;
1629   4                                              //add by yq
1630   4                                              if (cMenuSn-- <= 10)
1631   4                                                      cMenuSn = 29;
1632   4                                  break;      
1633   4                              case KEY_INCREASE:
1634   4      
1635   4                                  if (++DisplayItemNum >= DisplayMenuTotal) 
1636   4                                      DisplayItemNum = 0;     
1637   4      
1638   4                                              now_menu.par_id = DisplayItemNum;
1639   4                                              now_menu.event_flag = 1;
1640   4                                              //add by yq
1641   4                                              if (cMenuSn++ >= 29)
1642   4                                                      cMenuSn = 10;
1643   4                                  break;      
1644   4                              case KEY_ENT:   
1645   4                                              if(
1646   4                                                      (now_menu.menu_id == MENU_ID_10104)  //设定数校验是否有权限修改
1647   4                                                      )
1648   4                                                      {
1649   5                                                              if(public_val.input_pass_mask & (1<<DisplayItemNum))
1650   5                                                                      {
1651   6                                                                              zc_key_flag = 5;
1652   6                                                                      }
1653   5                                                      }
1654   4                                              else if(now_menu.menu_id == MENU_ID_10103)
1655   4                                                      {
1656   5                                                              if(public_val.input_pass_mask & (1<<(DisplayItemNum>>1)))
1657   5                                                                      {
1658   6                                                                              zc_key_flag = 5;
1659   6                                                                      }
1660   5                                                      }
1661   4                                              else
1662   4                                                      {
1663   5                                                              zc_key_flag = 5;
1664   5                                                      }
1665   4                                  break;                      
C51 COMPILER V9.00   LED_DISPLAY                                                           05/05/2016 16:23:17 PAGE 28  

1666   4                          }        
1667   3      
1668   3                              //纸长按键特殊处理
1669   3                              //////////////////////////////////////////////////////////////////////////////////////
1670   3                              if (now_menu.menu_id == 0 && zc_key_flag)
1671   3                                      {
1672   4                                              zc_key_flag ++;
1673   4                                      }
1674   3      
1675   3                              if(zc_key_flag == 5)
1676   3                                      {
1677   4                                              zc_key_flag = 0;
1678   4                                          TempDataB = DisplayItemNum;
1679   4                                              if (TY_D == TY_B  || 
1680   4                                                      TY_D == TY_D  ||  
1681   4                                                      TY_D == TY_H)                                                                   //数值类
1682   4                                              {
1683   5                                                      DisplayBitNum = 4;
1684   5                                                      DataType=TY_D;
1685   5      
1686   5                                                      //锁机相关操作特殊处理
1687   5                                                      if( (now_menu.menu_id == MENU_ID_10103)                 //未解锁不显示密码
1688   5                                                          && (!(public_val.input_pass_mask & (1<<(DisplayItemNum>>1)))) //锁定状态下锁机参数全部显示为0
1689   5                                                              )
1690   5                                                              TempInputData = 0;
1691   5                                                  else
1692   5                                                      TempInputData = *(int *)pDataValue->m_data_vale;                        
1693   5      
1694   5                                                      DisplayState=ST_DATA_INPUT;                                                                             //进入参数输入界面
1695   5      
1696   5                                                      pDataValue=&pMenu[TempDataB];
1697   5                                                      DataType=TY_D;
1698   5                                                      TempValue=DataToStr(pDataValue->m_data_vale,
1699   5                                                                      INT16_SIZE,
1700   5                                                                                          DEFAUT_POSE,
1701   5                                                                                          DEFAUT_POT,
1702   5                                                                                          DisplayBuff,0,DataType);                            
1703   5                                                      
1704   5                                                      InputDataLen = DEFAUT_POSE+DEFAUT_POT;
1705   5                                                      //DisplayBitNum = InputDataLen - 1; 
1706   5                                                      PasswordBuff[0] = '0';
1707   5                                                      PasswordBuff[1] = '0';
1708   5                                                      switch(InputDataLen)
1709   5                                                      {       /*用于复制显示缓冲区数据*/                                  
1710   6                                                      case 3:
1711   6                                                              PasswordBuff[2]=DisplayBuff[TempValue];
1712   6                                                              if(PasswordBuff[2] == ' ') PasswordBuff[2] = '0';
1713   6                                                              PasswordBuff[3]=DisplayBuff[TempValue+1];
1714   6                                                              if(PasswordBuff[3] == ' ') PasswordBuff[3] = '0';
1715   6                                                              PasswordBuff[4]=DisplayBuff[TempValue+2];                               
1716   6                                                          break;                      
1717   6                                                      case 2:
1718   6                                                              PasswordBuff[2]=' ';
1719   6                                                              PasswordBuff[3]=DisplayBuff[TempValue+1];
1720   6                                                              if(PasswordBuff[3] == ' ') PasswordBuff[3] = '0';
1721   6                                                              PasswordBuff[4]=DisplayBuff[TempValue+2];                               
1722   6                                                          break;              
1723   6                                                      case 1:
1724   6                                                              PasswordBuff[2]=' ';
1725   6                                                              PasswordBuff[3]=' ';
1726   6                                                              PasswordBuff[4]=DisplayBuff[TempValue+2];
1727   6                                                              break;                          
C51 COMPILER V9.00   LED_DISPLAY                                                           05/05/2016 16:23:17 PAGE 29  

1728   6                                                      }
1729   5                                                      pr_long_input_flag = 0;
1730   5                                                      //pDataValue.m_max = 999;
1731   5                                                      //pDataValue.m_min = 0;
1732   5                                                      DisplayState=ST_DATA_INPUT;                                                                             //进入参数输入界面
1733   5                                              }       
1734   4                                      }
1735   3                              //////////////////////////////////////////////////////////////////////////////////////
1736   3                                      
1737   3                              if(TempCount > 0)           
1738   3                              {       
1739   4                                      TempCount-- ;
1740   4                                      break;          
1741   4                              }
1742   3                              TempCount = main_menu_cfg[0].m_rate;  
1743   3      
1744   3                          pDataValue=&pMenu[DisplayItemNum];  
1745   3      //密码校验成功，进入菜单显示内容，以及翻动参数显示内容
1746   3      #if MENU_PASS_ON
1747   3                              //锁机相关操作特殊处理
1748   3                              if( (now_menu.menu_id == MENU_ID_10103)                 //未解锁不显示密码
1749   3                                  && (!(public_val.input_pass_mask & (1<<(DisplayItemNum>>1)))) //锁定状态下锁机参数全部显示为0
1750   3                                      )
1751   3                                      TempInputData = 0;
1752   3                          else
1753   3      #endif                          
1754   3                              TempInputData = *(int *)pDataValue->m_data_vale;                        
1755   3      
1756   3                              LEDShowCaption(DisplayItemNum);
1757   3      
1758   3                              TempValue=DataToStr(&TempInputData,   //pDataValue->m_data_vale
1759   3                                                  INT32_SIZE,      //pDataValue->m_size,
1760   3                                                                      DEFAUT_POSE,
1761   3                                                                      DEFAUT_POT,
1762   3                                                                      DisplayBuff,0,TY_D );           
1763   3                              LED_ShowNumber(&DisplayBuff[TempValue],2);
1764   3                  }
1765   2                  break;
1766   2      
1767   2                  case ST_DATA_INPUT: /* 数据输入画面 */
1768   2                  {
1769   3                      switch(Key_Val)
1770   3                          {
1771   4                              case KEY_SEL:   
1772   4                                              if (now_menu.menu_id == 0)
1773   4                                                      {
1774   5                                                      Main_disp_other = 0;
1775   5                                                              DisplayBitNum = 4;
1776   5                                                              CycShowCount  = 0;
1777   5                                                              now_menu.menu_id = 888;
1778   5                                                              now_menu.event_flag = 1;
1779   5                                                  DisplayItemNum = 0; 
1780   5                                                  DisplayState   = ST_MAIN;                                                                                   //返回主界面
1781   5                                                      }
1782   4                                              else
1783   4                                              DisplayState = ST_MENU;
1784   4                                  break;      
1785   4                              case KEY_REDUCE: //减少
1786   4                                      if(pMenu[DisplayItemNum].ext_property & 0x01)
1787   4                                              {
1788   5                                                      ;
1789   5                                              }
C51 COMPILER V9.00   LED_DISPLAY                                                           05/05/2016 16:23:17 PAGE 30  

1790   4                                      else
1791   4                                              {
1792   5                                                              TempInputData-=long_key_step;
1793   5                                                              if(TempInputData<pDataValue->m_min) //
1794   5                                                                      TempInputData = pDataValue->m_min; //pDataValue->m_min;
1795   5                                                      }
1796   4                                  break;      
1797   4                              case KEY_INCREASE: //增加
1798   4                                      if(pMenu[DisplayItemNum].ext_property & 0x01)
1799   4                                              {
1800   5                                                              ;
1801   5                                              }
1802   4                                      else
1803   4                                              {
1804   5                                                              TempInputData+=long_key_step;
1805   5                                                              temp_max = pDataValue->m_max;
1806   5                                                              if(TempInputData>temp_max) // temp_max
1807   5                                                                      TempInputData=temp_max;
1808   5                                                      }
1809   4                                  break;      
1810   4                              case KEY_ENT:
1811   4                                      if(!long_input_flag)
1812   4                                      {                       
1813   5                                                      TempInputData=StrToData(PasswordBuff,5,DataType);
1814   5                                                      if(TempInputData <= pDataValue->m_max && TempInputData >= pDataValue->m_min)
1815   5                                                      {
1816   6                                                      switch(INT16_SIZE)
1817   6                                                          {
1818   7                                                          case INT32_SIZE:
1819   7                                                              *(long *)pDataValue->m_data_vale = TempInputData;
1820   7                                                              break;
1821   7                                                          case INT16_SIZE:
1822   7                                                              *(int *)pDataValue->m_data_vale = (int)TempInputData;
1823   7                                                              break;                  
1824   7                                                          case INT8_SIZE:
1825   7                                                              *(char *)pDataValue->m_data_vale = (char)TempInputData;
1826   7                                                              break;                  
1827   7                                                              }       
1828   6                                                              if(PasswordBuff[2] == '0')
1829   6                                                                      {
1830   7                                                                              PasswordBuff[2] = ' ';
1831   7                                                                              if(PasswordBuff[3] == '0') PasswordBuff[3] = ' ';
1832   7                                                                      }
1833   6                                                              LED_ShowNumber(&PasswordBuff[2],2);
1834   6      
1835   6      #if MENU_PASS_ON
1836   6                                                              //修改操作，校对密码是否与保存的一致
1837   6                                                              if( now_menu.menu_id == MENU_ID_10102)
1838   6                                                                      {
1839   7                                                                              TempB = DisplayItemNum / 2;
1840   7                                                                              //for(TempB = 0; TempB < PASS_LOCK_COUNT; TempB++)
1841   7                                                                                      {
1842   8                                                                                              if( (public_val.Disp_Dz_10103[TempB * 2] == public_val.Disp_Dz_10102[TempB * 2])
1843   8                                                                                                      && (public_val.Disp_Dz_10103[TempB * 2 + 1] == public_val.Disp_Dz_10102[TempB * 2 + 1]) 
1844   8                                                                                                      )
1845   8                                                                                                      {
1846   9                                                                                                              public_val.input_pass_mask |= 1 << TempB;
1847   9                                                                                                              public_val.Disp_Dz_10104[TempB] = 0;
1848   9                                                                                                              for(i = 0; i < TempB; i ++)                             //此段以下的都清除
1849   9                                                                                                                      public_val.Disp_Dz_10104[i] = 0;
1850   9                                                                                                              func_menu_update(MENU_ID_10104);
1851   9                                                                                                      }
C51 COMPILER V9.00   LED_DISPLAY                                                           05/05/2016 16:23:17 PAGE 31  

1852   8                                                                                      }
1853   7                                                                              
1854   7                                                                                      DisplayState = ST_MENU;;                                                                        
1855   7                                                                      }
1856   6                                                              else
1857   6      #endif
1858   6                                                                      func_menu_update(now_menu.menu_id);
1859   6                                                                              
1860   6      
1861   6                                                              /* 如果将倒数第2个参数改为1则全部恢复默认参数 added by james for v19407 */
1862   6                                                              /*if ((DisplayItemNum == PARM_DEFAULT)
1863   6                                                                      && (TempInputData == 1))
1864   6                                                              {
1865   6                                                                      for (i = 0; i < MENU_ID_00000_MAX_ITEM; i++)
1866   6                                                                      {
1867   6                                                                              public_val.menu_parm[i] = iDefaultParm[i];
1868   6                                                                      }
1869   6                                                              }*/
1870   6                                                              
1871   6                                                              
1872   6                                                      }
1873   5                                      }
1874   4      
1875   4                                              if (now_menu.menu_id == 0)
1876   4                                                      {
1877   5                                                      Main_disp_other = 0;
1878   5                                                              DisplayBitNum = 4;
1879   5                                                              CycShowCount  = 0;
1880   5                                                              now_menu.menu_id = 888;
1881   5                                                              now_menu.event_flag = 1;
1882   5                                                  DisplayItemNum = 0; 
1883   5                                                  DisplayState   = ST_MAIN;                                                                                   //返回主界面
1884   5                                                      }
1885   4                                              else
1886   4                                              DisplayState = ST_MENU;
1887   4                                              
1888   4                                  break;                      
1889   4                          }
1890   3      
1891   3                      if( flash_flag && !long_input_flag )  //闪烁功能
1892   3                      {       
1893   4                          LEDClearChar(DisplayBitNum,1);
1894   4                      }
1895   3                      else                    
1896   3                      {
1897   4                                              LEDShowCaption(DisplayItemNum);
1898   4                                      TempValue=DataToStr(&TempInputData,
1899   4                                                      INT32_SIZE,
1900   4                                                                      5,
1901   4                                                                      0,
1902   4                                                                      DisplayBuff,0,TY_D );   
1903   4      
1904   4                                      PasswordBuff[2]=DisplayBuff[TempValue];
1905   4                                      if(PasswordBuff[2] == ' ') PasswordBuff[2] = '0';
1906   4                                      PasswordBuff[3]=DisplayBuff[TempValue+1];
1907   4                                      if(PasswordBuff[3] == ' ') PasswordBuff[3] = '0';
1908   4                                      PasswordBuff[4]=DisplayBuff[TempValue+2];                                               
1909   4                                      LED_ShowNumber(&PasswordBuff[2],2);     
1910   4                                      
1911   4                      }
1912   3                  }   
1913   2                  break;      
C51 COMPILER V9.00   LED_DISPLAY                                                           05/05/2016 16:23:17 PAGE 32  

1914   2                      
1915   2                      case ST_DISP_ERR:
1916   2                      {
1917   3                              if(public_val.ms_timer - now_menu.err_dsip_delay > DISP_ERR_TIMER )
1918   3                              {
1919   4                                      DisplayState = now_menu.chang_next_step;
1920   4                              }
1921   3                              else
1922   3                              {
1923   4                                      LEDShowFlashString("  Err",0);
1924   4                              }
1925   3                      }
1926   2                      break;
1927   2                      
1928   2                      default :
1929   2                      DisplayState = ST_MAIN;
1930   2                              //DIS_OPTIONING=0;
1931   2                  break;                              
1932   2                      
1933   2              }
1934   1          if(LCDDisplayState != DisplayState)
1935   1              {
1936   2                      LCDDisplayState = DisplayState;
1937   2                      
1938   2                      switch(LCDDisplayState)
1939   2                      {
1940   3                              case ST_MAIN:
1941   3                                      GpuSend("CLS(0);\r\n");
1942   3                                      DELAY_US(UART2_DELAY);
1943   3                                      //add 0407
1944   3                                      DELAY_US(UART1s_DELAY);
1945   3                                      //cAlarmFlag = 0;                                               
1946   3                                      //add 0407
1947   3                                      GpuSend("SPG(52);\r\n");
1948   3                                      
1949   3                                      break;
1950   3                              case ST_PASSWORD:
1951   3                                      //add 0323
1952   3                                      GpuSend("CLS(0);\r\n");
1953   3                                      DELAY_US(UART2_DELAY);
1954   3                                      //add 0407
1955   3                                      DELAY_US(UART1s_DELAY);
1956   3      
1957   3                                      GpuSend("SPG(27);\r\n");
1958   3                                      DELAY_US(UART2_DELAY);          
1959   3                                      GpuSend("DS48(20,174,'00000',0);\r\n");
1960   3                                      DELAY_US(UART2_DELAY);
1961   3                                      
1962   3                                      break;
1963   3                              case ST_MENU ://--参数查看画面
1964   3      
1965   3                                      GpuSend("CLS(0);\r\n");
1966   3                                      DELAY_US(UART2_DELAY);
1967   3                                      MenuEditLook(cMenuSn);
1968   3                                      break;
1969   3                              case ST_DATA_INPUT://--数据输入画面
1970   3                              break;
1971   3                              case ST_CODE_INPUT://--代码输入画面
1972   3                              case ST_Show_Err://--错误提示画面
1973   3                              break;
1974   3                              case ST_ADJ://--直接调参数画面
1975   3                              break;
C51 COMPILER V9.00   LED_DISPLAY                                                           05/05/2016 16:23:17 PAGE 33  

1976   3                              case ST_WAIT_VER://--等待返校结果
1977   3                              break;
1978   3                              case ST_DISP_ERR://延时显示修改出错
1979   3                              break;
1980   3                              case ST_TEST://--测试参数设置  added by james for v19407
1981   3                              break;
1982   3                              case ST_LEARN://--学习模式
1983   3                              break;
1984   3                              case 0:
1985   3                              
1986   3                              break;
1987   3                      }
1988   2              }       
1989   1      
1990   1              if(!UpdateState)
1991   1              {
1992   2                      UpdateState = 1;
1993   2                      UpdateCountB = public_val.ms_timer;
1994   2              }
1995   1              else
1996   1              {
1997   2                      if(public_val.ms_timer - UpdateCountB > 100)
1998   2                      {
1999   3                              flash_flag = !flash_flag;
2000   3                              UpdateState = 0;
2001   3                      }               
2002   2              }
2003   1      
2004   1      
2005   1              switch(war_bell_step)  /* 蜂鸣器报警处理 */
2006   1              {
2007   2                      case 1:
2008   2                              war_bell_delay = public_val.ms_timer;
2009   2                              Bell_flag |= 0x02;
2010   2                              war_bell_step = 10;
2011   2                      break;
2012   2                      case 10:
2013   2                              iBellOnTime = (cPauseBell == 0) ? 500 : 50;
2014   2                              //iBellOnTime = (cPauseBell == 0) ? 2000 : 50;
2015   2                              if(public_val.ms_timer - war_bell_delay > iBellOnTime) //响的时间
2016   2                                      {
2017   3                                              war_bell_delay = public_val.ms_timer;
2018   3                                              Bell_flag &= 0xfd;
2019   3                                              war_bell_step = 20;
2020   3                                      }
2021   2                      break;
2022   2                      case 20:
2023   2                              iBellOffTime = (cPauseBell == 0) ? 2000 : 2000;                 
2024   2                              //iBellOffTime = (cPauseBell == 0) ? 200 : 2000;                        
2025   2                              if(public_val.ms_timer - war_bell_delay > iBellOffTime) //不响的时间
2026   2                                      {
2027   3                                              war_bell_delay = public_val.ms_timer;
2028   3                                              war_bell_step = 30;
2029   3                                      }                       
2030   2                      break;
2031   2                      case 30:
2032   2                              if((!public_val.Err_Flag) 
2033   2                                 && (!(public_val.Work_Pause_Flag & 0x80))
2034   2                                 && (!public_val.Bell_Flag))  /* added for v19416 */
2035   2                                      {
2036   3                                              war_bell_step = 0;   /* 无报错 */
2037   3                                      }
C51 COMPILER V9.00   LED_DISPLAY                                                           05/05/2016 16:23:17 PAGE 34  

2038   2                              else
2039   2                                      {
2040   3                                              war_bell_step = 1;
2041   3                                      }
2042   2                      break;
2043   2              }
2044   1              
2045   1              if(Bell_flag)
2046   1              {
2047   2                      BELL = 1;
2048   2              }
2049   1              else
2050   1              {
2051   2                      BELL = 0;
2052   2              }
2053   1              
2054   1      
2055   1              TM1637_Write();
2056   1      
2057   1              
2058   1      }
2059                          
2060          
2061          /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
2062          功能：整形变字符型
2063          
2064          参数：nBit:整数位个数，nPoint:小数位个数  ,nFlag==1整数位前的0以空格补充
2065          
2066          返回值：高位空格数
2067          ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
2068          static char DataToStr(void * const pData,char size,char nBit,char nPoint,char *string,char nFlag,char nTyp
             -e)
2069          {       
2070   1              long DataS32Bit;
2071   1              char spaces;
2072   1              char Temp,module;
2073   1              char SignZero;//负数标志位,  >0: 0,  <0: 1
2074   1              
2075   1              if(size==0 || size>4)//判断size的合理性
2076   1                  return 0;
2077   1              size--;
2078   1      //      if( ( *((char *)(pData)+size) ) & 0x80 )//判断最高位是否为1
2079   1      //          SignZero=1;
2080   1      //      else
2081   1                  SignZero=0; 
2082   1                  
2083   1          DataS32Bit=0;
2084   1              if(size==3)//LONG型数据
2085   1              {                           
2086   2                      if(SignZero)
2087   2                          *((long *)&DataS32Bit) = 0 - *((long *)pData);
2088   2                      else
2089   2                          *((long *)&DataS32Bit) = *((long *)pData);
2090   2              }       
2091   1              else if(size==1)//INT型数据
2092   1              {
2093   2                  if(SignZero)
2094   2                          *((int *)&DataS32Bit) = 0 - *((int *)pData);                                                
2095   2                      else
2096   2                          *((int *)&DataS32Bit) = *((int *)pData);    
2097   2              }       
2098   1              else if(size==0)//char型数据
C51 COMPILER V9.00   LED_DISPLAY                                                           05/05/2016 16:23:17 PAGE 35  

2099   1              {
2100   2                  if(SignZero)
2101   2                          *((char *)&DataS32Bit) = 0 - *((char *)pData);
2102   2                      else
2103   2                          *((char *)&DataS32Bit) = *((char *)pData);
2104   2              }
2105   1              else
2106   1                      return 0;       
2107   1              
2108   1              switch(nType){
2109   2              case TY_B:
2110   2                      module=2;
2111   2                      break;
2112   2              case TY_D:
2113   2              case TY_RD:
2114   2              case TY_D_A:
2115   2              case TY_D_L:
2116   2              module=10;
2117   2                      break;
2118   2              case TY_H:
2119   2              module=16;
2120   2                      break;
2121   2              }
2122   1              
2123   1          spaces = 3-(nPoint+nBit);
2124   1              Temp = nPoint+nBit;
2125   1              if(Temp<3)
2126   1              {
2127   2                  nBit += (3-Temp);
2128   2                      Temp=3;
2129   2              }
2130   1                      
2131   1              do
2132   1          {
2133   2              if(Temp!=nBit || nFlag)
2134   2              {
2135   3                  string[Temp]='0'+(char)(DataS32Bit%(module));
2136   3                  DataS32Bit/=module;
2137   3              }
2138   2              else 
2139   2                      {
2140   3                              if(nPoint!=0)
2141   3                                  string[Temp]='.';
2142   3                              else
2143   3                                  string[Temp]=' ';
2144   3                      }
2145   2              
2146   2          }while( Temp-- >0 );
2147   1              
2148   1              if(nFlag)//nFlag==1整数位前的0以空格补充
2149   1              {
2150   2                  if(SignZero && spaces<3)
2151   2                          string[spaces]='-';
2152   2                      return 0;
2153   2          }
2154   1              
2155   1              Temp=0;
2156   1              spaces=0;
2157   1          do
2158   1          {
2159   2             if(string[Temp]=='0' && (Temp+1<nBit)) 
2160   2             {
C51 COMPILER V9.00   LED_DISPLAY                                                           05/05/2016 16:23:17 PAGE 36  

2161   3                         string[Temp]=' ';
2162   3                         spaces++;
2163   3                 }
2164   2             else
2165   2                 {
2166   3                 break;
2167   3                 }
2168   2             Temp++;
2169   2          }while(1);
2170   1              if(SignZero)
2171   1              {
2172   2                  string[--spaces]='-';
2173   2              }
2174   1              Temp=nPoint+nBit-spaces;
2175   1              if(Temp<3)
2176   1                  spaces -= (3-Temp);
2177   1              return spaces;
2178   1      }
2179          
2180          /*++++++++++++++++++++++++++++++++++++++++++++++++++++
2181          功能：需要一个函数将字符化整形
2182          
2183          参数：len 为字符长度
2184          
2185          返回值：无
2186          ++++++++++++++++++++++++++++++++++++++++++++++++++++*/
2187          static long StrToData(char *string,char len,char nType)
2188          {       
2189   1          unsigned long x,bi;     
2190   1          char i,module;
2191   1      
2192   1          switch(nType){
2193   2              case TY_B:
2194   2                      module=2;
2195   2                      break;
2196   2              case TY_D:
2197   2              module=10;
2198   2                      break;
2199   2              case TY_H:
2200   2              module=16;
2201   2                      break;
2202   2              }
2203   1              x=0;
2204   1              bi=1;
2205   1              for(i=len;i>0;)
2206   1          {
2207   2              i--;
2208   2                      if(string[i] >= '0' && string[i]<=0x3F)
2209   2                      {
2210   3                         x+=(string[i] - '0')*bi;
2211   3                         bi*=module;
2212   3              }
2213   2              }
2214   1              if(string[0]=='-' || string[1]=='-' || string[2]=='-' )//负数
2215   1                  return (0-x);
2216   1              else
2217   1                  return x;
2218   1      
2219   1      }
2220          void MenuEditLook(unsigned char cDisplayItemNum)
2221          {
2222   1              
C51 COMPILER V9.00   LED_DISPLAY                                                           05/05/2016 16:23:17 PAGE 37  

2223   1              //unsigned char DisplayItemNum;
2224   1              switch(cDisplayItemNum)
2225   1              {
2226   2                      case 10:
2227   2                              GpuSend("SPG(31);\r\n");                
2228   2                      break;
2229   2              
2230   2                      case 11:
2231   2                              GpuSend("SPG(32);\r\n");                
2232   2                      break;
2233   2                      
2234   2                      case 12:
2235   2                              GpuSend("SPG(33);\r\n");                
2236   2                      break;
2237   2                      
2238   2                      case 13:
2239   2                              GpuSend("SPG(34);\r\n");                
2240   2                      break;
2241   2                      
2242   2                      case 14:
2243   2                              GpuSend("SPG(35);\r\n");                
2244   2                      break;
2245   2                      
2246   2                      case 15:
2247   2                              GpuSend("SPG(36);\r\n");                
2248   2                      break;
2249   2                      
2250   2                      case 16:
2251   2                              GpuSend("SPG(37);\r\n");                
2252   2                      break;
2253   2                      
2254   2                      case 17:
2255   2                              GpuSend("SPG(38);\r\n");                
2256   2                      break;
2257   2                      
2258   2                      case 18:
2259   2                              GpuSend("SPG(39);\r\n");                
2260   2                      break;
2261   2                      
2262   2                      case 19:
2263   2                              GpuSend("SPG(40);\r\n");                
2264   2                      break;
2265   2                      
2266   2                      
2267   2                      case 20:
2268   2                              GpuSend("SPG(41);\r\n");                
2269   2                      break;
2270   2                      
2271   2                      
2272   2                      case 21:
2273   2                              GpuSend("SPG(42);\r\n");                
2274   2                      break;
2275   2                      
2276   2                      case 22:
2277   2                              GpuSend("SPG(43);\r\n");                
2278   2                      break;
2279   2                      
2280   2                      case 23:
2281   2                              GpuSend("SPG(44);\r\n");                
2282   2                      break;
2283   2                      
2284   2                      case 24:
C51 COMPILER V9.00   LED_DISPLAY                                                           05/05/2016 16:23:17 PAGE 38  

2285   2                              GpuSend("SPG(45);\r\n");                
2286   2                      break;
2287   2                      
2288   2                      case 25:
2289   2                              GpuSend("SPG(46);\r\n");                
2290   2                      break;
2291   2                      
2292   2                      case 26:
2293   2                              GpuSend("SPG(47);\r\n");                
2294   2                      break;
2295   2                      
2296   2                      case 27:
2297   2                              GpuSend("SPG(48);\r\n");                
2298   2                      break;
2299   2                      
2300   2                      case 28:
2301   2                              GpuSend("SPG(49);\r\n");                
2302   2                      break;
2303   2                      
2304   2                      case 29:
2305   2                              GpuSend("SPG(50);\r\n");                
2306   2                      break;          
2307   2              
2308   2              }
2309   1              
2310   1              DELAY_US(UART1s_DELAY);
2311   1      }
2312          
2313          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  10379    ----
   CONSTANT SIZE    =    892    ----
   XDATA SIZE       =   1044       1
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      4      77
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
