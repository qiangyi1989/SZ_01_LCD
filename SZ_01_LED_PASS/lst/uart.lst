C51 COMPILER V9.00   UART                                                                  04/09/2016 11:07:34 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN .\out\uart.obj
COMPILER INVOKED BY: D:\Program Files (x86)\Keil\C51\BIN\C51.EXE uart.c BROWSE DEBUG OBJECTEXTEND PRINT(.\lst\uart.lst) 
                    -OBJECT(.\out\uart.obj)

line level    source

   1          
   2          #include "reg51.h"
   3          #include "intrins.h"
   4          #include "led_display.h"
   5          #include "uart.h"
   6          #include "global.h"
   7          #include "save_cnt.h"
   8          #include "sys.h"
   9          #include <string.h>
  10          
  11          typedef unsigned char BYTE;
  12          typedef unsigned int WORD;
  13          
  14          #define FOSC 11059200L          //系统频率
  15          #define BAUD 9600             //串口波特率
  16          
  17          #define NONE_PARITY     0       //无校验
  18          #define ODD_PARITY      1       //奇校验
  19          #define EVEN_PARITY     2       //偶校验
  20          #define MARK_PARITY     3       //标记校验
  21          #define SPACE_PARITY    4       //空白校验
  22          
  23          #define PARITYBIT NONE_PARITY   //定义校验位
  24          
  25          //#define UART_REC_FRAME_DELAY 50
  26          #define UART_REC_FRAME_DELAY 10
  27          
  28          
  29          extern xdata public_stru public_val;
  30          extern xdata char uart_send_buf[100];
  31          extern code MENU_ITEM MenuItem[];
  32          extern xdata MENU_CHANG now_menu;
  33          
  34          
  35          //sfr AUXR  = 0x8e;               //辅助寄存器
  36          
  37          //sbit P22 = P2^2;
  38          
  39          bit busy;  /* 1正在发送，0发送完成 */
  40          
  41          //void SendString(char *s);
  42          
  43          xdata unsigned char Uart_RecBuf[100];
  44          void * com_data = Uart_RecBuf;
  45          
  46          
  47          char temp_char;
  48          
  49          
  50          
  51          
  52          void SendData(BYTE dat);
  53          
  54          void uart_init()
C51 COMPILER V9.00   UART                                                                  04/09/2016 11:07:34 PAGE 2   

  55          {
  56   1      #if (PARITYBIT == NONE_PARITY)
  57   1          SCON = 0x50;                //8位可变波特率
  58   1      #elif (PARITYBIT == ODD_PARITY) || (PARITYBIT == EVEN_PARITY) || (PARITYBIT == MARK_PARITY)
                  SCON = 0xda;                //9位可变波特率,校验位初始为1
              #elif (PARITYBIT == SPACE_PARITY)
                  SCON = 0xd2;                //9位可变波特率,校验位初始为0
              #endif
  63   1      
  64   1          AUXR = 0x40;                //定时器1为1T模式
  65   1          TMOD = 0x00;                //定时器1为模式0(16位自动重载)
  66   1          TL1 = (65536 - (FOSC/4/BAUD));   //设置波特率重装值
  67   1          TH1 = (65536 - (FOSC/4/BAUD))>>8;
  68   1          TR1 = 1;                    //定时器1开始启动
  69   1          ES = 1;                     //使能串口中断
  70   1          EA = 1;
  71   1      
  72   1      }
  73          
  74          /*----------------------------
  75          UART 中断服务程序
  76          -----------------------------*/
  77          
  78          void UartRecIsr() interrupt 4 using 1
  79          {
  80   1          if (RI)
  81   1          {
  82   2              RI = 0;                 //清除RI位
  83   2              Uart_RecBuf[public_val.uart_rec_count++] = SBUF;
  84   2              public_val.uart_rec_statu = 1;
  85   2              public_val.uart_rec_start_timer = public_val.ms_timer;
  86   2          }
  87   1          if (TI)
  88   1          {
  89   2              TI = 0;                 //清除TI位
  90   2              busy = 0;               //清忙标志
  91   2          }
  92   1      }
  93          
  94          /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  95          名称:   void check_uart_rec(void)
  96          功能：  接收数据帧判断
  97          参数：  无
  98          返回值：无
  99          ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
 100          void check_uart_rec(void)
 101          {
 102   1              if(public_val.uart_rec_statu == 1)
 103   1              {
 104   2                      /* 如果超过50ms未接收到数据，认为当前帧接收完，开始处理 */
 105   2                      if(public_val.ms_timer - public_val.uart_rec_start_timer > UART_REC_FRAME_DELAY)
 106   2                      {
 107   3                              public_val.uart_rec_statu = 2;  /* 置正在处理状态 */
 108   3                      }
 109   2              }
 110   1      }
 111          
 112          /*----------------------------
 113          发送串口数据
 114          ----------------------------*/
 115          void SendData(BYTE dat)
 116          {
C51 COMPILER V9.00   UART                                                                  04/09/2016 11:07:34 PAGE 3   

 117   1          while (busy);               //等待前面的数据发送完成
 118   1          ACC = dat;                  //获取校验位P (PSW.0)
 119   1          if (P)                      //根据P来设置校验位
 120   1          {
 121   2      #if (PARITYBIT == ODD_PARITY)
                      TB8 = 0;                //设置校验位为0
              #elif (PARITYBIT == EVEN_PARITY)
                      TB8 = 1;                //设置校验位为1
              #endif
 126   2          }
 127   1          else
 128   1          {
 129   2      #if (PARITYBIT == ODD_PARITY)
                      TB8 = 1;                //设置校验位为1
              #elif (PARITYBIT == EVEN_PARITY)
                      TB8 = 0;                //设置校验位为0
              #endif
 134   2          }
 135   1          busy = 1;
 136   1          SBUF = ACC;                 //写数据到UART数据寄存器
 137   1      }
 138          
 139          /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 140          名称:   Send_UartBuf(char * buf)
 141          功能：  数据发送 和校验
 142          参数：  无
 143          返回值：无
 144          ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
 145          void Send_UartBuf(char * buf)
 146          {
 147   1              int i;
 148   1              static char frame_id = 1;
 149   1              char sum_byte = 0;
 150   1              
 151   1              //buf[0] = (buf[0] & 0x03) | (frame_id << 2);
 152   1              for(i = 0; i < buf[1] + 2; i++)
 153   1              {
 154   2                      sum_byte += buf[i];
 155   2                      SendData(buf[i]);
 156   2              }
 157   1              SendData(sum_byte);
 158   1              frame_id++;
 159   1              if(!frame_id) frame_id = 1;
 160   1      }
 161          
 162          /*----------------------------
 163          发送字符串
 164          ----------------------------*/
 165          /*void SendString(char *s)
 166          {
 167              while (*s)                  //检测字符串结束标志
 168              {
 169                  SendData(*s++);         //发送当前字符
 170              }
 171          }*/
 172          
 173          #if 0
              /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
              名称:   void frame_par_func(void)
              功能：  参数字回帧处理
              参数：  无
              返回值：无
C51 COMPILER V9.00   UART                                                                  04/09/2016 11:07:34 PAGE 4   

              ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
              static void frame_par_func()
              {
                      if(now_menu.chang_par_flag == 1)
                              {
                                      if( ((rt_updata_menu_stru *)com_data)->Statu == 0x00FF )
                                              {
                                                      now_menu.chang_par_flag = 2;
                                              }
                                      else
                                              {
                                                      now_menu.chang_par_flag = 3;
                                              }
                              }
              }
              
              /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
              名称:   void frame_info_func(void)
              功能：  回帧信息字处理
              参数：  无
              返回值：无
              ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
              void frame_info_func(void)
              {
                      char menu_id,i;
                      switch(((get_ver_stru *)com_data)->cmd_type)
                              {
                                      case GET_VER_CMD:
                                              public_val.drive_type_com = ((get_ver_stru *)com_data)->ver;
                                              public_val.drive_index_com = ((get_ver_stru *)com_data)->drive_indx;
                                              if(public_val.drive_type_com != public_val.drive_type)
                                                      {
                                                              public_val.com_log_step = COMD_LOG_STEP_GET_CFG;
                                                      }
                                              else
                                                      {
                                                              public_val.com_log_step = COMD_LOG_STEP_DOWN;
                                                      }
                                              public_val.send_frame_idx = 0;
                                      break;
                                      case SET_VER_IDX_CMD:
                                              public_val.drive_indx = ((set_ver_idx_stru *)com_data)->ver_idx;
                                              public_val.drive_type = 0; //清除版本号,下次上电重新获取配置
                                              func_ver_update();
                                      break;
                                      case GET_MENU_CFG_INFO:
                                              menu_id = ((rec_menu_cfg_stru *)com_data)->menu_id;
                                              *((char*)(MenuItem[menu_id].com_max_item)) = ((rec_menu_cfg_stru *)com_data)->menu_count;
                                              for(i = 0; i < *(MenuItem[menu_id].com_max_item); i++)
                                                      {
                                                              MenuItem[menu_id].m_pcfg[i].m_max = 
                                                                      ((rec_menu_cfg_stru *)com_data)->val[i].menu_max;
                                                              MenuItem[menu_id].m_pcfg[i].m_min = 
                                                                      ((rec_menu_cfg_stru *)com_data)->val[i].menu_min;
                                                              MenuItem[menu_id].m_pcfg[i].ext_property = 
                                                                      ((rec_menu_cfg_stru *)com_data)->val[i].ext_property;
                                                      }
                                              func_cfg_update(menu_id);
                                              if(menu_id == MENU_NUM - 1) //完成菜单配置数据传输,保存版本及版本序号
                                                      {
                                                              //debug
                                                              public_val.drive_type = public_val.drive_type_com;
C51 COMPILER V9.00   UART                                                                  04/09/2016 11:07:34 PAGE 5   

                                                              public_val.drive_indx = public_val.drive_index_com;
                                                              func_ver_update();
                                                      }
                                      break;
                                      case GET_DEFAUT_VAL:
                                              menu_id = ((rec_menu_cfg_stru *)com_data)->menu_id;
                                              for(i = 0; i < *(MenuItem[menu_id].com_max_item); i++)
                                                      {
                                                              *((int *)MenuItem[menu_id].m_pcfg[i].m_data_vale) = 
                                                                      ((rec_defaut_stru *)com_data)->val[i];
                                                      }
                                              //保存菜单数据值到EEPROM
                                              func_menu_update(menu_id);
                                      break;
                                      case GET_PAR_INFO:
                                              menu_id = ((rec_menu_cfg_stru *)com_data)->menu_id;
                                              for(i = 0; i < *(MenuItem[menu_id].com_max_item); i++)
                                                      {
                                                              *((int *)MenuItem[menu_id].m_pcfg[i].m_data_vale) = 
                                                                      ((rec_defaut_stru *)com_data)->val[i];
                                                      }
                                              //保存菜单数据值到EEPROM
                                              func_menu_update(menu_id);
                                      break;
                                      case GET_STATU_INFO:
                                              public_val.Err_Flag &= 0xf0;
                                              public_val.Err_Flag |= (((rec_statu_stru *)com_data)->err_flag) & 0x0f;
                                              public_val.Work_Statu = ((rec_statu_stru *)com_data)->statu_num;
                                              public_val.Work_Pause_Flag = ((rec_statu_stru *)com_data)->pass_flag;
                                              public_val.Other_Bit_Flag = ((rec_statu_stru *)com_data)->other_bit_flag;
                                              public_val.main_disp_val = ((rec_statu_stru *)com_data)->disp_count;
                                              public_val.io_read = ((rec_statu_stru *)com_data)->io_read;
                                              if(public_val.Work_Statu  == WORK_STATU_WAIT)
                                                      {
                                                              public_val.Init_Over = 0;
                                                              public_val.com_log_step = COMD_LOG_STEP_GET_VER;
                                                      }
                                              else if(public_val.Work_Statu  >= WORK_STATU_START)
                                                      {
                                                              public_val.Init_Over = 1;
                                                      }
                                      break;
                              }
              }
              
              #endif
 287          
 288          
 289          void rec_data_func(void)
 290          {
 291   1              char i;
 292   1              char sum_byte;
 293   1          char *pcTemp = 0;
 294   1              unsigned long uiCnt;
 295   1      
 296   1              static char ucSaveLearn1 = 0, ucSaveLearn2 = 0;
 297   1      
 298   1              /* 对主板反馈的其他帧作校验 */
 299   1              sum_byte = Uart_RecBuf[0];
 300   1              for(i = 1; i < public_val.uart_rec_count - 1; i++)
 301   1              {
 302   2                      sum_byte += Uart_RecBuf[i];
C51 COMPILER V9.00   UART                                                                  04/09/2016 11:07:34 PAGE 6   

 303   2              }
 304   1      
 305   1              /* 校验失败报错返回 */
 306   1              if(sum_byte != Uart_RecBuf[public_val.uart_rec_count - 1])
 307   1              {
 308   2                      //public_val.Err_Flag = ERR_NUM_ZK_COM_ERR;             
 309   2                      public_val.Err_Flag =  LED_CHECK_ERROR;       /* 接收到校验错误帧后不发送后续帧 */
 310   2      
 311   2                      send_frame_type = UP_REPLY_DONE;  /* 可以发送下一帧 */
 312   2                      
 313   2                      return;                 
 314   2              }
 315   1      
 316   1      
 317   1              /* 校验成功，对接收帧进行处理 */        
 318   1              switch(Uart_RecBuf[0])
 319   1              {
 320   2                      /* 上行写参数帧 */
 321   2                      case UP_WRITE_PARAM:
 322   2      
 323   2                              /* 获取参数个数 */
 324   2                              //Menu_Number[0] = Uart_RecBuf[1] >> 1;    /* 载荷长度除以2为参数个数 */
 325   2      //                      Menu_Number[0] = (Uart_RecBuf[1] + Uart_RecBuf[2]) >> 1;  //所有参数个数
 326   2      //                      Menu0_Number = Uart_RecBuf[1] >> 1;                                       //菜单0参数个数
 327   2      
 328   2                              /* 提取下发的参数 */
 329   2                              pcTemp = (char *)&public_val.menu_parm[0];
 330   2                              
 331   2                              for (i = 0; i < (COM_MENU_MAX_ITEM << 1); i++)
 332   2                              {
 333   3                                      //pcTemp[i] = Uart_RecBuf[2 + i];
 334   3                                      pcTemp[i] = Uart_RecBuf[3 + i];
 335   3                              }
 336   2      
 337   2                              already_read_param = 1;  /* 置为已读到配置参数 */
 338   2      
 339   2                              send_frame_type = UP_REPLY_DONE;  /* 可以发送下一帧 */
 340   2                              
 341   2                      break;
 342   2      
 343   2                      /* 上行写状态帧 */
 344   2                      case UP_WRITE_STATE:
 345   2      
 346   2                              for(i = 0; i < PASS_LOCK_COUNT; i++)
 347   2                                      {
 348   3                                              if( (public_val.Disp_Dz_10104[i] > 0)
 349   3                                                      && (public_val.work_count > ((unsigned long)public_val.Disp_Dz_10104[i] * LOCK_UNIT))
 350   3                                                      )
 351   3                                                      {
 352   4                                                              public_val.Lock_Flag = i + 1;
 353   4                                                      }
 354   3                                      }
 355   2                              if(public_val.Disp_Dz_10104[PASS_LOCK_COUNT - 1] == 0) //完全解锁
 356   2                                      {
 357   3                                              public_val.Lock_Flag = 0;
 358   3                                      }
 359   2                              
 360   2                              public_val.version 
 361   2                                      = ((unsigned int)Uart_RecBuf[3] << 8) | (unsigned int)Uart_RecBuf[2];                   
 362   2                              
 363   2                              public_val.io_read
 364   2                                      = ((unsigned int)Uart_RecBuf[5] << 8) | (unsigned int)Uart_RecBuf[4];
C51 COMPILER V9.00   UART                                                                  04/09/2016 11:07:34 PAGE 7   

 365   2                                              
 366   2                              //if ((Uart_RecBuf[7] != 0) || (Uart_RecBuf[6] != 0))
 367   2                              //{
 368   2                              public_val.Err_Flag 
 369   2                                      = ((unsigned int)Uart_RecBuf[7] << 8) | (unsigned int)Uart_RecBuf[6];
 370   2                              //}
 371   2      
 372   2                              //public_val.disp_cnt_upload
 373   2                              uiCnt
 374   2                                      = ((unsigned long)Uart_RecBuf[9] << 8) | (unsigned long)Uart_RecBuf[8]
 375   2                                      | ((unsigned long)Uart_RecBuf[11] << 24) | ((unsigned long)Uart_RecBuf[10] << 16);
 376   2      
 377   2                              if (uiCnt != public_val.cnt_after_powered)  /* 如果筒数有更新，则保存更新 */
 378   2                              {
 379   3                                      public_val.cnt_after_powered = uiCnt;
 380   3                                      public_val.work_count++;
 381   3                                      if(public_val.work_count - public_val.work_count_user > 99999)
 382   3                                              {
 383   4                                                      public_val.work_count_user = public_val.work_count;
 384   4                                                      save_user_count();
 385   4                                              }
 386   3                                                                      
 387   3                                      save_sys_lock();
 388   3                              }
 389   2      #if 0
                                      if ((public_val.version == 11111) && (ucSaveLearn1 == 0))
                                      {
                                              public_val.menu_parm[PARAM_FZ_START_PWM_SCALE] = (int)(uiCnt & 0xFFFF);
                                              //public_val.menu_parm[PARAM_QZ_START_PWM_SCALE] = (int)((uiCnt >> 16) & 0xFFFF);
                                              
                                              func_menu_update(0);
              
                                              ucSaveLearn1 = 1;
                                      }
              
                                      if ((public_val.version == 22222) && (ucSaveLearn2 == 0))
                                      {
                                              public_val.menu_parm[PARAM_FZ_START_PWM_SCALE] = (int)(uiCnt & 0xFFFF);
                                              //public_val.menu_parm[PARAM_QZ_START_PWM_SCALE] = (int)((uiCnt >> 16) & 0xFFFF);
                                              
                                              func_menu_update(0);
              
                                              ucSaveLearn2 = 1;
                                      }
              #endif                  
 410   2                              send_frame_type = UP_REPLY_DONE;  /* 可以发送下一帧 */
 411   2                              
 412   2                      break;
 413   2      
 414   2                      /* 上行写参数范围帧 */
 415   2                      case UP_WRITE_PARAM_RANGE:
 416   2      
 417   2                              for (i = 0; i < (Uart_RecBuf[1] >> 2); i++)  /* 参数个数为载荷长度除以4 */
 418   2                              {
 419   3                                      MenuItem[MENU_ID_00000].m_pcfg[i].m_min 
 420   3                                              = ((short)Uart_RecBuf[2 + (i << 2)] << 8)    /* 先收高字节 */
 421   3                                                      | (short)Uart_RecBuf[2 + (i << 2) + 1]; 
 422   3                                      
 423   3                                      MenuItem[MENU_ID_00000].m_pcfg[i].m_max 
 424   3                                              = ((short)Uart_RecBuf[2 + (i << 2) + 2] << 8) 
 425   3                                                      | (short)Uart_RecBuf[2 + (i << 2) + 3];                         
 426   3                              }
C51 COMPILER V9.00   UART                                                                  04/09/2016 11:07:34 PAGE 8   

 427   2      
 428   2                              //Menu_Number[0] = (Uart_RecBuf[1] >> 2);  
 429   2      
 430   2                              already_read_param_range = 1;  /* 置为已读到配置参数范围 */     
 431   2      
 432   2                              send_frame_type = UP_REPLY_DONE;  /* 可以发送下一帧 */  
 433   2      
 434   2                      break;
 435   2      
 436   2                      /* 上行写接收参数完成 */
 437   2                      case UP_WRITE_REC_PARAM_DONE:
 438   2      
 439   2                              send_frame_type = UP_REPLY_DONE;  /* 可以发送下一帧 */
 440   2      
 441   2                      break;
 442   2      
 443   2                      /* 上行写进入测试模式成功 */
 444   2                      case UP_WRITE_TEST_MODE_DONE:
 445   2      
 446   2                              send_frame_type = UP_REPLY_DONE;  /* 可以发送下一帧 */
 447   2      
 448   2                      break;
 449   2      
 450   2                      /* 上行写进入学习模式成功 */
 451   2                      case UP_WRITE_LEARN_MODE_DONE:
 452   2      
 453   2                              send_frame_type = UP_REPLY_DONE;  /* 可以发送下一帧 */
 454   2      
 455   2                      break;
 456   2      
 457   2                      /* 上行写切换速度模式成功 */
 458   2                      case UP_WRITE_SPEED_MODE_DONE:
 459   2      
 460   2                              send_frame_type = UP_REPLY_DONE;  /* 可以发送下一帧 */
 461   2      
 462   2                      break;
 463   2      
 464   2                      /* 上行写报警消息成功 */
 465   2                      case UP_WRITE_WARNING_MSG_DONE:
 466   2      
 467   2                              send_frame_type = UP_REPLY_DONE;  /* 可以发送下一帧 */
 468   2      
 469   2                      break;
 470   2      
 471   2      
 472   2      
 473   2                      /* 上行写清除已出筒数成功 */
 474   2                      case UP_WRITE_CLEAR_CNT_DONE:
 475   2      
 476   2                              main_borad_finish_clear = 1;      /* 主板已完成清除计数 */
 477   2      
 478   2                              send_frame_type = UP_REPLY_DONE;  /* 可以发送下一帧 */
 479   2      
 480   2                      break;          
 481   2      
 482   2                      /* 上行写按键成功 */
 483   2                      case UP_WRITE_KEY_DONE:
 484   2      
 485   2                              send_frame_type = UP_REPLY_DONE;  /* 可以发送下一帧 */
 486   2      
 487   2                      break;  
 488   2      
C51 COMPILER V9.00   UART                                                                  04/09/2016 11:07:34 PAGE 9   

 489   2      
 490   2                      /* 校验失败帧，报错 */
 491   2                      case UP_WRITE_CHECK_FAIL:  
 492   2                              
 493   2                              //public_val.Err_Flag = ERR_NUM_ZK_COM_ERR;     
 494   2                              public_val.Err_Flag = MAIN_CHECK_ERROR;           /* 接收到校验错误帧后不发送后续帧 */  
 495   2      
 496   2                              send_frame_type = UP_REPLY_DONE;  /* 可以发送下一帧 */
 497   2                              
 498   2                      break;
 499   2      
 500   2                      default:
 501   2                              break;
 502   2              }
 503   1              
 504   1      }
*** WARNING C280 IN LINE 296 OF UART.C: 'ucSaveLearn1': unreferenced local variable
*** WARNING C280 IN LINE 296 OF UART.C: 'ucSaveLearn2': unreferenced local variable
 505          
 506          /*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 507          名称:   send_data_func(void)
 508          功能：  通讯处理过程 由主程序调用
 509          参数：  无
 510          返回值：无
 511          说明: 版本不匹配: 获取菜单配置信息->获取默认参数->下发菜单参数
 512                版本匹配: 下发菜单参数
 513          ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
 514          void send_data_func(void)
 515          {
 516   1              int i;
 517   1      
 518   1          char *pcTemp = 0;
 519   1              unsigned char sum_byte;
 520   1              
 521   1      
 522   1              /* 每1s读取一次主板状态 */
 523   1      #if 1
 524   1              if(public_val.ms_timer - cnt_read_state > READ_STATE_PERIOD)
 525   1              {       
 526   2                      if (write_param_flag == 0)
 527   2                      {
 528   3                              if (send_frame_type == UP_REPLY_DONE)  /* 上一帧已收到回复，则发送读状态帧 */
 529   3                              {
 530   4                                      send_frame_type = DOWN_READ_STATE;
 531   4                              }
 532   3                      }
 533   2      
 534   2                      cnt_read_state = public_val.ms_timer;
 535   2              }
 536   1      #endif
 537   1      
 538   1              /* 已读到主板状态，且未读配置参数，则读取一次配置参数 */
 539   1      #if 1   
 540   1              if ((public_val.version != 0) && (already_read_param == 0))
 541   1              {
 542   2                      //if (public_val.ms_timer - cnt_read_param > 100)
 543   2                      {               
 544   3      #if 1
 545   3                              if (send_frame_type == UP_REPLY_DONE)  /* 上一帧已收到回复，则发送读参数帧 */
 546   3                              {
 547   4                                      //send_frame_type = DOWN_READ_PARAM;                            
 548   4      
C51 COMPILER V9.00   UART                                                                  04/09/2016 11:07:34 PAGE 10  

 549   4                                      // 写默认参数
 550   4                                      // 最后一个参数不是0x55aa则写一次默认参数
 551   4                                      if (public_val.Disp_Dz_10101[MENU_ID_10101_MAX_ITEM] != 0x55aa)
 552   4                                      {
 553   5                                              public_val.Disp_Dz_00000[0] = 310;   //纸长                                     
 554   5                                              public_val.Disp_Dz_00000[1] = 300;   /* 设定筒数 */
 555   5                                              
 556   5                                              public_val.Disp_Dz_10101[0] = 2;     /* 1、报警持续时间:s */
 557   5                                              public_val.Disp_Dz_10101[1] = 15;    /* 2、堵筒检测时间1, 时基感应到堵筒检测1感应报警的延迟时间:0.1s 
             -*/
 558   5                                              public_val.Disp_Dz_10101[2] = 15;    /* 3、堵筒检测时间2, 时基感应到堵筒检测2感应报警的延迟时间:0.1s 
             -*/
 559   5                                              public_val.Disp_Dz_10101[3] = 0;     /* 4、步进电机方向 */
 560   5                                              public_val.Disp_Dz_10101[4] = 0;     // 5、送纸速度增益
 561   5                                              public_val.Disp_Dz_10101[5] = 320;   /* 6、步进电机脉冲当量:0.1个/mm (4000*2 /(2*3.14*40)) 减速比2 */
 562   5                                              public_val.Disp_Dz_10101[6] = 89;    /* 7、发纸电机链轮减速比 */
 563   5                                              public_val.Disp_Dz_10101[7] = 400;   /* 8、发纸压轮半径:0.1mm */
 564   5                                              public_val.Disp_Dz_10101[8] = 20;   /* 9、发纸电机PID调速的比例系数*100 */
 565   5                                      #ifdef SZ_01    // SZ_01
                                                      public_val.Disp_Dz_10101[9] = 85;   /* 10、发纸电机启动PWM占空比 */
                                                      public_val.Disp_Dz_10101[10] = 85;   /* 11、切纸电机启动PWM占空比 */
                                                      public_val.Disp_Dz_10101[12] = 70;   /* 12、切纸电机目标PWM占空比 */
                                                      public_val.Disp_Dz_10101[13] = 10;   /* 13、发纸最高速度 */
                                                      public_val.Disp_Dz_10101[14] = 1;    /* 14、发纸最低速度 */
                                                      public_val.Disp_Dz_10101[15] = 40;   /* 15、送纸角度 */
                                                      public_val.Disp_Dz_10101[16] = 3;    /* 16、切刀控制模式 3:七段调速 */
                                                      public_val.Disp_Dz_10101[17] = 84;   /* 17、切纸停止速度 */
                                                      public_val.Disp_Dz_10101[18] = 1;    /* 18、备用 */
                                                      public_val.Disp_Dz_10101[19] = 1;    /* 19、备用 */
                                                      public_val.Disp_Dz_10101[20] = 60;   /* 20、调速最高速度 */
                                              #endif
 578   5                                              
 579   5                                      #ifdef SZ_02            // SZ_02
 580   5                                              public_val.Disp_Dz_10101[9] = 84;   /* 10、发纸电机启动PWM占空比 */                             
 581   5                                              public_val.Disp_Dz_10101[10] = 2;    /* 11、切纸电机链轮减速比 */
 582   5                                              public_val.Disp_Dz_10101[11] = 120;  /* 12、切纸电机目标速度:0.1khz */
 583   5                                              public_val.Disp_Dz_10101[12] = 10;   /* 13、发纸最高速度 */
 584   5                                              public_val.Disp_Dz_10101[13] = 1;    /* 14、发纸最低速度 */
 585   5                                              public_val.Disp_Dz_10101[14] = 73;   /* 15、送纸角度:0.1k脉冲 */
 586   5                                              public_val.Disp_Dz_10101[15] = 80;    /* 16、备用 */
 587   5                                              public_val.Disp_Dz_10101[16] = 1;    /* 16、备用 */
 588   5                                              public_val.Disp_Dz_10101[17] = 1;   /* 17、备用 */
 589   5                                              public_val.Disp_Dz_10101[18] = 1;    /* 18、备用 */
 590   5                                              public_val.Disp_Dz_10101[19] = 1;    /* 19、备用 */
 591   5                                              public_val.Disp_Dz_10101[20] = 1;   /* 20、备用 */
 592   5                                      #endif
 593   5      
 594   5                                      #ifdef SZ_03
                                                      public_val.Disp_Dz_10101[1] = 30;    /* 2、堵筒检测时间1, 时基感应到堵筒检测1感应报警的延迟时间:0.1s 
             -*/
                                                      public_val.Disp_Dz_10101[2] = 30;    /* 3、堵筒检测时间2, 时基感应到堵筒检测2感应报警的延迟时间:0.1s 
             -*/
                                                      public_val.Disp_Dz_10101[3] = 1;     /* 4、步进电机方向 */
                                                      public_val.Disp_Dz_10101[4] = 20;    // 5、送纸速度增益                                 
                                                      public_val.Disp_Dz_10101[5] = 490;   /* 6、 送纸步进电机脉冲当量:0.1个/mm (4000*(36/12) /(2*3.14*39))
             - 减速比36/12 */
                                                      public_val.Disp_Dz_10101[6] = 1;     /* 7、切纸电机链轮减速比 */
                                                      public_val.Disp_Dz_10101[7] = 150;   /* 8、切纸电机目标速度:0.1khz */
                                                      public_val.Disp_Dz_10101[8] = 37;   /* 9、送纸角度:0.1k脉冲 */
                                                      public_val.Disp_Dz_10101[11] = 1;    /* 10、备用 */
                                                      public_val.Disp_Dz_10101[12] = 1;    /* 11、备用 */
                                                      public_val.Disp_Dz_10101[13] = 1;    /* 12、备用 */
C51 COMPILER V9.00   UART                                                                  04/09/2016 11:07:34 PAGE 11  

                                                      public_val.Disp_Dz_10101[14] = 1;    /* 13、备用 */     
                                                      public_val.Disp_Dz_10101[15] = 1;    /* 14、备用 */
                                                      public_val.Disp_Dz_10101[16] = 1;    /* 16、备用 */
                                                      public_val.Disp_Dz_10101[17] = 1;   /* 17、备用 */
                                                      public_val.Disp_Dz_10101[18] = 1;    /* 18、备用 */
                                                      public_val.Disp_Dz_10101[19] = 1;    /* 19、备用 */
                                                      public_val.Disp_Dz_10101[20] = 1;   /* 20、备用 */
                                              #endif
 614   5      
 615   5                                              public_val.Disp_Dz_10101[MENU_ID_10101_MAX_ITEM] = 0x55aa;                                      
 616   5      
 617   5                                              func_menu_update(MENU_ID_00000);
 618   5                                              func_menu_update(MENU_ID_10101);
 619   5                                              
 620   5                                      }
 621   4      
 622   4                                      write_param_flag = 1;    // 更新下位机参数
 623   4      
 624   4                                      already_read_param = 1;  /* 置为已读到配置参数 */
 625   4      
 626   4                                      send_frame_type = UP_REPLY_DONE;  /* 可以发送下一帧 */                          
 627   4                                      
 628   4                              }
 629   3      #endif
 630   3                              //cnt_read_param = public_val.ms_timer;
 631   3                      }
 632   2              }
 633   1      #endif  
 634   1      
 635   1              /* 已读到配置参数，且未读配置参数范围，则读取一次配置参数范围 */
 636   1      #if 1   
 637   1              if ((already_read_param == 1) && (already_read_param_range == 0))
 638   1              {
 639   2                      //if (public_val.ms_timer - cnt_read_param > 100)
 640   2                      {               
 641   3                              if (send_frame_type == UP_REPLY_DONE)  /* 上一帧已收到回复，则发送读参数帧 */
 642   3                              {
 643   4                                      send_frame_type = DOWN_READ_PARAM_RANGE;
 644   4                              }
 645   3      
 646   3                              //cnt_read_param = public_val.ms_timer;
 647   3                      }
 648   2              }
 649   1      #endif  
 650   1      
 651   1      
 652   1              /* 当前需要保存配置参数到主板 */
 653   1      #if 1
 654   1              if (write_param_flag != 0)
 655   1              {
 656   2                      if (send_frame_type == UP_REPLY_DONE)  /* 上一帧已收到回复，则发送写参数帧 */
 657   2                      {
 658   3                              send_frame_type = DOWN_WRITE_PARAM;
 659   3                      }
 660   2              }
 661   1      #endif
 662   1      
 663   1      
 664   1              /* 当前需要写学习模式到主板 */
 665   1      #if 1
 666   1              if (write_learn_mode_flag != 0)
 667   1              {
C51 COMPILER V9.00   UART                                                                  04/09/2016 11:07:34 PAGE 12  

 668   2                      if (send_frame_type == UP_REPLY_DONE)  /* 上一帧已收到回复，则发送写测试模式帧 */
 669   2                      {
 670   3                              send_frame_type = DOWN_WRITE_LEARN_MODE;
 671   3                      }
 672   2              }
 673   1      #endif
 674   1      
 675   1      #if 1
 676   1              if (write_warning_flag != 0)
 677   1              {
 678   2                      if (send_frame_type == UP_REPLY_DONE)  /* 上一帧已收到回复，则发送写测试模式帧 */
 679   2                      {
 680   3                              send_frame_type = DOWN_WRITE_WARNING_MSG;
 681   3                      }
 682   2              }
 683   1      #endif
 684   1      
 685   1      
 686   1      
 687   1              /* 当前需要写测试模式到主板 */
 688   1      #if 1
 689   1              if (write_test_mode_flag != 0)
 690   1              {
 691   2                      if (send_frame_type == UP_REPLY_DONE)  /* 上一帧已收到回复，则发送写测试模式帧 */
 692   2                      {
 693   3                              send_frame_type = DOWN_WRITE_TEST_MODE;
 694   3                      }
 695   2              }
 696   1      #endif
 697   1      
 698   1              /* 当前需要写速度模式到主板 */
 699   1      #if 1
 700   1              if (write_speed_mode_flag != 0)
 701   1              {
 702   2                      if (send_frame_type == UP_REPLY_DONE)  /* 上一帧已收到回复，则发送写测试模式帧 */
 703   2                      {
 704   3                              send_frame_type = DOWN_WRITE_SPEED_MODE;
 705   3                      }
 706   2              }
 707   1      #endif
 708   1      
 709   1      
 710   1              /* 当前需要写清除已出筒数主板 */
 711   1      #if 1
 712   1              if (write_clear_cnt_flag != 0)
 713   1              {
 714   2                      if (send_frame_type == UP_REPLY_DONE)  /* 上一帧已收到回复，则发送写测试模式帧 */
 715   2                      {
 716   3                              send_frame_type = DOWN_WRITE_CLEAR_CNT;
 717   3                      }
 718   2              }
 719   1      #endif
 720   1      
 721   1              /* 当前需要写按键到主板 */
 722   1      #if 1
 723   1              if (write_key_flag != 0)
 724   1              {
 725   2                      if (send_frame_type == UP_REPLY_DONE)  /* 上一帧已收到回复，则发送写按键帧 */
 726   2                      {
 727   3                              send_frame_type = DOWN_WRITE_KEY;
 728   3                      }
 729   2              }       
C51 COMPILER V9.00   UART                                                                  04/09/2016 11:07:34 PAGE 13  

 730   1      #endif
 731   1      
 732   1              /* 发送组帧 */
 733   1              switch (send_frame_type)
 734   1              {
 735   2                      case DOWN_READ_PARAM:  /* 下行读参数帧 */
 736   2                              memset(uart_send_buf, 0, sizeof(uart_send_buf));
 737   2                              
 738   2                              uart_send_buf[0] = DOWN_READ_PARAM;
 739   2                              uart_send_buf[1] = 1;                   
 740   2                              uart_send_buf[2] = 0;
 741   2                              uart_send_buf[3] = 1;
 742   2      
 743   2                              Send_UartBuf(uart_send_buf);
 744   2      
 745   2                              send_frame_type = DOWN_READ_PARAM_SENT;   /* 置为读参数帧已发送 */
 746   2                              
 747   2                              break;
 748   2      
 749   2                      case DOWN_READ_STATE:  /* 下行读状态 */
 750   2                              memset(uart_send_buf, 0, sizeof(uart_send_buf));
 751   2                              
 752   2                              uart_send_buf[0] = DOWN_READ_STATE;
 753   2                              uart_send_buf[1] = 1;                   
 754   2                              uart_send_buf[2] = 0;
 755   2                              uart_send_buf[3] = 2;
 756   2      
 757   2                              Send_UartBuf(uart_send_buf);
 758   2      
 759   2                              send_frame_type = DOWN_READ_STATE_SENT;   /* 置为读状态帧已发送 */
 760   2                              
 761   2                              break;
 762   2      
 763   2                      case DOWN_READ_PARAM_RANGE:  /* 下行读参数范围 */
 764   2                              memset(uart_send_buf, 0, sizeof(uart_send_buf));
 765   2      
 766   2                              uart_send_buf[0] = DOWN_READ_PARAM_RANGE;
 767   2                              uart_send_buf[1] = 1;                   
 768   2                              uart_send_buf[2] = 0;
 769   2                              uart_send_buf[3] = 4;           
 770   2      
 771   2                              Send_UartBuf(uart_send_buf);
 772   2      
 773   2                              send_frame_type = DOWN_READ_PARAM_RANGE_SENT;   /* 置为读参数范围帧已发送 */
 774   2      
 775   2                              
 776   2                              break;
 777   2      
 778   2      
 779   2                      case DOWN_WRITE_PARAM:  /* 下行写配置参数 */
 780   2                              memset(uart_send_buf, 0, sizeof(uart_send_buf));                        
 781   2      
 782   2                              uart_send_buf[0] = DOWN_WRITE_PARAM;
 783   2                              uart_send_buf[1] = COM_MENU_MAX_ITEM << 1;      
 784   2      
 785   2                              pcTemp = (char *)&public_val.menu_parm[0];
 786   2      
 787   2                              sum_byte = uart_send_buf[0] + uart_send_buf[1];                 
 788   2                              
 789   2                              for (i = 0; i < (COM_MENU_MAX_ITEM << 1); i++)
 790   2                              {
 791   3                                      uart_send_buf[2 + i] = pcTemp[i];
C51 COMPILER V9.00   UART                                                                  04/09/2016 11:07:34 PAGE 14  

 792   3      
 793   3                                      /* 计算校验和 */
 794   3                                      sum_byte += pcTemp[i];                          
 795   3                              }
 796   2                              
 797   2                              //sum_byte &= 0xff;
 798   2                              
 799   2                              uart_send_buf[2 + (COM_MENU_MAX_ITEM << 1)] = sum_byte;
 800   2              
 801   2                              Send_UartBuf(uart_send_buf);
 802   2      
 803   2                              send_frame_type = DOWN_WRITE_PARAM_SENT;   /* 置为写参数帧已发送 */
 804   2      
 805   2      
 806   2                              write_param_flag = 0;  /* 已完成一次写配置参数，置为不写状态 */ 
 807   2                              
 808   2                              break;
 809   2      
 810   2                      case DOWN_WRITE_TEST_MODE:  /* 下行写进入测试模式 */
 811   2                              memset(uart_send_buf, 0, sizeof(uart_send_buf));                        
 812   2      
 813   2                              uart_send_buf[0] = DOWN_WRITE_TEST_MODE;
 814   2                              uart_send_buf[1] = 1;                   
 815   2                              uart_send_buf[2] = test_mode;
 816   2                              uart_send_buf[3] = 5 + test_mode;               
 817   2      
 818   2                              Send_UartBuf(uart_send_buf);
 819   2      
 820   2                              send_frame_type = DOWN_WRITE_TEST_MODE_SENT;   /* 置为写测试模式帧已发送 */                     
 821   2      
 822   2                              write_test_mode_flag = 0;  /* 已完成一次写测试模式，置为不写状态 */     
 823   2      
 824   2                              break;
 825   2      
 826   2                      case DOWN_WRITE_LEARN_MODE:  /* 下行写进入学习模式 */
 827   2                              memset(uart_send_buf, 0, sizeof(uart_send_buf));                        
 828   2      
 829   2                              uart_send_buf[0] = DOWN_WRITE_LEARN_MODE;
 830   2                              uart_send_buf[1] = 1;                   
 831   2                              uart_send_buf[2] = 0;  // no use
 832   2                              uart_send_buf[3] = 8;           
 833   2      
 834   2                              Send_UartBuf(uart_send_buf);
 835   2      
 836   2                              send_frame_type = DOWN_WRITE_LEARN_MODE_SENT;   /* 置为写学习模式帧已发送 */                    
 837   2      
 838   2                              write_learn_mode_flag = 0;  /* 已完成一次写学习模式，置为不写状态 */    
 839   2      
 840   2                              break;
 841   2      
 842   2                      case DOWN_WRITE_SPEED_MODE:  /* 下行写切换速度模式 */
 843   2      
 844   2                              memset(uart_send_buf, 0, sizeof(uart_send_buf));                        
 845   2      
 846   2                              uart_send_buf[0] = DOWN_WRITE_SPEED_MODE;
 847   2                              uart_send_buf[1] = 1;                   
 848   2                              uart_send_buf[2] = speed_mode;  
 849   2                              uart_send_buf[3] = 9 + speed_mode;              
 850   2      
 851   2                              Send_UartBuf(uart_send_buf);
 852   2      
 853   2                              send_frame_type = DOWN_WRITE_SPEED_MODE_SENT;   /* 置为写速度模式帧已发送 */                    
C51 COMPILER V9.00   UART                                                                  04/09/2016 11:07:34 PAGE 15  

 854   2      
 855   2                              write_speed_mode_flag = 0;  /* 已完成一次写速度模式，置为不写状态 */    
 856   2      
 857   2      
 858   2                              break;
 859   2      
 860   2                      case DOWN_WRITE_WARNING_MSG:
 861   2      
 862   2                              memset(uart_send_buf, 0, sizeof(uart_send_buf));                        
 863   2      
 864   2                              uart_send_buf[0] = DOWN_WRITE_WARNING_MSG;
 865   2                              uart_send_buf[1] = 1;                   
 866   2                              uart_send_buf[2] = 0;   // no use
 867   2                              uart_send_buf[3] = 10;          
 868   2      
 869   2                              Send_UartBuf(uart_send_buf);
 870   2      
 871   2                              send_frame_type = DOWN_WRITE_WARNING_MSG_SENT;   
 872   2      
 873   2                              write_warning_flag = 0;  
 874   2      
 875   2                              break;
 876   2      
 877   2                      case DOWN_WRITE_CLEAR_CNT:  /* 下行写清除已出筒数 */
 878   2                              memset(uart_send_buf, 0, sizeof(uart_send_buf));                        
 879   2      
 880   2                              uart_send_buf[0] = DOWN_WRITE_CLEAR_CNT;
 881   2                              uart_send_buf[1] = 1;                   
 882   2                              uart_send_buf[2] = 0;
 883   2                              uart_send_buf[3] = 6;           
 884   2      
 885   2                              Send_UartBuf(uart_send_buf);
 886   2      
 887   2                              send_frame_type = DOWN_WRITE_CLEAR_CNT_SENT;                    
 888   2      
 889   2                              write_clear_cnt_flag = 0;  
 890   2      
 891   2                              break;
 892   2      
 893   2                      case DOWN_WRITE_KEY:  /* 下行写按键操作 */
 894   2                              memset(uart_send_buf, 0, sizeof(uart_send_buf));                        
 895   2      
 896   2                              uart_send_buf[0] = DOWN_WRITE_KEY;
 897   2                              uart_send_buf[1] = 3;                   
 898   2                              uart_send_buf[2] = (char)gsKeyVal;
 899   2                              uart_send_buf[3] = (char)(gsKeyVal >> 8);
 900   2                              uart_send_buf[4] = gcKeyType;                   
 901   2                              uart_send_buf[5] = 9 + uart_send_buf[2] + uart_send_buf[3] 
 902   2                                      + uart_send_buf[4];
 903   2      
 904   2                              Send_UartBuf(uart_send_buf);
 905   2      
 906   2                              send_frame_type = DOWN_WRITE_KEY_SENT;                          
 907   2      
 908   2                              write_key_flag = 0;  
 909   2      
 910   2                              break;
 911   2      
 912   2                      default:
 913   2                              break;
 914   2              }
 915   1      
C51 COMPILER V9.00   UART                                                                  04/09/2016 11:07:34 PAGE 16  

 916   1      
 917   1              //if (send_frame_type != 0x7f)     /* 有帧要发送 */
 918   1              //{             
 919   1              //      Send_UartBuf(uart_send_buf);  //deleted for test
 920   1      
 921   1                      //send_frame_type = 0x7f;      /* 发送完成，置为无效帧，无帧发送 */
 922   1              //}
 923   1              
 924   1      }
 925          
 926          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2007    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    100    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      7      16
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
